use icicle_vm::cpu::mem::{MemError, MemResult};
pub(crate) struct PeripheralPage0x10000000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x10000000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 268435456;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (16..=23, 17..=24) => {
                if _start < 20 && _end > 16 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_codepagesize()?
                        .to_ne_bytes();
                    if _start <= 16 && _end > 16 {
                        _buf[(16 - _start) as usize] = _value[0];
                    }
                    if _start <= 17 && _end > 17 {
                        _buf[(17 - _start) as usize] = _value[1];
                    }
                    if _start <= 18 && _end > 18 {
                        _buf[(18 - _start) as usize] = _value[2];
                    }
                    if _start <= 19 && _end > 19 {
                        _buf[(19 - _start) as usize] = _value[3];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_codesize()?
                        .to_ne_bytes();
                    if _start <= 20 && _end > 20 {
                        _buf[(20 - _start) as usize] = _value[0];
                    }
                    if _start <= 21 && _end > 21 {
                        _buf[(21 - _start) as usize] = _value[1];
                    }
                    if _start <= 22 && _end > 22 {
                        _buf[(22 - _start) as usize] = _value[2];
                    }
                    if _start <= 23 && _end > 23 {
                        _buf[(23 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (40..=47, 41..=48) => {
                if _start < 44 && _end > 40 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_clenr0()?
                        .to_ne_bytes();
                    if _start <= 40 && _end > 40 {
                        _buf[(40 - _start) as usize] = _value[0];
                    }
                    if _start <= 41 && _end > 41 {
                        _buf[(41 - _start) as usize] = _value[1];
                    }
                    if _start <= 42 && _end > 42 {
                        _buf[(42 - _start) as usize] = _value[2];
                    }
                    if _start <= 43 && _end > 43 {
                        _buf[(43 - _start) as usize] = _value[3];
                    }
                }
                if _start < 48 && _end > 44 {
                    let _value = self.read_ficr_ppfc()?.to_ne_bytes();
                    if _start <= 44 && _end > 44 {
                        _buf[(44 - _start) as usize] = _value[0];
                    }
                    if _start <= 45 && _end > 45 {
                        _buf[(45 - _start) as usize] = _value[1];
                    }
                    if _start <= 46 && _end > 46 {
                        _buf[(46 - _start) as usize] = _value[2];
                    }
                    if _start <= 47 && _end > 47 {
                        _buf[(47 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (52..=71, 53..=72) => {
                if _start < 56 && _end > 52 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_numramblock()?
                        .to_ne_bytes();
                    if _start <= 52 && _end > 52 {
                        _buf[(52 - _start) as usize] = _value[0];
                    }
                    if _start <= 53 && _end > 53 {
                        _buf[(53 - _start) as usize] = _value[1];
                    }
                    if _start <= 54 && _end > 54 {
                        _buf[(54 - _start) as usize] = _value[2];
                    }
                    if _start <= 55 && _end > 55 {
                        _buf[(55 - _start) as usize] = _value[3];
                    }
                }
                if _start < 60 && _end > 56 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_sizeramblocks(0)?
                        .to_ne_bytes();
                    if _start <= 56 && _end > 56 {
                        _buf[(56 - _start) as usize] = _value[0];
                    }
                    if _start <= 57 && _end > 57 {
                        _buf[(57 - _start) as usize] = _value[1];
                    }
                    if _start <= 58 && _end > 58 {
                        _buf[(58 - _start) as usize] = _value[2];
                    }
                    if _start <= 59 && _end > 59 {
                        _buf[(59 - _start) as usize] = _value[3];
                    }
                }
                if _start < 76 && _end > 72 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_sizeramblocks(1)?
                        .to_ne_bytes();
                    if _start <= 72 && _end > 72 {
                        _buf[(72 - _start) as usize] = _value[0];
                    }
                    if _start <= 73 && _end > 73 {
                        _buf[(73 - _start) as usize] = _value[1];
                    }
                    if _start <= 74 && _end > 74 {
                        _buf[(74 - _start) as usize] = _value[2];
                    }
                    if _start <= 75 && _end > 75 {
                        _buf[(75 - _start) as usize] = _value[3];
                    }
                }
                if _start < 92 && _end > 88 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_sizeramblocks(2)?
                        .to_ne_bytes();
                    if _start <= 88 && _end > 88 {
                        _buf[(88 - _start) as usize] = _value[0];
                    }
                    if _start <= 89 && _end > 89 {
                        _buf[(89 - _start) as usize] = _value[1];
                    }
                    if _start <= 90 && _end > 90 {
                        _buf[(90 - _start) as usize] = _value[2];
                    }
                    if _start <= 91 && _end > 91 {
                        _buf[(91 - _start) as usize] = _value[3];
                    }
                }
                if _start < 108 && _end > 104 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_sizeramblocks(3)?
                        .to_ne_bytes();
                    if _start <= 104 && _end > 104 {
                        _buf[(104 - _start) as usize] = _value[0];
                    }
                    if _start <= 105 && _end > 105 {
                        _buf[(105 - _start) as usize] = _value[1];
                    }
                    if _start <= 106 && _end > 106 {
                        _buf[(106 - _start) as usize] = _value[2];
                    }
                    if _start <= 107 && _end > 107 {
                        _buf[(107 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (92..=103, 93..=104) => {
                if _start < 96 && _end > 92 {
                    let _value = self.read_ficr_configid()?.to_ne_bytes();
                    if _start <= 92 && _end > 92 {
                        _buf[(92 - _start) as usize] = _value[0];
                    }
                    if _start <= 93 && _end > 93 {
                        _buf[(93 - _start) as usize] = _value[1];
                    }
                    if _start <= 94 && _end > 94 {
                        _buf[(94 - _start) as usize] = _value[2];
                    }
                    if _start <= 95 && _end > 95 {
                        _buf[(95 - _start) as usize] = _value[3];
                    }
                }
                if _start < 100 && _end > 96 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_deviceidn(0)?
                        .to_ne_bytes();
                    if _start <= 96 && _end > 96 {
                        _buf[(96 - _start) as usize] = _value[0];
                    }
                    if _start <= 97 && _end > 97 {
                        _buf[(97 - _start) as usize] = _value[1];
                    }
                    if _start <= 98 && _end > 98 {
                        _buf[(98 - _start) as usize] = _value[2];
                    }
                    if _start <= 99 && _end > 99 {
                        _buf[(99 - _start) as usize] = _value[3];
                    }
                }
                if _start < 116 && _end > 112 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_deviceidn(1)?
                        .to_ne_bytes();
                    if _start <= 112 && _end > 112 {
                        _buf[(112 - _start) as usize] = _value[0];
                    }
                    if _start <= 113 && _end > 113 {
                        _buf[(113 - _start) as usize] = _value[1];
                    }
                    if _start <= 114 && _end > 114 {
                        _buf[(114 - _start) as usize] = _value[2];
                    }
                    if _start <= 115 && _end > 115 {
                        _buf[(115 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (128..=195, 129..=196) => {
                if _start < 132 && _end > 128 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_ern(0)?.to_ne_bytes();
                    if _start <= 128 && _end > 128 {
                        _buf[(128 - _start) as usize] = _value[0];
                    }
                    if _start <= 129 && _end > 129 {
                        _buf[(129 - _start) as usize] = _value[1];
                    }
                    if _start <= 130 && _end > 130 {
                        _buf[(130 - _start) as usize] = _value[2];
                    }
                    if _start <= 131 && _end > 131 {
                        _buf[(131 - _start) as usize] = _value[3];
                    }
                }
                if _start < 148 && _end > 144 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_ern(1)?.to_ne_bytes();
                    if _start <= 144 && _end > 144 {
                        _buf[(144 - _start) as usize] = _value[0];
                    }
                    if _start <= 145 && _end > 145 {
                        _buf[(145 - _start) as usize] = _value[1];
                    }
                    if _start <= 146 && _end > 146 {
                        _buf[(146 - _start) as usize] = _value[2];
                    }
                    if _start <= 147 && _end > 147 {
                        _buf[(147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 164 && _end > 160 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_ern(2)?.to_ne_bytes();
                    if _start <= 160 && _end > 160 {
                        _buf[(160 - _start) as usize] = _value[0];
                    }
                    if _start <= 161 && _end > 161 {
                        _buf[(161 - _start) as usize] = _value[1];
                    }
                    if _start <= 162 && _end > 162 {
                        _buf[(162 - _start) as usize] = _value[2];
                    }
                    if _start <= 163 && _end > 163 {
                        _buf[(163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 180 && _end > 176 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_ern(3)?.to_ne_bytes();
                    if _start <= 176 && _end > 176 {
                        _buf[(176 - _start) as usize] = _value[0];
                    }
                    if _start <= 177 && _end > 177 {
                        _buf[(177 - _start) as usize] = _value[1];
                    }
                    if _start <= 178 && _end > 178 {
                        _buf[(178 - _start) as usize] = _value[2];
                    }
                    if _start <= 179 && _end > 179 {
                        _buf[(179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 148 && _end > 144 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_irn(0)?.to_ne_bytes();
                    if _start <= 144 && _end > 144 {
                        _buf[(144 - _start) as usize] = _value[0];
                    }
                    if _start <= 145 && _end > 145 {
                        _buf[(145 - _start) as usize] = _value[1];
                    }
                    if _start <= 146 && _end > 146 {
                        _buf[(146 - _start) as usize] = _value[2];
                    }
                    if _start <= 147 && _end > 147 {
                        _buf[(147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 164 && _end > 160 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_irn(1)?.to_ne_bytes();
                    if _start <= 160 && _end > 160 {
                        _buf[(160 - _start) as usize] = _value[0];
                    }
                    if _start <= 161 && _end > 161 {
                        _buf[(161 - _start) as usize] = _value[1];
                    }
                    if _start <= 162 && _end > 162 {
                        _buf[(162 - _start) as usize] = _value[2];
                    }
                    if _start <= 163 && _end > 163 {
                        _buf[(163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 180 && _end > 176 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_irn(2)?.to_ne_bytes();
                    if _start <= 176 && _end > 176 {
                        _buf[(176 - _start) as usize] = _value[0];
                    }
                    if _start <= 177 && _end > 177 {
                        _buf[(177 - _start) as usize] = _value[1];
                    }
                    if _start <= 178 && _end > 178 {
                        _buf[(178 - _start) as usize] = _value[2];
                    }
                    if _start <= 179 && _end > 179 {
                        _buf[(179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 196 && _end > 192 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_irn(3)?.to_ne_bytes();
                    if _start <= 192 && _end > 192 {
                        _buf[(192 - _start) as usize] = _value[0];
                    }
                    if _start <= 193 && _end > 193 {
                        _buf[(193 - _start) as usize] = _value[1];
                    }
                    if _start <= 194 && _end > 194 {
                        _buf[(194 - _start) as usize] = _value[2];
                    }
                    if _start <= 195 && _end > 195 {
                        _buf[(195 - _start) as usize] = _value[3];
                    }
                }
                if _start < 164 && _end > 160 {
                    let _value = self.read_ficr_deviceaddrtype()?.to_ne_bytes();
                    if _start <= 160 && _end > 160 {
                        _buf[(160 - _start) as usize] = _value[0];
                    }
                    if _start <= 161 && _end > 161 {
                        _buf[(161 - _start) as usize] = _value[1];
                    }
                    if _start <= 162 && _end > 162 {
                        _buf[(162 - _start) as usize] = _value[2];
                    }
                    if _start <= 163 && _end > 163 {
                        _buf[(163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 168 && _end > 164 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_deviceaddrn(0)?
                        .to_ne_bytes();
                    if _start <= 164 && _end > 164 {
                        _buf[(164 - _start) as usize] = _value[0];
                    }
                    if _start <= 165 && _end > 165 {
                        _buf[(165 - _start) as usize] = _value[1];
                    }
                    if _start <= 166 && _end > 166 {
                        _buf[(166 - _start) as usize] = _value[2];
                    }
                    if _start <= 167 && _end > 167 {
                        _buf[(167 - _start) as usize] = _value[3];
                    }
                }
                if _start < 184 && _end > 180 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_deviceaddrn(1)?
                        .to_ne_bytes();
                    if _start <= 180 && _end > 180 {
                        _buf[(180 - _start) as usize] = _value[0];
                    }
                    if _start <= 181 && _end > 181 {
                        _buf[(181 - _start) as usize] = _value[1];
                    }
                    if _start <= 182 && _end > 182 {
                        _buf[(182 - _start) as usize] = _value[2];
                    }
                    if _start <= 183 && _end > 183 {
                        _buf[(183 - _start) as usize] = _value[3];
                    }
                }
                if _start < 176 && _end > 172 {
                    let _value = self.read_ficr_overrideen()?.to_ne_bytes();
                    if _start <= 172 && _end > 172 {
                        _buf[(172 - _start) as usize] = _value[0];
                    }
                    if _start <= 173 && _end > 173 {
                        _buf[(173 - _start) as usize] = _value[1];
                    }
                    if _start <= 174 && _end > 174 {
                        _buf[(174 - _start) as usize] = _value[2];
                    }
                    if _start <= 175 && _end > 175 {
                        _buf[(175 - _start) as usize] = _value[3];
                    }
                }
                if _start < 180 && _end > 176 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_nrf_1mbitn(0)?
                        .to_ne_bytes();
                    if _start <= 176 && _end > 176 {
                        _buf[(176 - _start) as usize] = _value[0];
                    }
                    if _start <= 177 && _end > 177 {
                        _buf[(177 - _start) as usize] = _value[1];
                    }
                    if _start <= 178 && _end > 178 {
                        _buf[(178 - _start) as usize] = _value[2];
                    }
                    if _start <= 179 && _end > 179 {
                        _buf[(179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 196 && _end > 192 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_nrf_1mbitn(1)?
                        .to_ne_bytes();
                    if _start <= 192 && _end > 192 {
                        _buf[(192 - _start) as usize] = _value[0];
                    }
                    if _start <= 193 && _end > 193 {
                        _buf[(193 - _start) as usize] = _value[1];
                    }
                    if _start <= 194 && _end > 194 {
                        _buf[(194 - _start) as usize] = _value[2];
                    }
                    if _start <= 195 && _end > 195 {
                        _buf[(195 - _start) as usize] = _value[3];
                    }
                }
                if _start < 212 && _end > 208 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_nrf_1mbitn(2)?
                        .to_ne_bytes();
                    if _start <= 208 && _end > 208 {
                        _buf[(208 - _start) as usize] = _value[0];
                    }
                    if _start <= 209 && _end > 209 {
                        _buf[(209 - _start) as usize] = _value[1];
                    }
                    if _start <= 210 && _end > 210 {
                        _buf[(210 - _start) as usize] = _value[2];
                    }
                    if _start <= 211 && _end > 211 {
                        _buf[(211 - _start) as usize] = _value[3];
                    }
                }
                if _start < 228 && _end > 224 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_nrf_1mbitn(3)?
                        .to_ne_bytes();
                    if _start <= 224 && _end > 224 {
                        _buf[(224 - _start) as usize] = _value[0];
                    }
                    if _start <= 225 && _end > 225 {
                        _buf[(225 - _start) as usize] = _value[1];
                    }
                    if _start <= 226 && _end > 226 {
                        _buf[(226 - _start) as usize] = _value[2];
                    }
                    if _start <= 227 && _end > 227 {
                        _buf[(227 - _start) as usize] = _value[3];
                    }
                }
                if _start < 244 && _end > 240 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_nrf_1mbitn(4)?
                        .to_ne_bytes();
                    if _start <= 240 && _end > 240 {
                        _buf[(240 - _start) as usize] = _value[0];
                    }
                    if _start <= 241 && _end > 241 {
                        _buf[(241 - _start) as usize] = _value[1];
                    }
                    if _start <= 242 && _end > 242 {
                        _buf[(242 - _start) as usize] = _value[2];
                    }
                    if _start <= 243 && _end > 243 {
                        _buf[(243 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (236..=255, 237..=256) => {
                if _start < 240 && _end > 236 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_ble_1mbitn(0)?
                        .to_ne_bytes();
                    if _start <= 236 && _end > 236 {
                        _buf[(236 - _start) as usize] = _value[0];
                    }
                    if _start <= 237 && _end > 237 {
                        _buf[(237 - _start) as usize] = _value[1];
                    }
                    if _start <= 238 && _end > 238 {
                        _buf[(238 - _start) as usize] = _value[2];
                    }
                    if _start <= 239 && _end > 239 {
                        _buf[(239 - _start) as usize] = _value[3];
                    }
                }
                if _start < 256 && _end > 252 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_ble_1mbitn(1)?
                        .to_ne_bytes();
                    if _start <= 252 && _end > 252 {
                        _buf[(252 - _start) as usize] = _value[0];
                    }
                    if _start <= 253 && _end > 253 {
                        _buf[(253 - _start) as usize] = _value[1];
                    }
                    if _start <= 254 && _end > 254 {
                        _buf[(254 - _start) as usize] = _value[2];
                    }
                    if _start <= 255 && _end > 255 {
                        _buf[(255 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_ble_1mbitn(2)?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_ble_1mbitn(3)?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 304 && _end > 300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_ble_1mbitn(4)?
                        .to_ne_bytes();
                    if _start <= 300 && _end > 300 {
                        _buf[(300 - _start) as usize] = _value[0];
                    }
                    if _start <= 301 && _end > 301 {
                        _buf[(301 - _start) as usize] = _value[1];
                    }
                    if _start <= 302 && _end > 302 {
                        _buf[(302 - _start) as usize] = _value[2];
                    }
                    if _start <= 303 && _end > 303 {
                        _buf[(303 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 268435456;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (16..=23, 17..=24) => return Err(MemError::WriteViolation),
            (40..=47, 41..=48) => return Err(MemError::WriteViolation),
            (52..=71, 53..=72) => return Err(MemError::WriteViolation),
            (92..=103, 93..=104) => return Err(MemError::WriteViolation),
            (128..=195, 129..=196) => return Err(MemError::WriteViolation),
            (236..=255, 237..=256) => return Err(MemError::WriteViolation),
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x10000000 {
    fn read_ficr_ppfc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_ppfc_ppfc()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_configid(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_ficr_configid_hwid()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_ficr_configid_fwid()?)
            << 16u32;
        Ok(_value)
    }
    fn read_ficr_deviceaddrtype(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_ficr_deviceaddrtype_deviceaddrtype()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_ficr_overrideen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_overrideen_nrf_1mbit()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_overrideen_ble_1mbit()?)
                << 3u32;
        Ok(_value)
    }
}
pub(crate) struct PeripheralPage0x10001000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x10001000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 268439552;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_clenr0()?
                        .to_ne_bytes();
                    if _start <= 0 && _end > 0 {
                        _buf[(0 - _start) as usize] = _value[0];
                    }
                    if _start <= 1 && _end > 1 {
                        _buf[(1 - _start) as usize] = _value[1];
                    }
                    if _start <= 2 && _end > 2 {
                        _buf[(2 - _start) as usize] = _value[2];
                    }
                    if _start <= 3 && _end > 3 {
                        _buf[(3 - _start) as usize] = _value[3];
                    }
                }
                if _start < 8 && _end > 4 {
                    let _value = self.read_uicr_rbpconf()?.to_ne_bytes();
                    if _start <= 4 && _end > 4 {
                        _buf[(4 - _start) as usize] = _value[0];
                    }
                    if _start <= 5 && _end > 5 {
                        _buf[(5 - _start) as usize] = _value[1];
                    }
                    if _start <= 6 && _end > 6 {
                        _buf[(6 - _start) as usize] = _value[2];
                    }
                    if _start <= 7 && _end > 7 {
                        _buf[(7 - _start) as usize] = _value[3];
                    }
                }
                if _start < 12 && _end > 8 {
                    let _value = self.read_uicr_xtalfreq()?.to_ne_bytes();
                    if _start <= 8 && _end > 8 {
                        _buf[(8 - _start) as usize] = _value[0];
                    }
                    if _start <= 9 && _end > 9 {
                        _buf[(9 - _start) as usize] = _value[1];
                    }
                    if _start <= 10 && _end > 10 {
                        _buf[(10 - _start) as usize] = _value[2];
                    }
                    if _start <= 11 && _end > 11 {
                        _buf[(11 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (16..=255, 17..=256) => {
                if _start < 20 && _end > 16 {
                    let _value = self.read_uicr_fwid()?.to_ne_bytes();
                    if _start <= 16 && _end > 16 {
                        _buf[(16 - _start) as usize] = _value[0];
                    }
                    if _start <= 17 && _end > 17 {
                        _buf[(17 - _start) as usize] = _value[1];
                    }
                    if _start <= 18 && _end > 18 {
                        _buf[(18 - _start) as usize] = _value[2];
                    }
                    if _start <= 19 && _end > 19 {
                        _buf[(19 - _start) as usize] = _value[3];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(0)?
                        .to_ne_bytes();
                    if _start <= 20 && _end > 20 {
                        _buf[(20 - _start) as usize] = _value[0];
                    }
                    if _start <= 21 && _end > 21 {
                        _buf[(21 - _start) as usize] = _value[1];
                    }
                    if _start <= 22 && _end > 22 {
                        _buf[(22 - _start) as usize] = _value[2];
                    }
                    if _start <= 23 && _end > 23 {
                        _buf[(23 - _start) as usize] = _value[3];
                    }
                }
                if _start < 40 && _end > 36 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(1)?
                        .to_ne_bytes();
                    if _start <= 36 && _end > 36 {
                        _buf[(36 - _start) as usize] = _value[0];
                    }
                    if _start <= 37 && _end > 37 {
                        _buf[(37 - _start) as usize] = _value[1];
                    }
                    if _start <= 38 && _end > 38 {
                        _buf[(38 - _start) as usize] = _value[2];
                    }
                    if _start <= 39 && _end > 39 {
                        _buf[(39 - _start) as usize] = _value[3];
                    }
                }
                if _start < 56 && _end > 52 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(2)?
                        .to_ne_bytes();
                    if _start <= 52 && _end > 52 {
                        _buf[(52 - _start) as usize] = _value[0];
                    }
                    if _start <= 53 && _end > 53 {
                        _buf[(53 - _start) as usize] = _value[1];
                    }
                    if _start <= 54 && _end > 54 {
                        _buf[(54 - _start) as usize] = _value[2];
                    }
                    if _start <= 55 && _end > 55 {
                        _buf[(55 - _start) as usize] = _value[3];
                    }
                }
                if _start < 72 && _end > 68 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(3)?
                        .to_ne_bytes();
                    if _start <= 68 && _end > 68 {
                        _buf[(68 - _start) as usize] = _value[0];
                    }
                    if _start <= 69 && _end > 69 {
                        _buf[(69 - _start) as usize] = _value[1];
                    }
                    if _start <= 70 && _end > 70 {
                        _buf[(70 - _start) as usize] = _value[2];
                    }
                    if _start <= 71 && _end > 71 {
                        _buf[(71 - _start) as usize] = _value[3];
                    }
                }
                if _start < 88 && _end > 84 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(4)?
                        .to_ne_bytes();
                    if _start <= 84 && _end > 84 {
                        _buf[(84 - _start) as usize] = _value[0];
                    }
                    if _start <= 85 && _end > 85 {
                        _buf[(85 - _start) as usize] = _value[1];
                    }
                    if _start <= 86 && _end > 86 {
                        _buf[(86 - _start) as usize] = _value[2];
                    }
                    if _start <= 87 && _end > 87 {
                        _buf[(87 - _start) as usize] = _value[3];
                    }
                }
                if _start < 104 && _end > 100 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(5)?
                        .to_ne_bytes();
                    if _start <= 100 && _end > 100 {
                        _buf[(100 - _start) as usize] = _value[0];
                    }
                    if _start <= 101 && _end > 101 {
                        _buf[(101 - _start) as usize] = _value[1];
                    }
                    if _start <= 102 && _end > 102 {
                        _buf[(102 - _start) as usize] = _value[2];
                    }
                    if _start <= 103 && _end > 103 {
                        _buf[(103 - _start) as usize] = _value[3];
                    }
                }
                if _start < 120 && _end > 116 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(6)?
                        .to_ne_bytes();
                    if _start <= 116 && _end > 116 {
                        _buf[(116 - _start) as usize] = _value[0];
                    }
                    if _start <= 117 && _end > 117 {
                        _buf[(117 - _start) as usize] = _value[1];
                    }
                    if _start <= 118 && _end > 118 {
                        _buf[(118 - _start) as usize] = _value[2];
                    }
                    if _start <= 119 && _end > 119 {
                        _buf[(119 - _start) as usize] = _value[3];
                    }
                }
                if _start < 136 && _end > 132 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(7)?
                        .to_ne_bytes();
                    if _start <= 132 && _end > 132 {
                        _buf[(132 - _start) as usize] = _value[0];
                    }
                    if _start <= 133 && _end > 133 {
                        _buf[(133 - _start) as usize] = _value[1];
                    }
                    if _start <= 134 && _end > 134 {
                        _buf[(134 - _start) as usize] = _value[2];
                    }
                    if _start <= 135 && _end > 135 {
                        _buf[(135 - _start) as usize] = _value[3];
                    }
                }
                if _start < 152 && _end > 148 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(8)?
                        .to_ne_bytes();
                    if _start <= 148 && _end > 148 {
                        _buf[(148 - _start) as usize] = _value[0];
                    }
                    if _start <= 149 && _end > 149 {
                        _buf[(149 - _start) as usize] = _value[1];
                    }
                    if _start <= 150 && _end > 150 {
                        _buf[(150 - _start) as usize] = _value[2];
                    }
                    if _start <= 151 && _end > 151 {
                        _buf[(151 - _start) as usize] = _value[3];
                    }
                }
                if _start < 168 && _end > 164 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(9)?
                        .to_ne_bytes();
                    if _start <= 164 && _end > 164 {
                        _buf[(164 - _start) as usize] = _value[0];
                    }
                    if _start <= 165 && _end > 165 {
                        _buf[(165 - _start) as usize] = _value[1];
                    }
                    if _start <= 166 && _end > 166 {
                        _buf[(166 - _start) as usize] = _value[2];
                    }
                    if _start <= 167 && _end > 167 {
                        _buf[(167 - _start) as usize] = _value[3];
                    }
                }
                if _start < 184 && _end > 180 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(10)?
                        .to_ne_bytes();
                    if _start <= 180 && _end > 180 {
                        _buf[(180 - _start) as usize] = _value[0];
                    }
                    if _start <= 181 && _end > 181 {
                        _buf[(181 - _start) as usize] = _value[1];
                    }
                    if _start <= 182 && _end > 182 {
                        _buf[(182 - _start) as usize] = _value[2];
                    }
                    if _start <= 183 && _end > 183 {
                        _buf[(183 - _start) as usize] = _value[3];
                    }
                }
                if _start < 200 && _end > 196 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(11)?
                        .to_ne_bytes();
                    if _start <= 196 && _end > 196 {
                        _buf[(196 - _start) as usize] = _value[0];
                    }
                    if _start <= 197 && _end > 197 {
                        _buf[(197 - _start) as usize] = _value[1];
                    }
                    if _start <= 198 && _end > 198 {
                        _buf[(198 - _start) as usize] = _value[2];
                    }
                    if _start <= 199 && _end > 199 {
                        _buf[(199 - _start) as usize] = _value[3];
                    }
                }
                if _start < 216 && _end > 212 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(12)?
                        .to_ne_bytes();
                    if _start <= 212 && _end > 212 {
                        _buf[(212 - _start) as usize] = _value[0];
                    }
                    if _start <= 213 && _end > 213 {
                        _buf[(213 - _start) as usize] = _value[1];
                    }
                    if _start <= 214 && _end > 214 {
                        _buf[(214 - _start) as usize] = _value[2];
                    }
                    if _start <= 215 && _end > 215 {
                        _buf[(215 - _start) as usize] = _value[3];
                    }
                }
                if _start < 232 && _end > 228 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(13)?
                        .to_ne_bytes();
                    if _start <= 228 && _end > 228 {
                        _buf[(228 - _start) as usize] = _value[0];
                    }
                    if _start <= 229 && _end > 229 {
                        _buf[(229 - _start) as usize] = _value[1];
                    }
                    if _start <= 230 && _end > 230 {
                        _buf[(230 - _start) as usize] = _value[2];
                    }
                    if _start <= 231 && _end > 231 {
                        _buf[(231 - _start) as usize] = _value[3];
                    }
                }
                if _start < 248 && _end > 244 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_bootloaderaddr(14)?
                        .to_ne_bytes();
                    if _start <= 244 && _end > 244 {
                        _buf[(244 - _start) as usize] = _value[0];
                    }
                    if _start <= 245 && _end > 245 {
                        _buf[(245 - _start) as usize] = _value[1];
                    }
                    if _start <= 246 && _end > 246 {
                        _buf[(246 - _start) as usize] = _value[2];
                    }
                    if _start <= 247 && _end > 247 {
                        _buf[(247 - _start) as usize] = _value[3];
                    }
                }
                if _start < 84 && _end > 80 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(0)?
                        .to_ne_bytes();
                    if _start <= 80 && _end > 80 {
                        _buf[(80 - _start) as usize] = _value[0];
                    }
                    if _start <= 81 && _end > 81 {
                        _buf[(81 - _start) as usize] = _value[1];
                    }
                    if _start <= 82 && _end > 82 {
                        _buf[(82 - _start) as usize] = _value[2];
                    }
                    if _start <= 83 && _end > 83 {
                        _buf[(83 - _start) as usize] = _value[3];
                    }
                }
                if _start < 100 && _end > 96 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(1)?
                        .to_ne_bytes();
                    if _start <= 96 && _end > 96 {
                        _buf[(96 - _start) as usize] = _value[0];
                    }
                    if _start <= 97 && _end > 97 {
                        _buf[(97 - _start) as usize] = _value[1];
                    }
                    if _start <= 98 && _end > 98 {
                        _buf[(98 - _start) as usize] = _value[2];
                    }
                    if _start <= 99 && _end > 99 {
                        _buf[(99 - _start) as usize] = _value[3];
                    }
                }
                if _start < 116 && _end > 112 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(2)?
                        .to_ne_bytes();
                    if _start <= 112 && _end > 112 {
                        _buf[(112 - _start) as usize] = _value[0];
                    }
                    if _start <= 113 && _end > 113 {
                        _buf[(113 - _start) as usize] = _value[1];
                    }
                    if _start <= 114 && _end > 114 {
                        _buf[(114 - _start) as usize] = _value[2];
                    }
                    if _start <= 115 && _end > 115 {
                        _buf[(115 - _start) as usize] = _value[3];
                    }
                }
                if _start < 132 && _end > 128 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(3)?
                        .to_ne_bytes();
                    if _start <= 128 && _end > 128 {
                        _buf[(128 - _start) as usize] = _value[0];
                    }
                    if _start <= 129 && _end > 129 {
                        _buf[(129 - _start) as usize] = _value[1];
                    }
                    if _start <= 130 && _end > 130 {
                        _buf[(130 - _start) as usize] = _value[2];
                    }
                    if _start <= 131 && _end > 131 {
                        _buf[(131 - _start) as usize] = _value[3];
                    }
                }
                if _start < 148 && _end > 144 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(4)?
                        .to_ne_bytes();
                    if _start <= 144 && _end > 144 {
                        _buf[(144 - _start) as usize] = _value[0];
                    }
                    if _start <= 145 && _end > 145 {
                        _buf[(145 - _start) as usize] = _value[1];
                    }
                    if _start <= 146 && _end > 146 {
                        _buf[(146 - _start) as usize] = _value[2];
                    }
                    if _start <= 147 && _end > 147 {
                        _buf[(147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 164 && _end > 160 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(5)?
                        .to_ne_bytes();
                    if _start <= 160 && _end > 160 {
                        _buf[(160 - _start) as usize] = _value[0];
                    }
                    if _start <= 161 && _end > 161 {
                        _buf[(161 - _start) as usize] = _value[1];
                    }
                    if _start <= 162 && _end > 162 {
                        _buf[(162 - _start) as usize] = _value[2];
                    }
                    if _start <= 163 && _end > 163 {
                        _buf[(163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 180 && _end > 176 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(6)?
                        .to_ne_bytes();
                    if _start <= 176 && _end > 176 {
                        _buf[(176 - _start) as usize] = _value[0];
                    }
                    if _start <= 177 && _end > 177 {
                        _buf[(177 - _start) as usize] = _value[1];
                    }
                    if _start <= 178 && _end > 178 {
                        _buf[(178 - _start) as usize] = _value[2];
                    }
                    if _start <= 179 && _end > 179 {
                        _buf[(179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 196 && _end > 192 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(7)?
                        .to_ne_bytes();
                    if _start <= 192 && _end > 192 {
                        _buf[(192 - _start) as usize] = _value[0];
                    }
                    if _start <= 193 && _end > 193 {
                        _buf[(193 - _start) as usize] = _value[1];
                    }
                    if _start <= 194 && _end > 194 {
                        _buf[(194 - _start) as usize] = _value[2];
                    }
                    if _start <= 195 && _end > 195 {
                        _buf[(195 - _start) as usize] = _value[3];
                    }
                }
                if _start < 212 && _end > 208 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(8)?
                        .to_ne_bytes();
                    if _start <= 208 && _end > 208 {
                        _buf[(208 - _start) as usize] = _value[0];
                    }
                    if _start <= 209 && _end > 209 {
                        _buf[(209 - _start) as usize] = _value[1];
                    }
                    if _start <= 210 && _end > 210 {
                        _buf[(210 - _start) as usize] = _value[2];
                    }
                    if _start <= 211 && _end > 211 {
                        _buf[(211 - _start) as usize] = _value[3];
                    }
                }
                if _start < 228 && _end > 224 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(9)?
                        .to_ne_bytes();
                    if _start <= 224 && _end > 224 {
                        _buf[(224 - _start) as usize] = _value[0];
                    }
                    if _start <= 225 && _end > 225 {
                        _buf[(225 - _start) as usize] = _value[1];
                    }
                    if _start <= 226 && _end > 226 {
                        _buf[(226 - _start) as usize] = _value[2];
                    }
                    if _start <= 227 && _end > 227 {
                        _buf[(227 - _start) as usize] = _value[3];
                    }
                }
                if _start < 244 && _end > 240 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(10)?
                        .to_ne_bytes();
                    if _start <= 240 && _end > 240 {
                        _buf[(240 - _start) as usize] = _value[0];
                    }
                    if _start <= 241 && _end > 241 {
                        _buf[(241 - _start) as usize] = _value[1];
                    }
                    if _start <= 242 && _end > 242 {
                        _buf[(242 - _start) as usize] = _value[2];
                    }
                    if _start <= 243 && _end > 243 {
                        _buf[(243 - _start) as usize] = _value[3];
                    }
                }
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(11)?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 132 && _end > 128 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(0)?
                        .to_ne_bytes();
                    if _start <= 128 && _end > 128 {
                        _buf[(128 - _start) as usize] = _value[0];
                    }
                    if _start <= 129 && _end > 129 {
                        _buf[(129 - _start) as usize] = _value[1];
                    }
                    if _start <= 130 && _end > 130 {
                        _buf[(130 - _start) as usize] = _value[2];
                    }
                    if _start <= 131 && _end > 131 {
                        _buf[(131 - _start) as usize] = _value[3];
                    }
                }
                if _start < 148 && _end > 144 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(1)?
                        .to_ne_bytes();
                    if _start <= 144 && _end > 144 {
                        _buf[(144 - _start) as usize] = _value[0];
                    }
                    if _start <= 145 && _end > 145 {
                        _buf[(145 - _start) as usize] = _value[1];
                    }
                    if _start <= 146 && _end > 146 {
                        _buf[(146 - _start) as usize] = _value[2];
                    }
                    if _start <= 147 && _end > 147 {
                        _buf[(147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 164 && _end > 160 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(2)?
                        .to_ne_bytes();
                    if _start <= 160 && _end > 160 {
                        _buf[(160 - _start) as usize] = _value[0];
                    }
                    if _start <= 161 && _end > 161 {
                        _buf[(161 - _start) as usize] = _value[1];
                    }
                    if _start <= 162 && _end > 162 {
                        _buf[(162 - _start) as usize] = _value[2];
                    }
                    if _start <= 163 && _end > 163 {
                        _buf[(163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 180 && _end > 176 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(3)?
                        .to_ne_bytes();
                    if _start <= 176 && _end > 176 {
                        _buf[(176 - _start) as usize] = _value[0];
                    }
                    if _start <= 177 && _end > 177 {
                        _buf[(177 - _start) as usize] = _value[1];
                    }
                    if _start <= 178 && _end > 178 {
                        _buf[(178 - _start) as usize] = _value[2];
                    }
                    if _start <= 179 && _end > 179 {
                        _buf[(179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 196 && _end > 192 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(4)?
                        .to_ne_bytes();
                    if _start <= 192 && _end > 192 {
                        _buf[(192 - _start) as usize] = _value[0];
                    }
                    if _start <= 193 && _end > 193 {
                        _buf[(193 - _start) as usize] = _value[1];
                    }
                    if _start <= 194 && _end > 194 {
                        _buf[(194 - _start) as usize] = _value[2];
                    }
                    if _start <= 195 && _end > 195 {
                        _buf[(195 - _start) as usize] = _value[3];
                    }
                }
                if _start < 212 && _end > 208 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(5)?
                        .to_ne_bytes();
                    if _start <= 208 && _end > 208 {
                        _buf[(208 - _start) as usize] = _value[0];
                    }
                    if _start <= 209 && _end > 209 {
                        _buf[(209 - _start) as usize] = _value[1];
                    }
                    if _start <= 210 && _end > 210 {
                        _buf[(210 - _start) as usize] = _value[2];
                    }
                    if _start <= 211 && _end > 211 {
                        _buf[(211 - _start) as usize] = _value[3];
                    }
                }
                if _start < 228 && _end > 224 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(6)?
                        .to_ne_bytes();
                    if _start <= 224 && _end > 224 {
                        _buf[(224 - _start) as usize] = _value[0];
                    }
                    if _start <= 225 && _end > 225 {
                        _buf[(225 - _start) as usize] = _value[1];
                    }
                    if _start <= 226 && _end > 226 {
                        _buf[(226 - _start) as usize] = _value[2];
                    }
                    if _start <= 227 && _end > 227 {
                        _buf[(227 - _start) as usize] = _value[3];
                    }
                }
                if _start < 244 && _end > 240 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(7)?
                        .to_ne_bytes();
                    if _start <= 240 && _end > 240 {
                        _buf[(240 - _start) as usize] = _value[0];
                    }
                    if _start <= 241 && _end > 241 {
                        _buf[(241 - _start) as usize] = _value[1];
                    }
                    if _start <= 242 && _end > 242 {
                        _buf[(242 - _start) as usize] = _value[2];
                    }
                    if _start <= 243 && _end > 243 {
                        _buf[(243 - _start) as usize] = _value[3];
                    }
                }
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(8)?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(9)?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 292 && _end > 288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(10)?
                        .to_ne_bytes();
                    if _start <= 288 && _end > 288 {
                        _buf[(288 - _start) as usize] = _value[0];
                    }
                    if _start <= 289 && _end > 289 {
                        _buf[(289 - _start) as usize] = _value[1];
                    }
                    if _start <= 290 && _end > 290 {
                        _buf[(290 - _start) as usize] = _value[2];
                    }
                    if _start <= 291 && _end > 291 {
                        _buf[(291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 308 && _end > 304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(11)?
                        .to_ne_bytes();
                    if _start <= 304 && _end > 304 {
                        _buf[(304 - _start) as usize] = _value[0];
                    }
                    if _start <= 305 && _end > 305 {
                        _buf[(305 - _start) as usize] = _value[1];
                    }
                    if _start <= 306 && _end > 306 {
                        _buf[(306 - _start) as usize] = _value[2];
                    }
                    if _start <= 307 && _end > 307 {
                        _buf[(307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 324 && _end > 320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(12)?
                        .to_ne_bytes();
                    if _start <= 320 && _end > 320 {
                        _buf[(320 - _start) as usize] = _value[0];
                    }
                    if _start <= 321 && _end > 321 {
                        _buf[(321 - _start) as usize] = _value[1];
                    }
                    if _start <= 322 && _end > 322 {
                        _buf[(322 - _start) as usize] = _value[2];
                    }
                    if _start <= 323 && _end > 323 {
                        _buf[(323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(13)?
                        .to_ne_bytes();
                    if _start <= 336 && _end > 336 {
                        _buf[(336 - _start) as usize] = _value[0];
                    }
                    if _start <= 337 && _end > 337 {
                        _buf[(337 - _start) as usize] = _value[1];
                    }
                    if _start <= 338 && _end > 338 {
                        _buf[(338 - _start) as usize] = _value[2];
                    }
                    if _start <= 339 && _end > 339 {
                        _buf[(339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 356 && _end > 352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(14)?
                        .to_ne_bytes();
                    if _start <= 352 && _end > 352 {
                        _buf[(352 - _start) as usize] = _value[0];
                    }
                    if _start <= 353 && _end > 353 {
                        _buf[(353 - _start) as usize] = _value[1];
                    }
                    if _start <= 354 && _end > 354 {
                        _buf[(354 - _start) as usize] = _value[2];
                    }
                    if _start <= 355 && _end > 355 {
                        _buf[(355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 372 && _end > 368 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(15)?
                        .to_ne_bytes();
                    if _start <= 368 && _end > 368 {
                        _buf[(368 - _start) as usize] = _value[0];
                    }
                    if _start <= 369 && _end > 369 {
                        _buf[(369 - _start) as usize] = _value[1];
                    }
                    if _start <= 370 && _end > 370 {
                        _buf[(370 - _start) as usize] = _value[2];
                    }
                    if _start <= 371 && _end > 371 {
                        _buf[(371 - _start) as usize] = _value[3];
                    }
                }
                if _start < 388 && _end > 384 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(16)?
                        .to_ne_bytes();
                    if _start <= 384 && _end > 384 {
                        _buf[(384 - _start) as usize] = _value[0];
                    }
                    if _start <= 385 && _end > 385 {
                        _buf[(385 - _start) as usize] = _value[1];
                    }
                    if _start <= 386 && _end > 386 {
                        _buf[(386 - _start) as usize] = _value[2];
                    }
                    if _start <= 387 && _end > 387 {
                        _buf[(387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 404 && _end > 400 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(17)?
                        .to_ne_bytes();
                    if _start <= 400 && _end > 400 {
                        _buf[(400 - _start) as usize] = _value[0];
                    }
                    if _start <= 401 && _end > 401 {
                        _buf[(401 - _start) as usize] = _value[1];
                    }
                    if _start <= 402 && _end > 402 {
                        _buf[(402 - _start) as usize] = _value[2];
                    }
                    if _start <= 403 && _end > 403 {
                        _buf[(403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 420 && _end > 416 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(18)?
                        .to_ne_bytes();
                    if _start <= 416 && _end > 416 {
                        _buf[(416 - _start) as usize] = _value[0];
                    }
                    if _start <= 417 && _end > 417 {
                        _buf[(417 - _start) as usize] = _value[1];
                    }
                    if _start <= 418 && _end > 418 {
                        _buf[(418 - _start) as usize] = _value[2];
                    }
                    if _start <= 419 && _end > 419 {
                        _buf[(419 - _start) as usize] = _value[3];
                    }
                }
                if _start < 436 && _end > 432 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(19)?
                        .to_ne_bytes();
                    if _start <= 432 && _end > 432 {
                        _buf[(432 - _start) as usize] = _value[0];
                    }
                    if _start <= 433 && _end > 433 {
                        _buf[(433 - _start) as usize] = _value[1];
                    }
                    if _start <= 434 && _end > 434 {
                        _buf[(434 - _start) as usize] = _value[2];
                    }
                    if _start <= 435 && _end > 435 {
                        _buf[(435 - _start) as usize] = _value[3];
                    }
                }
                if _start < 452 && _end > 448 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(20)?
                        .to_ne_bytes();
                    if _start <= 448 && _end > 448 {
                        _buf[(448 - _start) as usize] = _value[0];
                    }
                    if _start <= 449 && _end > 449 {
                        _buf[(449 - _start) as usize] = _value[1];
                    }
                    if _start <= 450 && _end > 450 {
                        _buf[(450 - _start) as usize] = _value[2];
                    }
                    if _start <= 451 && _end > 451 {
                        _buf[(451 - _start) as usize] = _value[3];
                    }
                }
                if _start < 468 && _end > 464 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(21)?
                        .to_ne_bytes();
                    if _start <= 464 && _end > 464 {
                        _buf[(464 - _start) as usize] = _value[0];
                    }
                    if _start <= 465 && _end > 465 {
                        _buf[(465 - _start) as usize] = _value[1];
                    }
                    if _start <= 466 && _end > 466 {
                        _buf[(466 - _start) as usize] = _value[2];
                    }
                    if _start <= 467 && _end > 467 {
                        _buf[(467 - _start) as usize] = _value[3];
                    }
                }
                if _start < 484 && _end > 480 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(22)?
                        .to_ne_bytes();
                    if _start <= 480 && _end > 480 {
                        _buf[(480 - _start) as usize] = _value[0];
                    }
                    if _start <= 481 && _end > 481 {
                        _buf[(481 - _start) as usize] = _value[1];
                    }
                    if _start <= 482 && _end > 482 {
                        _buf[(482 - _start) as usize] = _value[2];
                    }
                    if _start <= 483 && _end > 483 {
                        _buf[(483 - _start) as usize] = _value[3];
                    }
                }
                if _start < 500 && _end > 496 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(23)?
                        .to_ne_bytes();
                    if _start <= 496 && _end > 496 {
                        _buf[(496 - _start) as usize] = _value[0];
                    }
                    if _start <= 497 && _end > 497 {
                        _buf[(497 - _start) as usize] = _value[1];
                    }
                    if _start <= 498 && _end > 498 {
                        _buf[(498 - _start) as usize] = _value[2];
                    }
                    if _start <= 499 && _end > 499 {
                        _buf[(499 - _start) as usize] = _value[3];
                    }
                }
                if _start < 516 && _end > 512 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(24)?
                        .to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                if _start < 532 && _end > 528 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(25)?
                        .to_ne_bytes();
                    if _start <= 528 && _end > 528 {
                        _buf[(528 - _start) as usize] = _value[0];
                    }
                    if _start <= 529 && _end > 529 {
                        _buf[(529 - _start) as usize] = _value[1];
                    }
                    if _start <= 530 && _end > 530 {
                        _buf[(530 - _start) as usize] = _value[2];
                    }
                    if _start <= 531 && _end > 531 {
                        _buf[(531 - _start) as usize] = _value[3];
                    }
                }
                if _start < 548 && _end > 544 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(26)?
                        .to_ne_bytes();
                    if _start <= 544 && _end > 544 {
                        _buf[(544 - _start) as usize] = _value[0];
                    }
                    if _start <= 545 && _end > 545 {
                        _buf[(545 - _start) as usize] = _value[1];
                    }
                    if _start <= 546 && _end > 546 {
                        _buf[(546 - _start) as usize] = _value[2];
                    }
                    if _start <= 547 && _end > 547 {
                        _buf[(547 - _start) as usize] = _value[3];
                    }
                }
                if _start < 564 && _end > 560 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(27)?
                        .to_ne_bytes();
                    if _start <= 560 && _end > 560 {
                        _buf[(560 - _start) as usize] = _value[0];
                    }
                    if _start <= 561 && _end > 561 {
                        _buf[(561 - _start) as usize] = _value[1];
                    }
                    if _start <= 562 && _end > 562 {
                        _buf[(562 - _start) as usize] = _value[2];
                    }
                    if _start <= 563 && _end > 563 {
                        _buf[(563 - _start) as usize] = _value[3];
                    }
                }
                if _start < 580 && _end > 576 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(28)?
                        .to_ne_bytes();
                    if _start <= 576 && _end > 576 {
                        _buf[(576 - _start) as usize] = _value[0];
                    }
                    if _start <= 577 && _end > 577 {
                        _buf[(577 - _start) as usize] = _value[1];
                    }
                    if _start <= 578 && _end > 578 {
                        _buf[(578 - _start) as usize] = _value[2];
                    }
                    if _start <= 579 && _end > 579 {
                        _buf[(579 - _start) as usize] = _value[3];
                    }
                }
                if _start < 596 && _end > 592 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(29)?
                        .to_ne_bytes();
                    if _start <= 592 && _end > 592 {
                        _buf[(592 - _start) as usize] = _value[0];
                    }
                    if _start <= 593 && _end > 593 {
                        _buf[(593 - _start) as usize] = _value[1];
                    }
                    if _start <= 594 && _end > 594 {
                        _buf[(594 - _start) as usize] = _value[2];
                    }
                    if _start <= 595 && _end > 595 {
                        _buf[(595 - _start) as usize] = _value[3];
                    }
                }
                if _start < 612 && _end > 608 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(30)?
                        .to_ne_bytes();
                    if _start <= 608 && _end > 608 {
                        _buf[(608 - _start) as usize] = _value[0];
                    }
                    if _start <= 609 && _end > 609 {
                        _buf[(609 - _start) as usize] = _value[1];
                    }
                    if _start <= 610 && _end > 610 {
                        _buf[(610 - _start) as usize] = _value[2];
                    }
                    if _start <= 611 && _end > 611 {
                        _buf[(611 - _start) as usize] = _value[3];
                    }
                }
                if _start < 628 && _end > 624 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(31)?
                        .to_ne_bytes();
                    if _start <= 624 && _end > 624 {
                        _buf[(624 - _start) as usize] = _value[0];
                    }
                    if _start <= 625 && _end > 625 {
                        _buf[(625 - _start) as usize] = _value[1];
                    }
                    if _start <= 626 && _end > 626 {
                        _buf[(626 - _start) as usize] = _value[2];
                    }
                    if _start <= 627 && _end > 627 {
                        _buf[(627 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 268439552;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for UICR CLENR0 not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_clenr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    let offset = 4u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.write_uicr_rbpconf(offset, &_buf[start..end])?;
                }
                if _start < 12 && _end > 8 {
                    let offset = 8u64.saturating_sub(_start);
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.write_uicr_xtalfreq(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (16..=255, 17..=256) => {
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 24 && _end > 20 {
                    assert!(
                        _start <= 20u64 && _end >= 24u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(20u64) as usize;
                    let end =
                        (_end.saturating_sub(20u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 40 && _end > 36 {
                    assert!(
                        _start <= 36u64 && _end >= 40u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(36u64) as usize;
                    let end =
                        (_end.saturating_sub(36u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 56 && _end > 52 {
                    assert!(
                        _start <= 52u64 && _end >= 56u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(52u64) as usize;
                    let end =
                        (_end.saturating_sub(52u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 72 && _end > 68 {
                    assert!(
                        _start <= 68u64 && _end >= 72u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(68u64) as usize;
                    let end =
                        (_end.saturating_sub(68u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 88 && _end > 84 {
                    assert!(
                        _start <= 84u64 && _end >= 88u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(84u64) as usize;
                    let end =
                        (_end.saturating_sub(84u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 104 && _end > 100 {
                    assert!(
                        _start <= 100u64 && _end >= 104u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(100u64) as usize;
                    let end =
                        (_end.saturating_sub(100u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 120 && _end > 116 {
                    assert!(
                        _start <= 116u64 && _end >= 120u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(116u64) as usize;
                    let end =
                        (_end.saturating_sub(116u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 136 && _end > 132 {
                    assert!(
                        _start <= 132u64 && _end >= 136u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(132u64) as usize;
                    let end =
                        (_end.saturating_sub(132u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 152 && _end > 148 {
                    assert!(
                        _start <= 148u64 && _end >= 152u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(148u64) as usize;
                    let end =
                        (_end.saturating_sub(148u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 168 && _end > 164 {
                    assert!(
                        _start <= 164u64 && _end >= 168u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(164u64) as usize;
                    let end =
                        (_end.saturating_sub(164u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 184 && _end > 180 {
                    assert!(
                        _start <= 180u64 && _end >= 184u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(180u64) as usize;
                    let end =
                        (_end.saturating_sub(180u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 200 && _end > 196 {
                    assert!(
                        _start <= 196u64 && _end >= 200u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(196u64) as usize;
                    let end =
                        (_end.saturating_sub(196u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 216 && _end > 212 {
                    assert!(
                        _start <= 212u64 && _end >= 216u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(212u64) as usize;
                    let end =
                        (_end.saturating_sub(212u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 232 && _end > 228 {
                    assert!(
                        _start <= 228u64 && _end >= 232u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(228u64) as usize;
                    let end =
                        (_end.saturating_sub(228u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 248 && _end > 244 {
                    assert!(
                        _start <= 244u64 && _end >= 248u64,
                        "partial write for UICR BOOTLOADERADDR not implemented",
                    );
                    let start = _start.saturating_sub(244u64) as usize;
                    let end =
                        (_end.saturating_sub(244u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_bootloaderaddr(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 84 && _end > 80 {
                    assert!(
                        _start <= 80u64 && _end >= 84u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(80u64) as usize;
                    let end =
                        (_end.saturating_sub(80u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 100 && _end > 96 {
                    assert!(
                        _start <= 96u64 && _end >= 100u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(96u64) as usize;
                    let end =
                        (_end.saturating_sub(96u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 116 && _end > 112 {
                    assert!(
                        _start <= 112u64 && _end >= 116u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(112u64) as usize;
                    let end =
                        (_end.saturating_sub(112u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 132 && _end > 128 {
                    assert!(
                        _start <= 128u64 && _end >= 132u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(128u64) as usize;
                    let end =
                        (_end.saturating_sub(128u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 148 && _end > 144 {
                    assert!(
                        _start <= 144u64 && _end >= 148u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(144u64) as usize;
                    let end =
                        (_end.saturating_sub(144u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 164 && _end > 160 {
                    assert!(
                        _start <= 160u64 && _end >= 164u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(160u64) as usize;
                    let end =
                        (_end.saturating_sub(160u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 180 && _end > 176 {
                    assert!(
                        _start <= 176u64 && _end >= 180u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(176u64) as usize;
                    let end =
                        (_end.saturating_sub(176u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 196 && _end > 192 {
                    assert!(
                        _start <= 192u64 && _end >= 196u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(192u64) as usize;
                    let end =
                        (_end.saturating_sub(192u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 212 && _end > 208 {
                    assert!(
                        _start <= 208u64 && _end >= 212u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(208u64) as usize;
                    let end =
                        (_end.saturating_sub(208u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 228 && _end > 224 {
                    assert!(
                        _start <= 224u64 && _end >= 228u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(224u64) as usize;
                    let end =
                        (_end.saturating_sub(224u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 244 && _end > 240 {
                    assert!(
                        _start <= 240u64 && _end >= 244u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(240u64) as usize;
                    let end =
                        (_end.saturating_sub(240u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 132 && _end > 128 {
                    assert!(
                        _start <= 128u64 && _end >= 132u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(128u64) as usize;
                    let end =
                        (_end.saturating_sub(128u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 148 && _end > 144 {
                    assert!(
                        _start <= 144u64 && _end >= 148u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(144u64) as usize;
                    let end =
                        (_end.saturating_sub(144u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 164 && _end > 160 {
                    assert!(
                        _start <= 160u64 && _end >= 164u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(160u64) as usize;
                    let end =
                        (_end.saturating_sub(160u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 180 && _end > 176 {
                    assert!(
                        _start <= 176u64 && _end >= 180u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(176u64) as usize;
                    let end =
                        (_end.saturating_sub(176u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 196 && _end > 192 {
                    assert!(
                        _start <= 192u64 && _end >= 196u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(192u64) as usize;
                    let end =
                        (_end.saturating_sub(192u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 212 && _end > 208 {
                    assert!(
                        _start <= 208u64 && _end >= 212u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(208u64) as usize;
                    let end =
                        (_end.saturating_sub(208u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 228 && _end > 224 {
                    assert!(
                        _start <= 224u64 && _end >= 228u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(224u64) as usize;
                    let end =
                        (_end.saturating_sub(224u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 244 && _end > 240 {
                    assert!(
                        _start <= 240u64 && _end >= 244u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(240u64) as usize;
                    let end =
                        (_end.saturating_sub(240u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272u64 && _end >= 276u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(272u64) as usize;
                    let end =
                        (_end.saturating_sub(272u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 292 && _end > 288 {
                    assert!(
                        _start <= 288u64 && _end >= 292u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(288u64) as usize;
                    let end =
                        (_end.saturating_sub(288u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 308 && _end > 304 {
                    assert!(
                        _start <= 304u64 && _end >= 308u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(304u64) as usize;
                    let end =
                        (_end.saturating_sub(304u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 324 && _end > 320 {
                    assert!(
                        _start <= 320u64 && _end >= 324u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(320u64) as usize;
                    let end =
                        (_end.saturating_sub(320u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 340 && _end > 336 {
                    assert!(
                        _start <= 336u64 && _end >= 340u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(336u64) as usize;
                    let end =
                        (_end.saturating_sub(336u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 356 && _end > 352 {
                    assert!(
                        _start <= 352u64 && _end >= 356u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(352u64) as usize;
                    let end =
                        (_end.saturating_sub(352u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 372 && _end > 368 {
                    assert!(
                        _start <= 368u64 && _end >= 372u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(368u64) as usize;
                    let end =
                        (_end.saturating_sub(368u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 388 && _end > 384 {
                    assert!(
                        _start <= 384u64 && _end >= 388u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(384u64) as usize;
                    let end =
                        (_end.saturating_sub(384u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        16,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 404 && _end > 400 {
                    assert!(
                        _start <= 400u64 && _end >= 404u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(400u64) as usize;
                    let end =
                        (_end.saturating_sub(400u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        17,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 420 && _end > 416 {
                    assert!(
                        _start <= 416u64 && _end >= 420u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(416u64) as usize;
                    let end =
                        (_end.saturating_sub(416u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        18,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 436 && _end > 432 {
                    assert!(
                        _start <= 432u64 && _end >= 436u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(432u64) as usize;
                    let end =
                        (_end.saturating_sub(432u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        19,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 452 && _end > 448 {
                    assert!(
                        _start <= 448u64 && _end >= 452u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(448u64) as usize;
                    let end =
                        (_end.saturating_sub(448u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        20,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 468 && _end > 464 {
                    assert!(
                        _start <= 464u64 && _end >= 468u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(464u64) as usize;
                    let end =
                        (_end.saturating_sub(464u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        21,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 484 && _end > 480 {
                    assert!(
                        _start <= 480u64 && _end >= 484u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(480u64) as usize;
                    let end =
                        (_end.saturating_sub(480u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        22,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 500 && _end > 496 {
                    assert!(
                        _start <= 496u64 && _end >= 500u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(496u64) as usize;
                    let end =
                        (_end.saturating_sub(496u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        23,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 516 && _end > 512 {
                    assert!(
                        _start <= 512u64 && _end >= 516u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        24,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 532 && _end > 528 {
                    assert!(
                        _start <= 528u64 && _end >= 532u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(528u64) as usize;
                    let end =
                        (_end.saturating_sub(528u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        25,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 548 && _end > 544 {
                    assert!(
                        _start <= 544u64 && _end >= 548u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(544u64) as usize;
                    let end =
                        (_end.saturating_sub(544u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        26,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 564 && _end > 560 {
                    assert!(
                        _start <= 560u64 && _end >= 564u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(560u64) as usize;
                    let end =
                        (_end.saturating_sub(560u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        27,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 580 && _end > 576 {
                    assert!(
                        _start <= 576u64 && _end >= 580u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(576u64) as usize;
                    let end =
                        (_end.saturating_sub(576u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        28,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 596 && _end > 592 {
                    assert!(
                        _start <= 592u64 && _end >= 596u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(592u64) as usize;
                    let end =
                        (_end.saturating_sub(592u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        29,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 612 && _end > 608 {
                    assert!(
                        _start <= 608u64 && _end >= 612u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(608u64) as usize;
                    let end =
                        (_end.saturating_sub(608u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        30,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 628 && _end > 624 {
                    assert!(
                        _start <= 624u64 && _end >= 628u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(624u64) as usize;
                    let end =
                        (_end.saturating_sub(624u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        31,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x10001000 {
    fn read_uicr_rbpconf(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uicr_rbpconf_pr0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uicr_rbpconf_pall()?) << 8u32;
        Ok(_value)
    }
    fn write_uicr_rbpconf(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uicr_rbpconf_pr0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uicr_rbpconf_pall((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_uicr_xtalfreq(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uicr_xtalfreq_xtalfreq()?)
                << 0u32;
        Ok(_value)
    }
    fn write_uicr_xtalfreq(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uicr_xtalfreq_xtalfreq((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_uicr_fwid(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uicr_fwid_fwid()?) << 0u32;
        Ok(_value)
    }
}
pub(crate) struct PeripheralPage0x40000000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40000000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073741824;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=27, 1..=28) => return Err(MemError::ReadViolation),
            (120..=127, 121..=128) => return Err(MemError::ReadViolation),
            (256..=275, 257..=276) => {
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_power_events_pofwarn()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_clock_events_hfclkstarted()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_clock_events_lfclkstarted()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_clock_events_done()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_clock_events_ctto()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_powerclock_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_powerclock_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_power_resetreas()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1032..=1039, 1033..=1040) => {
                if _start < 1036 && _end > 1032 {
                    let _value = self.read_clock_hfclkrun()?.to_ne_bytes();
                    if _start <= 1032 && _end > 1032 {
                        _buf[(1032 - _start) as usize] = _value[0];
                    }
                    if _start <= 1033 && _end > 1033 {
                        _buf[(1033 - _start) as usize] = _value[1];
                    }
                    if _start <= 1034 && _end > 1034 {
                        _buf[(1034 - _start) as usize] = _value[2];
                    }
                    if _start <= 1035 && _end > 1035 {
                        _buf[(1035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _value = self.read_clock_hfclkstat()?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1044..=1055, 1045..=1056) => {
                if _start < 1048 && _end > 1044 {
                    let _value = self.read_clock_lfclkrun()?.to_ne_bytes();
                    if _start <= 1044 && _end > 1044 {
                        _buf[(1044 - _start) as usize] = _value[0];
                    }
                    if _start <= 1045 && _end > 1045 {
                        _buf[(1045 - _start) as usize] = _value[1];
                    }
                    if _start <= 1046 && _end > 1046 {
                        _buf[(1046 - _start) as usize] = _value[2];
                    }
                    if _start <= 1047 && _end > 1047 {
                        _buf[(1047 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1052 && _end > 1048 {
                    let _value = self.read_clock_lfclkstat()?.to_ne_bytes();
                    if _start <= 1048 && _end > 1048 {
                        _buf[(1048 - _start) as usize] = _value[0];
                    }
                    if _start <= 1049 && _end > 1049 {
                        _buf[(1049 - _start) as usize] = _value[1];
                    }
                    if _start <= 1050 && _end > 1050 {
                        _buf[(1050 - _start) as usize] = _value[2];
                    }
                    if _start <= 1051 && _end > 1051 {
                        _buf[(1051 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1056 && _end > 1052 {
                    let _value = self.read_clock_lfclksrccopy()?.to_ne_bytes();
                    if _start <= 1052 && _end > 1052 {
                        _buf[(1052 - _start) as usize] = _value[0];
                    }
                    if _start <= 1053 && _end > 1053 {
                        _buf[(1053 - _start) as usize] = _value[1];
                    }
                    if _start <= 1054 && _end > 1054 {
                        _buf[(1054 - _start) as usize] = _value[2];
                    }
                    if _start <= 1055 && _end > 1055 {
                        _buf[(1055 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1064..=1067, 1065..=1068) => {
                if _start < 1068 && _end > 1064 {
                    let _value = self.read_power_ramstatus()?.to_ne_bytes();
                    if _start <= 1064 && _end > 1064 {
                        _buf[(1064 - _start) as usize] = _value[0];
                    }
                    if _start <= 1065 && _end > 1065 {
                        _buf[(1065 - _start) as usize] = _value[1];
                    }
                    if _start <= 1066 && _end > 1066 {
                        _buf[(1066 - _start) as usize] = _value[2];
                    }
                    if _start <= 1067 && _end > 1067 {
                        _buf[(1067 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => return Err(MemError::ReadViolation),
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_power_pofcon()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1304..=1311, 1305..=1312) => {
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_power_gpregret()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_clock_lfclksrc()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1316..=1327, 1317..=1328) => {
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_power_ramon()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_mpu_perr0()?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _value =
                        self.0.lock().unwrap().read_mpu_rlenr0()?.to_ne_bytes();
                    if _start <= 1324 && _end > 1324 {
                        _buf[(1324 - _start) as usize] = _value[0];
                    }
                    if _start <= 1325 && _end > 1325 {
                        _buf[(1325 - _start) as usize] = _value[1];
                    }
                    if _start <= 1326 && _end > 1326 {
                        _buf[(1326 - _start) as usize] = _value[2];
                    }
                    if _start <= 1327 && _end > 1327 {
                        _buf[(1327 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let _value = self.read_clock_ctiv()?.to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1348..=1351, 1349..=1352) => {
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_power_reset()?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1360..=1367, 1361..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let _value = self.read_power_ramonb()?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value = self.read_clock_xtalfreq()?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1400..=1403, 1401..=1404) => {
                if _start < 1404 && _end > 1400 {
                    let _value = self.read_power_dcdcen()?.to_ne_bytes();
                    if _start <= 1400 && _end > 1400 {
                        _buf[(1400 - _start) as usize] = _value[0];
                    }
                    if _start <= 1401 && _end > 1401 {
                        _buf[(1401 - _start) as usize] = _value[1];
                    }
                    if _start <= 1402 && _end > 1402 {
                        _buf[(1402 - _start) as usize] = _value[2];
                    }
                    if _start <= 1403 && _end > 1403 {
                        _buf[(1403 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1536..=1551, 1537..=1552) => {
                if _start < 1540 && _end > 1536 {
                    let _value = self.read_mpu_protenset0()?.to_ne_bytes();
                    if _start <= 1536 && _end > 1536 {
                        _buf[(1536 - _start) as usize] = _value[0];
                    }
                    if _start <= 1537 && _end > 1537 {
                        _buf[(1537 - _start) as usize] = _value[1];
                    }
                    if _start <= 1538 && _end > 1538 {
                        _buf[(1538 - _start) as usize] = _value[2];
                    }
                    if _start <= 1539 && _end > 1539 {
                        _buf[(1539 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1544 && _end > 1540 {
                    let _value = self.read_mpu_protenset1()?.to_ne_bytes();
                    if _start <= 1540 && _end > 1540 {
                        _buf[(1540 - _start) as usize] = _value[0];
                    }
                    if _start <= 1541 && _end > 1541 {
                        _buf[(1541 - _start) as usize] = _value[1];
                    }
                    if _start <= 1542 && _end > 1542 {
                        _buf[(1542 - _start) as usize] = _value[2];
                    }
                    if _start <= 1543 && _end > 1543 {
                        _buf[(1543 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1548 && _end > 1544 {
                    let _value = self.read_mpu_disableindebug()?.to_ne_bytes();
                    if _start <= 1544 && _end > 1544 {
                        _buf[(1544 - _start) as usize] = _value[0];
                    }
                    if _start <= 1545 && _end > 1545 {
                        _buf[(1545 - _start) as usize] = _value[1];
                    }
                    if _start <= 1546 && _end > 1546 {
                        _buf[(1546 - _start) as usize] = _value[2];
                    }
                    if _start <= 1547 && _end > 1547 {
                        _buf[(1547 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1552 && _end > 1548 {
                    let _value = self.read_mpu_protblocksize()?.to_ne_bytes();
                    if _start <= 1548 && _end > 1548 {
                        _buf[(1548 - _start) as usize] = _value[0];
                    }
                    if _start <= 1549 && _end > 1549 {
                        _buf[(1549 - _start) as usize] = _value[1];
                    }
                    if _start <= 1550 && _end > 1550 {
                        _buf[(1550 - _start) as usize] = _value[2];
                    }
                    if _start <= 1551 && _end > 1551 {
                        _buf[(1551 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (2568..=2571, 2569..=2572) => {
                if _start < 2572 && _end > 2568 {
                    let _value = self.read_power_dcdcforce()?.to_ne_bytes();
                    if _start <= 2568 && _end > 2568 {
                        _buf[(2568 - _start) as usize] = _value[0];
                    }
                    if _start <= 2569 && _end > 2569 {
                        _buf[(2569 - _start) as usize] = _value[1];
                    }
                    if _start <= 2570 && _end > 2570 {
                        _buf[(2570 - _start) as usize] = _value[2];
                    }
                    if _start <= 2571 && _end > 2571 {
                        _buf[(2571 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073741824;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=27, 1..=28) => {
                if _start < 4 && _end > 0 {
                    assert ! (_start <= 0u64 && _end >= 4u64 , "partial write for CLOCK TASKS_HFCLKSTART not implemented" ,);
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_hfclkstart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert ! (_start <= 4u64 && _end >= 8u64 , "partial write for CLOCK TASKS_HFCLKSTOP not implemented" ,);
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_hfclkstop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert ! (_start <= 8u64 && _end >= 12u64 , "partial write for CLOCK TASKS_LFCLKSTART not implemented" ,);
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_lfclkstart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert ! (_start <= 12u64 && _end >= 16u64 , "partial write for CLOCK TASKS_LFCLKSTOP not implemented" ,);
                    let start = _start.saturating_sub(12u64) as usize;
                    let end =
                        (_end.saturating_sub(12u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_lfclkstop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16u64 && _end >= 20u64,
                        "partial write for CLOCK TASKS_CAL not implemented",
                    );
                    let start = _start.saturating_sub(16u64) as usize;
                    let end =
                        (_end.saturating_sub(16u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_cal(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert!(
                        _start <= 20u64 && _end >= 24u64,
                        "partial write for CLOCK TASKS_CTSTART not implemented",
                    );
                    let start = _start.saturating_sub(20u64) as usize;
                    let end =
                        (_end.saturating_sub(20u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_ctstart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 28 && _end > 24 {
                    assert!(
                        _start <= 24u64 && _end >= 28u64,
                        "partial write for CLOCK TASKS_CTSTOP not implemented",
                    );
                    let start = _start.saturating_sub(24u64) as usize;
                    let end =
                        (_end.saturating_sub(24u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_ctstop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (120..=127, 121..=128) => {
                if _start < 124 && _end > 120 {
                    assert ! (_start <= 120u64 && _end >= 124u64 , "partial write for POWER TASKS_CONSTLAT not implemented" ,);
                    let start = _start.saturating_sub(120u64) as usize;
                    let end =
                        (_end.saturating_sub(120u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_power_tasks_constlat(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 128 && _end > 124 {
                    assert!(
                        _start <= 124u64 && _end >= 128u64,
                        "partial write for POWER TASKS_LOWPWR not implemented",
                    );
                    let start = _start.saturating_sub(124u64) as usize;
                    let end =
                        (_end.saturating_sub(124u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_power_tasks_lowpwr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=275, 257..=276) => {
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264u64 && _end >= 268u64 , "partial write for POWER EVENTS_POFWARN not implemented" ,);
                    let start = _start.saturating_sub(264u64) as usize;
                    let end =
                        (_end.saturating_sub(264u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_power_events_pofwarn(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 260 && _end > 256 {
                    assert ! (_start <= 256u64 && _end >= 260u64 , "partial write for CLOCK EVENTS_HFCLKSTARTED not implemented" ,);
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_events_hfclkstarted(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260u64 && _end >= 264u64 , "partial write for CLOCK EVENTS_LFCLKSTARTED not implemented" ,);
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_events_lfclkstarted(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268u64 && _end >= 272u64,
                        "partial write for CLOCK EVENTS_DONE not implemented",
                    );
                    let start = _start.saturating_sub(268u64) as usize;
                    let end =
                        (_end.saturating_sub(268u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_events_done(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272u64 && _end >= 276u64,
                        "partial write for CLOCK EVENTS_CTTO not implemented",
                    );
                    let start = _start.saturating_sub(272u64) as usize;
                    let end =
                        (_end.saturating_sub(272u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_events_ctto(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_powerclock_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_powerclock_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let offset = 1024u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1024u64) as usize;
                    let end =
                        (_end.saturating_sub(1024u64) as usize).min(start + 4);
                    self.write_power_resetreas(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1032..=1039, 1033..=1040) => return Err(MemError::WriteViolation),
            (1044..=1055, 1045..=1056) => return Err(MemError::WriteViolation),
            (1064..=1067, 1065..=1068) => return Err(MemError::WriteViolation),
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_power_systemoff(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let offset = 1296u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.write_power_pofcon(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1304..=1311, 1305..=1312) => {
                if _start < 1312 && _end > 1308 {
                    let offset = 1308u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1308u64) as usize;
                    let end =
                        (_end.saturating_sub(1308u64) as usize).min(start + 4);
                    self.write_power_gpregret(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = 1304u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1304u64) as usize;
                    let end =
                        (_end.saturating_sub(1304u64) as usize).min(start + 4);
                    self.write_clock_lfclksrc(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1316..=1327, 1317..=1328) => {
                if _start < 1320 && _end > 1316 {
                    let offset = 1316u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1316u64) as usize;
                    let end =
                        (_end.saturating_sub(1316u64) as usize).min(start + 4);
                    self.write_power_ramon(offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = 1320u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1320u64) as usize;
                    let end =
                        (_end.saturating_sub(1320u64) as usize).min(start + 4);
                    self.write_mpu_perr0(offset, &_buf[start..end])?;
                }
                if _start < 1328 && _end > 1324 {
                    assert!(
                        _start <= 1324u64 && _end >= 1328u64,
                        "partial write for MPU RLENR0 not implemented",
                    );
                    let start = _start.saturating_sub(1324u64) as usize;
                    let end =
                        (_end.saturating_sub(1324u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mpu_rlenr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let offset = 1336u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1336u64) as usize;
                    let end =
                        (_end.saturating_sub(1336u64) as usize).min(start + 4);
                    self.write_clock_ctiv(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1348..=1351, 1349..=1352) => {
                if _start < 1352 && _end > 1348 {
                    let offset = 1348u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1348u64) as usize;
                    let end =
                        (_end.saturating_sub(1348u64) as usize).min(start + 4);
                    self.write_power_reset(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1360..=1367, 1361..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let offset = 1364u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1364u64) as usize;
                    let end =
                        (_end.saturating_sub(1364u64) as usize).min(start + 4);
                    self.write_power_ramonb(offset, &_buf[start..end])?;
                }
                if _start < 1364 && _end > 1360 {
                    let offset = 1360u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1360u64) as usize;
                    let end =
                        (_end.saturating_sub(1360u64) as usize).min(start + 4);
                    self.write_clock_xtalfreq(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1400..=1403, 1401..=1404) => {
                if _start < 1404 && _end > 1400 {
                    let offset = 1400u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1400u64) as usize;
                    let end =
                        (_end.saturating_sub(1400u64) as usize).min(start + 4);
                    self.write_power_dcdcen(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1536..=1551, 1537..=1552) => {
                if _start < 1540 && _end > 1536 {
                    let offset = 1536u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1536u64) as usize;
                    let end =
                        (_end.saturating_sub(1536u64) as usize).min(start + 4);
                    self.write_mpu_protenset0(offset, &_buf[start..end])?;
                }
                if _start < 1544 && _end > 1540 {
                    let offset = 1540u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1540u64) as usize;
                    let end =
                        (_end.saturating_sub(1540u64) as usize).min(start + 4);
                    self.write_mpu_protenset1(offset, &_buf[start..end])?;
                }
                if _start < 1548 && _end > 1544 {
                    let offset = 1544u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1544u64) as usize;
                    let end =
                        (_end.saturating_sub(1544u64) as usize).min(start + 4);
                    self.write_mpu_disableindebug(offset, &_buf[start..end])?;
                }
                if _start < 1552 && _end > 1548 {
                    let offset = 1548u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1548u64) as usize;
                    let end =
                        (_end.saturating_sub(1548u64) as usize).min(start + 4);
                    self.write_mpu_protblocksize(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (2568..=2571, 2569..=2572) => {
                if _start < 2572 && _end > 2568 {
                    let offset = 2568u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2568u64) as usize;
                    let end =
                        (_end.saturating_sub(2568u64) as usize).min(start + 4);
                    self.write_power_dcdcforce(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40000000 {
    fn read_powerclock_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_powerclock_intenset_pofwarn()?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenset_hfclkstarted()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenset_lfclkstarted()?,
        ) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_powerclock_intenset_done()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_powerclock_intenset_ctto()?)
                << 4u32;
        Ok(_value)
    }
    fn write_powerclock_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_powerclock_intenset_pofwarn(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_hfclkstarted(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_lfclkstarted(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_done((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_ctto((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_powerclock_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_powerclock_intenclr_pofwarn()?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenclr_hfclkstarted()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenclr_lfclkstarted()?,
        ) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_powerclock_intenclr_done()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_powerclock_intenclr_ctto()?)
                << 4u32;
        Ok(_value)
    }
    fn write_powerclock_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_powerclock_intenclr_pofwarn(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_hfclkstarted(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_lfclkstarted(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_done((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_ctto((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_resetreas(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_resetreas_resetpin()?)
                << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_resetreas_dog()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_resetreas_sreq()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_resetreas_lockup()?)
                << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_resetreas_off()?)
            << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_resetreas_lpcomp()?)
                << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_resetreas_dif()?)
            << 18u32;
        Ok(_value)
    }
    fn write_power_resetreas(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_resetpin((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_dog((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_sreq((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_lockup((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_off((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_lpcomp((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_dif((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_ramstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramstatus_ramblock0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramstatus_ramblock1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramstatus_ramblock2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramstatus_ramblock3()?)
                << 3u32;
        Ok(_value)
    }
    fn write_power_systemoff(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_systemoff_systemoff((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_pofcon(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_pofcon_pof()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_pofcon_threshold()?)
                << 1u32;
        Ok(_value)
    }
    fn write_power_pofcon(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_pofcon_pof((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_pofcon_threshold((_value[_i] >> 1) & 3u8)?;
        }
        Ok(())
    }
    fn read_power_gpregret(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_gpregret_gpregret()?)
                << 0u32;
        Ok(_value)
    }
    fn write_power_gpregret(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_gpregret_gpregret((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_power_ramon(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramon_onram0()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramon_onram1()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramon_offram0()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramon_offram1()?)
            << 17u32;
        Ok(_value)
    }
    fn write_power_ramon(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramon_onram0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramon_onram1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramon_offram0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramon_offram1((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_reset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_reset_reset()?) << 0u32;
        Ok(_value)
    }
    fn write_power_reset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_reset_reset((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_ramonb(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramonb_onram2()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramonb_onram3()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramonb_offram2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramonb_offram3()?)
                << 17u32;
        Ok(_value)
    }
    fn write_power_ramonb(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramonb_onram2((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramonb_onram3((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramonb_offram2((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramonb_offram3((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_dcdcen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_power_dcdcen_dcdcen()?)
            << 0u32;
        Ok(_value)
    }
    fn write_power_dcdcen(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_dcdcen_dcdcen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_dcdcforce(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_dcdcforce_forceoff()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_dcdcforce_forceon()?)
                << 1u32;
        Ok(_value)
    }
    fn write_power_dcdcforce(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_dcdcforce_forceoff((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_dcdcforce_forceon((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_clock_hfclkrun(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_hfclkrun_status()?)
                << 0u32;
        Ok(_value)
    }
    fn read_clock_hfclkstat(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_clock_hfclkstat_src()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_hfclkstat_state()?)
                << 16u32;
        Ok(_value)
    }
    fn read_clock_lfclkrun(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_lfclkrun_status()?)
                << 0u32;
        Ok(_value)
    }
    fn read_clock_lfclkstat(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_clock_lfclkstat_src()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_lfclkstat_state()?)
                << 16u32;
        Ok(_value)
    }
    fn read_clock_lfclksrccopy(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_lfclksrccopy_src()?)
                << 0u32;
        Ok(_value)
    }
    fn read_clock_lfclksrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_clock_lfclksrc_src()?)
            << 0u32;
        Ok(_value)
    }
    fn write_clock_lfclksrc(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_lfclksrc_src((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_clock_ctiv(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_ctiv_ctiv()?) << 0u32;
        Ok(_value)
    }
    fn write_clock_ctiv(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_ctiv_ctiv((_value[_i] >> 0) & 127u8)?;
        }
        Ok(())
    }
    fn read_clock_xtalfreq(&self) -> MemResult<u32> {
        let mut _value = 4294967040;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_xtalfreq_xtalfreq()?)
                << 0u32;
        Ok(_value)
    }
    fn write_clock_xtalfreq(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_xtalfreq_xtalfreq((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_mpu_perr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_power_clock()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_radio()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_uart0()?) << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_perr0_spi0_twi0()?)
            << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_perr0_spi1_twi1()?)
            << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_gpiote()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_adc()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_timer0()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_timer1()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_timer2()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_rtc0()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_temp()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_rng()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_ecb()?) << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_perr0_ccm_aar()?)
            << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_wdt()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_rtc1()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_qdec()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_lpcomp()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_nvmc()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_perr0_ppi()?) << 31u32;
        Ok(_value)
    }
    fn write_mpu_perr0(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_power_clock((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_radio((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_uart0((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_spi0_twi0((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_spi1_twi1((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_gpiote((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_adc((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_timer0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_timer1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_timer2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_rtc0((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_temp((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_rng((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_ecb((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_ccm_aar((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_wdt((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_rtc1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_qdec((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_lpcomp((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_nvmc((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_perr0_ppi((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_protenset0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg3()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg4()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg5()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg6()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg7()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg8()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg9()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg10()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg11()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg12()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg13()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg14()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg15()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg16()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg17()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg18()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg19()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg20()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg21()?)
                << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg22()?)
                << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg23()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg24()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg25()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg26()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg27()?)
                << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg28()?)
                << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg29()?)
                << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg30()?)
                << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset0_protreg31()?)
                << 31u32;
        Ok(_value)
    }
    fn write_mpu_protenset0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset0_protreg31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_protenset1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg32()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg33()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg34()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg35()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg36()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg37()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg38()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg39()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg40()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg41()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg42()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg43()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg44()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg45()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg46()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg47()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg48()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg49()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg50()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg51()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg52()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg53()?)
                << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg54()?)
                << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg55()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg56()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg57()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg58()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg59()?)
                << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg60()?)
                << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg61()?)
                << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg62()?)
                << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_protenset1_protreg63()?)
                << 31u32;
        Ok(_value)
    }
    fn write_mpu_protenset1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg32((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg33((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg34((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg35((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg36((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg37((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg38((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg39((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg40((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg41((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg42((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg43((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg44((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg45((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg46((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg47((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg48((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg49((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg50((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg51((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg52((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg53((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg54((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg55((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg56((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg57((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg58((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg59((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg60((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg61((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg62((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protenset1_protreg63((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_disableindebug(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mpu_disableindebug_disableindebug()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_mpu_disableindebug(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_disableindebug_disableindebug(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_mpu_protblocksize(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mpu_protblocksize_protblocksize()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_mpu_protblocksize(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_protblocksize_protblocksize(
                    (_value[_i] >> 0) & 3u8,
                )?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40001000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40001000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073745920;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=35, 1..=36) => return Err(MemError::ReadViolation),
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_ready()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_address()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_payload()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_end()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_disabled()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_devmatch()?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_devmiss()?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_rssiend()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_bcmatch()?
                        .to_ne_bytes();
                    if _start <= 296 && _end > 296 {
                        _buf[(296 - _start) as usize] = _value[0];
                    }
                    if _start <= 297 && _end > 297 {
                        _buf[(297 - _start) as usize] = _value[1];
                    }
                    if _start <= 298 && _end > 298 {
                        _buf[(298 - _start) as usize] = _value[2];
                    }
                    if _start <= 299 && _end > 299 {
                        _buf[(299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_radio_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_radio_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_radio_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_radio_crcstatus()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1032..=1043, 1033..=1044) => {
                if _start < 1036 && _end > 1032 {
                    let _value = self.read_radio_rxmatch()?.to_ne_bytes();
                    if _start <= 1032 && _end > 1032 {
                        _buf[(1032 - _start) as usize] = _value[0];
                    }
                    if _start <= 1033 && _end > 1033 {
                        _buf[(1033 - _start) as usize] = _value[1];
                    }
                    if _start <= 1034 && _end > 1034 {
                        _buf[(1034 - _start) as usize] = _value[2];
                    }
                    if _start <= 1035 && _end > 1035 {
                        _buf[(1035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _value = self.read_radio_rxcrc()?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1044 && _end > 1040 {
                    let _value = self.read_radio_dai()?.to_ne_bytes();
                    if _start <= 1040 && _end > 1040 {
                        _buf[(1040 - _start) as usize] = _value[0];
                    }
                    if _start <= 1041 && _end > 1041 {
                        _buf[(1041 - _start) as usize] = _value[1];
                    }
                    if _start <= 1042 && _end > 1042 {
                        _buf[(1042 - _start) as usize] = _value[2];
                    }
                    if _start <= 1043 && _end > 1043 {
                        _buf[(1043 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1355, 1285..=1356) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_packetptr()?
                        .to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_radio_frequency()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_radio_txpower()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_radio_mode()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_radio_pcnf0()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_radio_pcnf1()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_base0()?
                        .to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_base1()?
                        .to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_radio_prefix0()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_radio_prefix1()?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _value = self.read_radio_txaddress()?.to_ne_bytes();
                    if _start <= 1324 && _end > 1324 {
                        _buf[(1324 - _start) as usize] = _value[0];
                    }
                    if _start <= 1325 && _end > 1325 {
                        _buf[(1325 - _start) as usize] = _value[1];
                    }
                    if _start <= 1326 && _end > 1326 {
                        _buf[(1326 - _start) as usize] = _value[2];
                    }
                    if _start <= 1327 && _end > 1327 {
                        _buf[(1327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _value = self.read_radio_rxaddresses()?.to_ne_bytes();
                    if _start <= 1328 && _end > 1328 {
                        _buf[(1328 - _start) as usize] = _value[0];
                    }
                    if _start <= 1329 && _end > 1329 {
                        _buf[(1329 - _start) as usize] = _value[1];
                    }
                    if _start <= 1330 && _end > 1330 {
                        _buf[(1330 - _start) as usize] = _value[2];
                    }
                    if _start <= 1331 && _end > 1331 {
                        _buf[(1331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _value = self.read_radio_crccnf()?.to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _value = self.read_radio_crcpoly()?.to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _value = self.read_radio_crcinit()?.to_ne_bytes();
                    if _start <= 1340 && _end > 1340 {
                        _buf[(1340 - _start) as usize] = _value[0];
                    }
                    if _start <= 1341 && _end > 1341 {
                        _buf[(1341 - _start) as usize] = _value[1];
                    }
                    if _start <= 1342 && _end > 1342 {
                        _buf[(1342 - _start) as usize] = _value[2];
                    }
                    if _start <= 1343 && _end > 1343 {
                        _buf[(1343 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_radio_test()?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_radio_tifs()?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_radio_rssisample()?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1360..=1367, 1361..=1368) => {
                if _start < 1364 && _end > 1360 {
                    let _value = self.read_radio_state()?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _value = self.read_radio_datawhiteiv()?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1376..=1379, 1377..=1380) => {
                if _start < 1380 && _end > 1376 {
                    let _value =
                        self.0.lock().unwrap().read_radio_bcc()?.to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1536..=1603, 1537..=1604) => {
                if _start < 1540 && _end > 1536 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(0)?
                        .to_ne_bytes();
                    if _start <= 1536 && _end > 1536 {
                        _buf[(1536 - _start) as usize] = _value[0];
                    }
                    if _start <= 1537 && _end > 1537 {
                        _buf[(1537 - _start) as usize] = _value[1];
                    }
                    if _start <= 1538 && _end > 1538 {
                        _buf[(1538 - _start) as usize] = _value[2];
                    }
                    if _start <= 1539 && _end > 1539 {
                        _buf[(1539 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1556 && _end > 1552 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(1)?
                        .to_ne_bytes();
                    if _start <= 1552 && _end > 1552 {
                        _buf[(1552 - _start) as usize] = _value[0];
                    }
                    if _start <= 1553 && _end > 1553 {
                        _buf[(1553 - _start) as usize] = _value[1];
                    }
                    if _start <= 1554 && _end > 1554 {
                        _buf[(1554 - _start) as usize] = _value[2];
                    }
                    if _start <= 1555 && _end > 1555 {
                        _buf[(1555 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1572 && _end > 1568 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(2)?
                        .to_ne_bytes();
                    if _start <= 1568 && _end > 1568 {
                        _buf[(1568 - _start) as usize] = _value[0];
                    }
                    if _start <= 1569 && _end > 1569 {
                        _buf[(1569 - _start) as usize] = _value[1];
                    }
                    if _start <= 1570 && _end > 1570 {
                        _buf[(1570 - _start) as usize] = _value[2];
                    }
                    if _start <= 1571 && _end > 1571 {
                        _buf[(1571 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1588 && _end > 1584 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(3)?
                        .to_ne_bytes();
                    if _start <= 1584 && _end > 1584 {
                        _buf[(1584 - _start) as usize] = _value[0];
                    }
                    if _start <= 1585 && _end > 1585 {
                        _buf[(1585 - _start) as usize] = _value[1];
                    }
                    if _start <= 1586 && _end > 1586 {
                        _buf[(1586 - _start) as usize] = _value[2];
                    }
                    if _start <= 1587 && _end > 1587 {
                        _buf[(1587 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1604 && _end > 1600 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(4)?
                        .to_ne_bytes();
                    if _start <= 1600 && _end > 1600 {
                        _buf[(1600 - _start) as usize] = _value[0];
                    }
                    if _start <= 1601 && _end > 1601 {
                        _buf[(1601 - _start) as usize] = _value[1];
                    }
                    if _start <= 1602 && _end > 1602 {
                        _buf[(1602 - _start) as usize] = _value[2];
                    }
                    if _start <= 1603 && _end > 1603 {
                        _buf[(1603 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1620 && _end > 1616 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(5)?
                        .to_ne_bytes();
                    if _start <= 1616 && _end > 1616 {
                        _buf[(1616 - _start) as usize] = _value[0];
                    }
                    if _start <= 1617 && _end > 1617 {
                        _buf[(1617 - _start) as usize] = _value[1];
                    }
                    if _start <= 1618 && _end > 1618 {
                        _buf[(1618 - _start) as usize] = _value[2];
                    }
                    if _start <= 1619 && _end > 1619 {
                        _buf[(1619 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1636 && _end > 1632 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(6)?
                        .to_ne_bytes();
                    if _start <= 1632 && _end > 1632 {
                        _buf[(1632 - _start) as usize] = _value[0];
                    }
                    if _start <= 1633 && _end > 1633 {
                        _buf[(1633 - _start) as usize] = _value[1];
                    }
                    if _start <= 1634 && _end > 1634 {
                        _buf[(1634 - _start) as usize] = _value[2];
                    }
                    if _start <= 1635 && _end > 1635 {
                        _buf[(1635 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1652 && _end > 1648 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(7)?
                        .to_ne_bytes();
                    if _start <= 1648 && _end > 1648 {
                        _buf[(1648 - _start) as usize] = _value[0];
                    }
                    if _start <= 1649 && _end > 1649 {
                        _buf[(1649 - _start) as usize] = _value[1];
                    }
                    if _start <= 1650 && _end > 1650 {
                        _buf[(1650 - _start) as usize] = _value[2];
                    }
                    if _start <= 1651 && _end > 1651 {
                        _buf[(1651 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1572 && _end > 1568 {
                    let _value = self.read_radio_dapn(0)?.to_ne_bytes();
                    if _start <= 1568 && _end > 1568 {
                        _buf[(1568 - _start) as usize] = _value[0];
                    }
                    if _start <= 1569 && _end > 1569 {
                        _buf[(1569 - _start) as usize] = _value[1];
                    }
                    if _start <= 1570 && _end > 1570 {
                        _buf[(1570 - _start) as usize] = _value[2];
                    }
                    if _start <= 1571 && _end > 1571 {
                        _buf[(1571 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1588 && _end > 1584 {
                    let _value = self.read_radio_dapn(1)?.to_ne_bytes();
                    if _start <= 1584 && _end > 1584 {
                        _buf[(1584 - _start) as usize] = _value[0];
                    }
                    if _start <= 1585 && _end > 1585 {
                        _buf[(1585 - _start) as usize] = _value[1];
                    }
                    if _start <= 1586 && _end > 1586 {
                        _buf[(1586 - _start) as usize] = _value[2];
                    }
                    if _start <= 1587 && _end > 1587 {
                        _buf[(1587 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1604 && _end > 1600 {
                    let _value = self.read_radio_dapn(2)?.to_ne_bytes();
                    if _start <= 1600 && _end > 1600 {
                        _buf[(1600 - _start) as usize] = _value[0];
                    }
                    if _start <= 1601 && _end > 1601 {
                        _buf[(1601 - _start) as usize] = _value[1];
                    }
                    if _start <= 1602 && _end > 1602 {
                        _buf[(1602 - _start) as usize] = _value[2];
                    }
                    if _start <= 1603 && _end > 1603 {
                        _buf[(1603 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1620 && _end > 1616 {
                    let _value = self.read_radio_dapn(3)?.to_ne_bytes();
                    if _start <= 1616 && _end > 1616 {
                        _buf[(1616 - _start) as usize] = _value[0];
                    }
                    if _start <= 1617 && _end > 1617 {
                        _buf[(1617 - _start) as usize] = _value[1];
                    }
                    if _start <= 1618 && _end > 1618 {
                        _buf[(1618 - _start) as usize] = _value[2];
                    }
                    if _start <= 1619 && _end > 1619 {
                        _buf[(1619 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1636 && _end > 1632 {
                    let _value = self.read_radio_dapn(4)?.to_ne_bytes();
                    if _start <= 1632 && _end > 1632 {
                        _buf[(1632 - _start) as usize] = _value[0];
                    }
                    if _start <= 1633 && _end > 1633 {
                        _buf[(1633 - _start) as usize] = _value[1];
                    }
                    if _start <= 1634 && _end > 1634 {
                        _buf[(1634 - _start) as usize] = _value[2];
                    }
                    if _start <= 1635 && _end > 1635 {
                        _buf[(1635 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1652 && _end > 1648 {
                    let _value = self.read_radio_dapn(5)?.to_ne_bytes();
                    if _start <= 1648 && _end > 1648 {
                        _buf[(1648 - _start) as usize] = _value[0];
                    }
                    if _start <= 1649 && _end > 1649 {
                        _buf[(1649 - _start) as usize] = _value[1];
                    }
                    if _start <= 1650 && _end > 1650 {
                        _buf[(1650 - _start) as usize] = _value[2];
                    }
                    if _start <= 1651 && _end > 1651 {
                        _buf[(1651 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1668 && _end > 1664 {
                    let _value = self.read_radio_dapn(6)?.to_ne_bytes();
                    if _start <= 1664 && _end > 1664 {
                        _buf[(1664 - _start) as usize] = _value[0];
                    }
                    if _start <= 1665 && _end > 1665 {
                        _buf[(1665 - _start) as usize] = _value[1];
                    }
                    if _start <= 1666 && _end > 1666 {
                        _buf[(1666 - _start) as usize] = _value[2];
                    }
                    if _start <= 1667 && _end > 1667 {
                        _buf[(1667 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1684 && _end > 1680 {
                    let _value = self.read_radio_dapn(7)?.to_ne_bytes();
                    if _start <= 1680 && _end > 1680 {
                        _buf[(1680 - _start) as usize] = _value[0];
                    }
                    if _start <= 1681 && _end > 1681 {
                        _buf[(1681 - _start) as usize] = _value[1];
                    }
                    if _start <= 1682 && _end > 1682 {
                        _buf[(1682 - _start) as usize] = _value[2];
                    }
                    if _start <= 1683 && _end > 1683 {
                        _buf[(1683 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1604 && _end > 1600 {
                    let _value = self.read_radio_dacnf()?.to_ne_bytes();
                    if _start <= 1600 && _end > 1600 {
                        _buf[(1600 - _start) as usize] = _value[0];
                    }
                    if _start <= 1601 && _end > 1601 {
                        _buf[(1601 - _start) as usize] = _value[1];
                    }
                    if _start <= 1602 && _end > 1602 {
                        _buf[(1602 - _start) as usize] = _value[2];
                    }
                    if _start <= 1603 && _end > 1603 {
                        _buf[(1603 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1828..=1847, 1829..=1848) => {
                if _start < 1832 && _end > 1828 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_override0()?
                        .to_ne_bytes();
                    if _start <= 1828 && _end > 1828 {
                        _buf[(1828 - _start) as usize] = _value[0];
                    }
                    if _start <= 1829 && _end > 1829 {
                        _buf[(1829 - _start) as usize] = _value[1];
                    }
                    if _start <= 1830 && _end > 1830 {
                        _buf[(1830 - _start) as usize] = _value[2];
                    }
                    if _start <= 1831 && _end > 1831 {
                        _buf[(1831 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1836 && _end > 1832 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_override1()?
                        .to_ne_bytes();
                    if _start <= 1832 && _end > 1832 {
                        _buf[(1832 - _start) as usize] = _value[0];
                    }
                    if _start <= 1833 && _end > 1833 {
                        _buf[(1833 - _start) as usize] = _value[1];
                    }
                    if _start <= 1834 && _end > 1834 {
                        _buf[(1834 - _start) as usize] = _value[2];
                    }
                    if _start <= 1835 && _end > 1835 {
                        _buf[(1835 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1840 && _end > 1836 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_override2()?
                        .to_ne_bytes();
                    if _start <= 1836 && _end > 1836 {
                        _buf[(1836 - _start) as usize] = _value[0];
                    }
                    if _start <= 1837 && _end > 1837 {
                        _buf[(1837 - _start) as usize] = _value[1];
                    }
                    if _start <= 1838 && _end > 1838 {
                        _buf[(1838 - _start) as usize] = _value[2];
                    }
                    if _start <= 1839 && _end > 1839 {
                        _buf[(1839 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1844 && _end > 1840 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_override3()?
                        .to_ne_bytes();
                    if _start <= 1840 && _end > 1840 {
                        _buf[(1840 - _start) as usize] = _value[0];
                    }
                    if _start <= 1841 && _end > 1841 {
                        _buf[(1841 - _start) as usize] = _value[1];
                    }
                    if _start <= 1842 && _end > 1842 {
                        _buf[(1842 - _start) as usize] = _value[2];
                    }
                    if _start <= 1843 && _end > 1843 {
                        _buf[(1843 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1848 && _end > 1844 {
                    let _value = self.read_radio_override4()?.to_ne_bytes();
                    if _start <= 1844 && _end > 1844 {
                        _buf[(1844 - _start) as usize] = _value[0];
                    }
                    if _start <= 1845 && _end > 1845 {
                        _buf[(1845 - _start) as usize] = _value[1];
                    }
                    if _start <= 1846 && _end > 1846 {
                        _buf[(1846 - _start) as usize] = _value[2];
                    }
                    if _start <= 1847 && _end > 1847 {
                        _buf[(1847 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_radio_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073745920;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=35, 1..=36) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for RADIO TASKS_TXEN not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_txen(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for RADIO TASKS_RXEN not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_rxen(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8u64 && _end >= 12u64,
                        "partial write for RADIO TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12u64 && _end >= 16u64,
                        "partial write for RADIO TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(12u64) as usize;
                    let end =
                        (_end.saturating_sub(12u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16u64 && _end >= 20u64,
                        "partial write for RADIO TASKS_DISABLE not implemented",
                    );
                    let start = _start.saturating_sub(16u64) as usize;
                    let end =
                        (_end.saturating_sub(16u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_disable(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert ! (_start <= 20u64 && _end >= 24u64 , "partial write for RADIO TASKS_RSSISTART not implemented" ,);
                    let start = _start.saturating_sub(20u64) as usize;
                    let end =
                        (_end.saturating_sub(20u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_rssistart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 28 && _end > 24 {
                    assert ! (_start <= 24u64 && _end >= 28u64 , "partial write for RADIO TASKS_RSSISTOP not implemented" ,);
                    let start = _start.saturating_sub(24u64) as usize;
                    let end =
                        (_end.saturating_sub(24u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_rssistop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28u64 && _end >= 32u64,
                        "partial write for RADIO TASKS_BCSTART not implemented",
                    );
                    let start = _start.saturating_sub(28u64) as usize;
                    let end =
                        (_end.saturating_sub(28u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_bcstart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 36 && _end > 32 {
                    assert!(
                        _start <= 32u64 && _end >= 36u64,
                        "partial write for RADIO TASKS_BCSTOP not implemented",
                    );
                    let start = _start.saturating_sub(32u64) as usize;
                    let end =
                        (_end.saturating_sub(32u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_bcstop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for RADIO EVENTS_READY not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_ready(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260u64 && _end >= 264u64 , "partial write for RADIO EVENTS_ADDRESS not implemented" ,);
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_address(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264u64 && _end >= 268u64 , "partial write for RADIO EVENTS_PAYLOAD not implemented" ,);
                    let start = _start.saturating_sub(264u64) as usize;
                    let end =
                        (_end.saturating_sub(264u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_payload(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268u64 && _end >= 272u64,
                        "partial write for RADIO EVENTS_END not implemented",
                    );
                    let start = _start.saturating_sub(268u64) as usize;
                    let end =
                        (_end.saturating_sub(268u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_end(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert ! (_start <= 272u64 && _end >= 276u64 , "partial write for RADIO EVENTS_DISABLED not implemented" ,);
                    let start = _start.saturating_sub(272u64) as usize;
                    let end =
                        (_end.saturating_sub(272u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_disabled(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert ! (_start <= 276u64 && _end >= 280u64 , "partial write for RADIO EVENTS_DEVMATCH not implemented" ,);
                    let start = _start.saturating_sub(276u64) as usize;
                    let end =
                        (_end.saturating_sub(276u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_devmatch(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert ! (_start <= 280u64 && _end >= 284u64 , "partial write for RADIO EVENTS_DEVMISS not implemented" ,);
                    let start = _start.saturating_sub(280u64) as usize;
                    let end =
                        (_end.saturating_sub(280u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_devmiss(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert ! (_start <= 284u64 && _end >= 288u64 , "partial write for RADIO EVENTS_RSSIEND not implemented" ,);
                    let start = _start.saturating_sub(284u64) as usize;
                    let end =
                        (_end.saturating_sub(284u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_rssiend(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    assert ! (_start <= 296u64 && _end >= 300u64 , "partial write for RADIO EVENTS_BCMATCH not implemented" ,);
                    let start = _start.saturating_sub(296u64) as usize;
                    let end =
                        (_end.saturating_sub(296u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_bcmatch(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_radio_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_radio_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_radio_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => return Err(MemError::WriteViolation),
            (1032..=1043, 1033..=1044) => return Err(MemError::WriteViolation),
            (1284..=1355, 1285..=1356) => {
                if _start < 1288 && _end > 1284 {
                    assert!(
                        _start <= 1284u64 && _end >= 1288u64,
                        "partial write for RADIO PACKETPTR not implemented",
                    );
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_packetptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = 1288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.write_radio_frequency(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = 1292u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.write_radio_txpower(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    let offset = 1296u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.write_radio_mode(offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = 1300u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1300u64) as usize;
                    let end =
                        (_end.saturating_sub(1300u64) as usize).min(start + 4);
                    self.write_radio_pcnf0(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = 1304u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1304u64) as usize;
                    let end =
                        (_end.saturating_sub(1304u64) as usize).min(start + 4);
                    self.write_radio_pcnf1(offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    assert!(
                        _start <= 1308u64 && _end >= 1312u64,
                        "partial write for RADIO BASE0 not implemented",
                    );
                    let start = _start.saturating_sub(1308u64) as usize;
                    let end =
                        (_end.saturating_sub(1308u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_base0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1316 && _end > 1312 {
                    assert!(
                        _start <= 1312u64 && _end >= 1316u64,
                        "partial write for RADIO BASE1 not implemented",
                    );
                    let start = _start.saturating_sub(1312u64) as usize;
                    let end =
                        (_end.saturating_sub(1312u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_base1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = 1316u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1316u64) as usize;
                    let end =
                        (_end.saturating_sub(1316u64) as usize).min(start + 4);
                    self.write_radio_prefix0(offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = 1320u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1320u64) as usize;
                    let end =
                        (_end.saturating_sub(1320u64) as usize).min(start + 4);
                    self.write_radio_prefix1(offset, &_buf[start..end])?;
                }
                if _start < 1328 && _end > 1324 {
                    let offset = 1324u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1324u64) as usize;
                    let end =
                        (_end.saturating_sub(1324u64) as usize).min(start + 4);
                    self.write_radio_txaddress(offset, &_buf[start..end])?;
                }
                if _start < 1332 && _end > 1328 {
                    let offset = 1328u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1328u64) as usize;
                    let end =
                        (_end.saturating_sub(1328u64) as usize).min(start + 4);
                    self.write_radio_rxaddresses(offset, &_buf[start..end])?;
                }
                if _start < 1336 && _end > 1332 {
                    let offset = 1332u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1332u64) as usize;
                    let end =
                        (_end.saturating_sub(1332u64) as usize).min(start + 4);
                    self.write_radio_crccnf(offset, &_buf[start..end])?;
                }
                if _start < 1340 && _end > 1336 {
                    let offset = 1336u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1336u64) as usize;
                    let end =
                        (_end.saturating_sub(1336u64) as usize).min(start + 4);
                    self.write_radio_crcpoly(offset, &_buf[start..end])?;
                }
                if _start < 1344 && _end > 1340 {
                    let offset = 1340u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1340u64) as usize;
                    let end =
                        (_end.saturating_sub(1340u64) as usize).min(start + 4);
                    self.write_radio_crcinit(offset, &_buf[start..end])?;
                }
                if _start < 1348 && _end > 1344 {
                    let offset = 1344u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1344u64) as usize;
                    let end =
                        (_end.saturating_sub(1344u64) as usize).min(start + 4);
                    self.write_radio_test(offset, &_buf[start..end])?;
                }
                if _start < 1352 && _end > 1348 {
                    let offset = 1348u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1348u64) as usize;
                    let end =
                        (_end.saturating_sub(1348u64) as usize).min(start + 4);
                    self.write_radio_tifs(offset, &_buf[start..end])?;
                }
                if _start < 1356 && _end > 1352 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1360..=1367, 1361..=1368) => {
                if _start < 1364 && _end > 1360 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1368 && _end > 1364 {
                    let offset = 1364u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1364u64) as usize;
                    let end =
                        (_end.saturating_sub(1364u64) as usize).min(start + 4);
                    self.write_radio_datawhiteiv(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1376..=1379, 1377..=1380) => {
                if _start < 1380 && _end > 1376 {
                    assert!(
                        _start <= 1376u64 && _end >= 1380u64,
                        "partial write for RADIO BCC not implemented",
                    );
                    let start = _start.saturating_sub(1376u64) as usize;
                    let end =
                        (_end.saturating_sub(1376u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_bcc(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1536..=1603, 1537..=1604) => {
                if _start < 1540 && _end > 1536 {
                    assert!(
                        _start <= 1536u64 && _end >= 1540u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1536u64) as usize;
                    let end =
                        (_end.saturating_sub(1536u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1556 && _end > 1552 {
                    assert!(
                        _start <= 1552u64 && _end >= 1556u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1552u64) as usize;
                    let end =
                        (_end.saturating_sub(1552u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1572 && _end > 1568 {
                    assert!(
                        _start <= 1568u64 && _end >= 1572u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1568u64) as usize;
                    let end =
                        (_end.saturating_sub(1568u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1588 && _end > 1584 {
                    assert!(
                        _start <= 1584u64 && _end >= 1588u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1584u64) as usize;
                    let end =
                        (_end.saturating_sub(1584u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1604 && _end > 1600 {
                    assert!(
                        _start <= 1600u64 && _end >= 1604u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1600u64) as usize;
                    let end =
                        (_end.saturating_sub(1600u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1620 && _end > 1616 {
                    assert!(
                        _start <= 1616u64 && _end >= 1620u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1616u64) as usize;
                    let end =
                        (_end.saturating_sub(1616u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1636 && _end > 1632 {
                    assert!(
                        _start <= 1632u64 && _end >= 1636u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1632u64) as usize;
                    let end =
                        (_end.saturating_sub(1632u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1652 && _end > 1648 {
                    assert!(
                        _start <= 1648u64 && _end >= 1652u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1648u64) as usize;
                    let end =
                        (_end.saturating_sub(1648u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1572 && _end > 1568 {
                    let offset = 1568u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1568u64) as usize;
                    let end =
                        (_end.saturating_sub(1568u64) as usize).min(start + 4);
                    self.write_radio_dapn(0, offset, &_buf[start..end])?;
                }
                if _start < 1588 && _end > 1584 {
                    let offset = 1584u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1584u64) as usize;
                    let end =
                        (_end.saturating_sub(1584u64) as usize).min(start + 4);
                    self.write_radio_dapn(1, offset, &_buf[start..end])?;
                }
                if _start < 1604 && _end > 1600 {
                    let offset = 1600u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1600u64) as usize;
                    let end =
                        (_end.saturating_sub(1600u64) as usize).min(start + 4);
                    self.write_radio_dapn(2, offset, &_buf[start..end])?;
                }
                if _start < 1620 && _end > 1616 {
                    let offset = 1616u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1616u64) as usize;
                    let end =
                        (_end.saturating_sub(1616u64) as usize).min(start + 4);
                    self.write_radio_dapn(3, offset, &_buf[start..end])?;
                }
                if _start < 1636 && _end > 1632 {
                    let offset = 1632u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1632u64) as usize;
                    let end =
                        (_end.saturating_sub(1632u64) as usize).min(start + 4);
                    self.write_radio_dapn(4, offset, &_buf[start..end])?;
                }
                if _start < 1652 && _end > 1648 {
                    let offset = 1648u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1648u64) as usize;
                    let end =
                        (_end.saturating_sub(1648u64) as usize).min(start + 4);
                    self.write_radio_dapn(5, offset, &_buf[start..end])?;
                }
                if _start < 1668 && _end > 1664 {
                    let offset = 1664u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1664u64) as usize;
                    let end =
                        (_end.saturating_sub(1664u64) as usize).min(start + 4);
                    self.write_radio_dapn(6, offset, &_buf[start..end])?;
                }
                if _start < 1684 && _end > 1680 {
                    let offset = 1680u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1680u64) as usize;
                    let end =
                        (_end.saturating_sub(1680u64) as usize).min(start + 4);
                    self.write_radio_dapn(7, offset, &_buf[start..end])?;
                }
                if _start < 1604 && _end > 1600 {
                    let offset = 1600u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1600u64) as usize;
                    let end =
                        (_end.saturating_sub(1600u64) as usize).min(start + 4);
                    self.write_radio_dacnf(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1828..=1847, 1829..=1848) => {
                if _start < 1832 && _end > 1828 {
                    assert!(
                        _start <= 1828u64 && _end >= 1832u64,
                        "partial write for RADIO OVERRIDE0 not implemented",
                    );
                    let start = _start.saturating_sub(1828u64) as usize;
                    let end =
                        (_end.saturating_sub(1828u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_override0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1836 && _end > 1832 {
                    assert!(
                        _start <= 1832u64 && _end >= 1836u64,
                        "partial write for RADIO OVERRIDE1 not implemented",
                    );
                    let start = _start.saturating_sub(1832u64) as usize;
                    let end =
                        (_end.saturating_sub(1832u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_override1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1840 && _end > 1836 {
                    assert!(
                        _start <= 1836u64 && _end >= 1840u64,
                        "partial write for RADIO OVERRIDE2 not implemented",
                    );
                    let start = _start.saturating_sub(1836u64) as usize;
                    let end =
                        (_end.saturating_sub(1836u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_override2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1844 && _end > 1840 {
                    assert!(
                        _start <= 1840u64 && _end >= 1844u64,
                        "partial write for RADIO OVERRIDE3 not implemented",
                    );
                    let start = _start.saturating_sub(1840u64) as usize;
                    let end =
                        (_end.saturating_sub(1840u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_override3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1848 && _end > 1844 {
                    let offset = 1844u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1844u64) as usize;
                    let end =
                        (_end.saturating_sub(1844u64) as usize).min(start + 4);
                    self.write_radio_override4(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_radio_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40001000 {
    fn read_radio_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_shorts_ready_start()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_shorts_end_disable()?)
                << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_radio_shorts_disabled_txen()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_radio_shorts_disabled_rxen()?,
        ) << 3u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_radio_shorts_address_rssistart()?,
        ) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_shorts_end_start()?)
                << 5u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_radio_shorts_address_bcstart()?,
        ) << 6u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_radio_shorts_disabled_rssistop()?,
        ) << 8u32;
        Ok(_value)
    }
    fn write_radio_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_ready_start((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_end_disable((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_disabled_txen((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_disabled_rxen((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_address_rssistart(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_end_start((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_radio_shorts_address_bcstart(
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_disabled_rssistop(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_radio_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_ready()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_address()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_payload()?)
                << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_intenset_end()?)
            << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_disabled()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_devmatch()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_devmiss()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_rssiend()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_bcmatch()?)
                << 10u32;
        Ok(_value)
    }
    fn write_radio_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_address((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_payload((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_end((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_disabled((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_devmatch((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_devmiss((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_rssiend((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_bcmatch((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_ready()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_address()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_payload()?)
                << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_intenclr_end()?)
            << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_disabled()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_devmatch()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_devmiss()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_rssiend()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_bcmatch()?)
                << 10u32;
        Ok(_value)
    }
    fn write_radio_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_address((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_payload((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_end((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_disabled((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_devmatch((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_devmiss((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_rssiend((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_bcmatch((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_crcstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crcstatus_crcstatus()?)
                << 0u32;
        Ok(_value)
    }
    fn read_radio_rxmatch(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxmatch_rxmatch()?)
                << 0u32;
        Ok(_value)
    }
    fn read_radio_rxcrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxcrc_rxcrc()?) << 0u32;
        Ok(_value)
    }
    fn read_radio_dai(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dai_dai()?) << 0u32;
        Ok(_value)
    }
    fn read_radio_frequency(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_frequency_frequency()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_frequency(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_frequency_frequency((_value[_i] >> 0) & 127u8)?;
        }
        Ok(())
    }
    fn read_radio_txpower(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_txpower_txpower()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_txpower(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_txpower_txpower((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_radio_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_mode_mode()?) << 0u32;
        Ok(_value)
    }
    fn write_radio_mode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_mode_mode((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_radio_pcnf0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_pcnf0_lflen()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_pcnf0_s0len()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf0_s1len()?)
            << 16u32;
        Ok(_value)
    }
    fn write_radio_pcnf0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf0_lflen((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf0_s0len((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf0_s1len((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
    fn read_radio_pcnf1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_maxlen()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_statlen()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_balen()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_endian()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_whiteen()?)
            << 25u32;
        Ok(_value)
    }
    fn write_radio_pcnf1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_maxlen((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_statlen((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_balen((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_endian((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_whiteen((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_prefix0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_prefix0_ap0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_prefix0_ap1()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_prefix0_ap2()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_prefix0_ap3()?)
            << 24u32;
        Ok(_value)
    }
    fn write_radio_prefix0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix0_ap0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix0_ap1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix0_ap2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix0_ap3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_radio_prefix1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_prefix1_ap4()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_prefix1_ap5()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_prefix1_ap6()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_prefix1_ap7()?)
            << 24u32;
        Ok(_value)
    }
    fn write_radio_prefix1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix1_ap4((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix1_ap5((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix1_ap6((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix1_ap7((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_radio_txaddress(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_txaddress_txaddress()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_txaddress(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_txaddress_txaddress((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_radio_rxaddresses(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr3()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr4()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr5()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr6()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr7()?)
                << 7u32;
        Ok(_value)
    }
    fn write_radio_rxaddresses(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr7((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_crccnf(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crccnf_len()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crccnf_skipaddr()?)
                << 8u32;
        Ok(_value)
    }
    fn write_radio_crccnf(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_crccnf_len((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_crccnf_skipaddr((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_crcpoly(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crcpoly_crcpoly()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_crcpoly(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_radio_crcpoly_crcpoly(_value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_radio_crcinit(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crcinit_crcinit()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_crcinit(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_radio_crcinit_crcinit(_value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_radio_test(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_test_constcarrier()?)
                << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_test_plllock()?)
            << 1u32;
        Ok(_value)
    }
    fn write_radio_test(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_test_constcarrier((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_test_plllock((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_tifs(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_tifs_tifs()?) << 0u32;
        Ok(_value)
    }
    fn write_radio_tifs(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_tifs_tifs((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_radio_rssisample(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_radio_rssisample_rssisample()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_radio_state(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_state_state()?) << 0u32;
        Ok(_value)
    }
    fn read_radio_datawhiteiv(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_radio_datawhiteiv_datawhiteiv()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_radio_datawhiteiv(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_radio_datawhiteiv_datawhiteiv(
                (_value[_i] >> 0) & 127u8,
            )?;
        }
        Ok(())
    }
    fn read_radio_dapn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dapn_dap(_dim)?)
            << 0u32;
        Ok(_value)
    }
    fn write_radio_dapn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_radio_dapn_dap(_dim, _value)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_radio_dacnf(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena7()?) << 7u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd0()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd1()?)
            << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd2()?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd3()?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd4()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd5()?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd6()?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd7()?)
            << 15u32;
        Ok(_value)
    }
    fn write_radio_dacnf(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd7((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_override4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_override4_override4()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_override4_enable()?)
                << 31u32;
        Ok(_value)
    }
    fn write_radio_override4(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 3 + 1) - _start) as usize] & 15u8)
                as u32)
                << (0 + (3 * 8));
            self.0
                .lock()
                .unwrap()
                .write_radio_override4_override4(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_override4_enable((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_radio_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40002000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40002000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073750016;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => return Err(MemError::ReadViolation),
            (28..=31, 29..=32) => return Err(MemError::ReadViolation),
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_events_cts()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_events_ncts()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_events_rxdrdy()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (284..=287, 285..=288) => {
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_events_txdrdy()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (292..=295, 293..=296) => {
                if _start < 296 && _end > 292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_events_error()?
                        .to_ne_bytes();
                    if _start <= 292 && _end > 292 {
                        _buf[(292 - _start) as usize] = _value[0];
                    }
                    if _start <= 293 && _end > 293 {
                        _buf[(293 - _start) as usize] = _value[1];
                    }
                    if _start <= 294 && _end > 294 {
                        _buf[(294 - _start) as usize] = _value[2];
                    }
                    if _start <= 295 && _end > 295 {
                        _buf[(295 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (324..=327, 325..=328) => {
                if _start < 328 && _end > 324 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_events_rxto()?
                        .to_ne_bytes();
                    if _start <= 324 && _end > 324 {
                        _buf[(324 - _start) as usize] = _value[0];
                    }
                    if _start <= 325 && _end > 325 {
                        _buf[(325 - _start) as usize] = _value[1];
                    }
                    if _start <= 326 && _end > 326 {
                        _buf[(326 - _start) as usize] = _value[2];
                    }
                    if _start <= 327 && _end > 327 {
                        _buf[(327 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_uart0_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_uart0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_uart0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1152..=1155, 1153..=1156) => {
                if _start < 1156 && _end > 1152 {
                    let _value = self.read_uart0_errorsrc()?.to_ne_bytes();
                    if _start <= 1152 && _end > 1152 {
                        _buf[(1152 - _start) as usize] = _value[0];
                    }
                    if _start <= 1153 && _end > 1153 {
                        _buf[(1153 - _start) as usize] = _value[1];
                    }
                    if _start <= 1154 && _end > 1154 {
                        _buf[(1154 - _start) as usize] = _value[2];
                    }
                    if _start <= 1155 && _end > 1155 {
                        _buf[(1155 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_uart0_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1292 && _end > 1288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_pselrts()?
                        .to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_pseltxd()?
                        .to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_pselcts()?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_pselrxd()?
                        .to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_uart0_rxd()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uart0_baudrate()?
                        .to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1388..=1391, 1389..=1392) => {
                if _start < 1392 && _end > 1388 {
                    let _value = self.read_uart0_config()?.to_ne_bytes();
                    if _start <= 1388 && _end > 1388 {
                        _buf[(1388 - _start) as usize] = _value[0];
                    }
                    if _start <= 1389 && _end > 1389 {
                        _buf[(1389 - _start) as usize] = _value[1];
                    }
                    if _start <= 1390 && _end > 1390 {
                        _buf[(1390 - _start) as usize] = _value[2];
                    }
                    if _start <= 1391 && _end > 1391 {
                        _buf[(1391 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_uart0_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073750016;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for UART0 TASKS_STARTRX not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_tasks_startrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for UART0 TASKS_STOPRX not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_tasks_stoprx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8u64 && _end >= 12u64,
                        "partial write for UART0 TASKS_STARTTX not implemented",
                    );
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_tasks_starttx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12u64 && _end >= 16u64,
                        "partial write for UART0 TASKS_STOPTX not implemented",
                    );
                    let start = _start.saturating_sub(12u64) as usize;
                    let end =
                        (_end.saturating_sub(12u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_tasks_stoptx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (28..=31, 29..=32) => {
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28u64 && _end >= 32u64,
                        "partial write for UART0 TASKS_SUSPEND not implemented",
                    );
                    let start = _start.saturating_sub(28u64) as usize;
                    let end =
                        (_end.saturating_sub(28u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_tasks_suspend(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for UART0 EVENTS_CTS not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_events_cts(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260u64 && _end >= 264u64,
                        "partial write for UART0 EVENTS_NCTS not implemented",
                    );
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_events_ncts(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264u64 && _end >= 268u64,
                        "partial write for UART0 EVENTS_RXDRDY not implemented",
                    );
                    let start = _start.saturating_sub(264u64) as usize;
                    let end =
                        (_end.saturating_sub(264u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_events_rxdrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (284..=287, 285..=288) => {
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284u64 && _end >= 288u64,
                        "partial write for UART0 EVENTS_TXDRDY not implemented",
                    );
                    let start = _start.saturating_sub(284u64) as usize;
                    let end =
                        (_end.saturating_sub(284u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_events_txdrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (292..=295, 293..=296) => {
                if _start < 296 && _end > 292 {
                    assert!(
                        _start <= 292u64 && _end >= 296u64,
                        "partial write for UART0 EVENTS_ERROR not implemented",
                    );
                    let start = _start.saturating_sub(292u64) as usize;
                    let end =
                        (_end.saturating_sub(292u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_events_error(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (324..=327, 325..=328) => {
                if _start < 328 && _end > 324 {
                    assert!(
                        _start <= 324u64 && _end >= 328u64,
                        "partial write for UART0 EVENTS_RXTO not implemented",
                    );
                    let start = _start.saturating_sub(324u64) as usize;
                    let end =
                        (_end.saturating_sub(324u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_events_rxto(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_uart0_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_uart0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_uart0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1152..=1155, 1153..=1156) => {
                if _start < 1156 && _end > 1152 {
                    let offset = 1152u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1152u64) as usize;
                    let end =
                        (_end.saturating_sub(1152u64) as usize).min(start + 4);
                    self.write_uart0_errorsrc(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_uart0_enable(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1292 && _end > 1288 {
                    assert!(
                        _start <= 1288u64 && _end >= 1292u64,
                        "partial write for UART0 PSELRTS not implemented",
                    );
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_pselrts(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    assert!(
                        _start <= 1292u64 && _end >= 1296u64,
                        "partial write for UART0 PSELTXD not implemented",
                    );
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_pseltxd(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296u64 && _end >= 1300u64,
                        "partial write for UART0 PSELCTS not implemented",
                    );
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_pselcts(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    assert!(
                        _start <= 1300u64 && _end >= 1304u64,
                        "partial write for UART0 PSELRXD not implemented",
                    );
                    let start = _start.saturating_sub(1300u64) as usize;
                    let end =
                        (_end.saturating_sub(1300u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_pselrxd(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1312 && _end > 1308 {
                    let offset = 1308u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1308u64) as usize;
                    let end =
                        (_end.saturating_sub(1308u64) as usize).min(start + 4);
                    self.write_uart0_txd(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    assert!(
                        _start <= 1316u64 && _end >= 1320u64,
                        "partial write for UART0 BAUDRATE not implemented",
                    );
                    let start = _start.saturating_sub(1316u64) as usize;
                    let end =
                        (_end.saturating_sub(1316u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_baudrate(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1388..=1391, 1389..=1392) => {
                if _start < 1392 && _end > 1388 {
                    let offset = 1388u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1388u64) as usize;
                    let end =
                        (_end.saturating_sub(1388u64) as usize).min(start + 4);
                    self.write_uart0_config(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_uart0_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40002000 {
    fn read_uart0_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_shorts_cts_startrx()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_shorts_ncts_stoprx()?)
                << 4u32;
        Ok(_value)
    }
    fn write_uart0_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_shorts_cts_startrx((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_shorts_ncts_stoprx((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_uart0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_uart0_intenset_cts()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_uart0_intenset_ncts()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_intenset_rxdrdy()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_intenset_txdrdy()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_intenset_error()?)
                << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_uart0_intenset_rxto()?)
            << 17u32;
        Ok(_value)
    }
    fn write_uart0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenset_cts((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenset_ncts((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenset_rxdrdy((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenset_txdrdy((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenset_error((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenset_rxto((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_uart0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_uart0_intenclr_cts()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_uart0_intenclr_ncts()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_intenclr_rxdrdy()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_intenclr_txdrdy()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_intenclr_error()?)
                << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_uart0_intenclr_rxto()?)
            << 17u32;
        Ok(_value)
    }
    fn write_uart0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenclr_cts((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenclr_ncts((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenclr_rxdrdy((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenclr_txdrdy((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenclr_error((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_intenclr_rxto((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_uart0_errorsrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_errorsrc_overrun()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_errorsrc_parity()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_errorsrc_framing()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_errorsrc_break()?)
                << 3u32;
        Ok(_value)
    }
    fn write_uart0_errorsrc(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_errorsrc_overrun((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_errorsrc_parity((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_errorsrc_framing((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_errorsrc_break((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_uart0_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_uart0_enable_enable()?)
            << 0u32;
        Ok(_value)
    }
    fn write_uart0_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_enable_enable((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_uart0_rxd(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_rxd_rxd()?) << 0u32;
        Ok(_value)
    }
    fn write_uart0_txd(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_txd_txd((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_uart0_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_config_hwfc()?) << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_uart0_config_parity()?)
            << 1u32;
        Ok(_value)
    }
    fn write_uart0_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_config_hwfc((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_config_parity((_value[_i] >> 1) & 7u8)?;
        }
        Ok(())
    }
    fn read_uart0_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_uart0_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40003000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40003000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073754112;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => return Err(MemError::ReadViolation),
            (8..=11, 9..=12) => return Err(MemError::ReadViolation),
            (20..=23, 21..=24) => return Err(MemError::ReadViolation),
            (28..=35, 29..=36) => return Err(MemError::ReadViolation),
            (260..=267, 261..=268) => {
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spi0twi0_events_ready()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twi0_events_stopped()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (284..=287, 285..=288) => {
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twi0_events_txdsent()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (292..=295, 293..=296) => {
                if _start < 296 && _end > 292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twi0_events_error()?
                        .to_ne_bytes();
                    if _start <= 292 && _end > 292 {
                        _buf[(292 - _start) as usize] = _value[0];
                    }
                    if _start <= 293 && _end > 293 {
                        _buf[(293 - _start) as usize] = _value[1];
                    }
                    if _start <= 294 && _end > 294 {
                        _buf[(294 - _start) as usize] = _value[2];
                    }
                    if _start <= 295 && _end > 295 {
                        _buf[(295 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twi0_events_bb()?
                        .to_ne_bytes();
                    if _start <= 312 && _end > 312 {
                        _buf[(312 - _start) as usize] = _value[0];
                    }
                    if _start <= 313 && _end > 313 {
                        _buf[(313 - _start) as usize] = _value[1];
                    }
                    if _start <= 314 && _end > 314 {
                        _buf[(314 - _start) as usize] = _value[2];
                    }
                    if _start <= 315 && _end > 315 {
                        _buf[(315 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (328..=331, 329..=332) => {
                if _start < 332 && _end > 328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twi0_events_suspended()?
                        .to_ne_bytes();
                    if _start <= 328 && _end > 328 {
                        _buf[(328 - _start) as usize] = _value[0];
                    }
                    if _start <= 329 && _end > 329 {
                        _buf[(329 - _start) as usize] = _value[1];
                    }
                    if _start <= 330 && _end > 330 {
                        _buf[(330 - _start) as usize] = _value[2];
                    }
                    if _start <= 331 && _end > 331 {
                        _buf[(331 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_twi0_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_spi0twi0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_spi0twi0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1220..=1223, 1221..=1224) => {
                if _start < 1224 && _end > 1220 {
                    let _value = self.read_twi0_errorsrc()?.to_ne_bytes();
                    if _start <= 1220 && _end > 1220 {
                        _buf[(1220 - _start) as usize] = _value[0];
                    }
                    if _start <= 1221 && _end > 1221 {
                        _buf[(1221 - _start) as usize] = _value[1];
                    }
                    if _start <= 1222 && _end > 1222 {
                        _buf[(1222 - _start) as usize] = _value[2];
                    }
                    if _start <= 1223 && _end > 1223 {
                        _buf[(1223 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_spi0twi0_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1288..=1299, 1289..=1300) => {
                if _start < 1292 && _end > 1288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spi0twi0_pselsck()?
                        .to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spi0twi0_pselmosi()?
                        .to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spi0_pselmiso()?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1304..=1311, 1305..=1312) => {
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_spi0twi0_rxd()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_spi0twi0_txd()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spi0twi0_frequency()?
                        .to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1364..=1367, 1365..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let _value = self.read_spi0_config()?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1416..=1419, 1417..=1420) => {
                if _start < 1420 && _end > 1416 {
                    let _value = self.read_twi0_address()?.to_ne_bytes();
                    if _start <= 1416 && _end > 1416 {
                        _buf[(1416 - _start) as usize] = _value[0];
                    }
                    if _start <= 1417 && _end > 1417 {
                        _buf[(1417 - _start) as usize] = _value[1];
                    }
                    if _start <= 1418 && _end > 1418 {
                        _buf[(1418 - _start) as usize] = _value[2];
                    }
                    if _start <= 1419 && _end > 1419 {
                        _buf[(1419 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_spi0twi0_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073754112;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for TWI0 TASKS_STARTRX not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_tasks_startrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (8..=11, 9..=12) => {
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8u64 && _end >= 12u64,
                        "partial write for TWI0 TASKS_STARTTX not implemented",
                    );
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_tasks_starttx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (20..=23, 21..=24) => {
                if _start < 24 && _end > 20 {
                    assert!(
                        _start <= 20u64 && _end >= 24u64,
                        "partial write for TWI0 TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(20u64) as usize;
                    let end =
                        (_end.saturating_sub(20u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (28..=35, 29..=36) => {
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28u64 && _end >= 32u64,
                        "partial write for TWI0 TASKS_SUSPEND not implemented",
                    );
                    let start = _start.saturating_sub(28u64) as usize;
                    let end =
                        (_end.saturating_sub(28u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_tasks_suspend(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 36 && _end > 32 {
                    assert!(
                        _start <= 32u64 && _end >= 36u64,
                        "partial write for TWI0 TASKS_RESUME not implemented",
                    );
                    let start = _start.saturating_sub(32u64) as usize;
                    let end =
                        (_end.saturating_sub(32u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_tasks_resume(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (260..=267, 261..=268) => {
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264u64 && _end >= 268u64,
                        "partial write for SPI0 EVENTS_READY not implemented",
                    );
                    let start = _start.saturating_sub(264u64) as usize;
                    let end =
                        (_end.saturating_sub(264u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spi0twi0_events_ready(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260u64 && _end >= 264u64,
                        "partial write for TWI0 EVENTS_STOPPED not implemented",
                    );
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_events_stopped(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (284..=287, 285..=288) => {
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284u64 && _end >= 288u64,
                        "partial write for TWI0 EVENTS_TXDSENT not implemented",
                    );
                    let start = _start.saturating_sub(284u64) as usize;
                    let end =
                        (_end.saturating_sub(284u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_events_txdsent(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (292..=295, 293..=296) => {
                if _start < 296 && _end > 292 {
                    assert!(
                        _start <= 292u64 && _end >= 296u64,
                        "partial write for TWI0 EVENTS_ERROR not implemented",
                    );
                    let start = _start.saturating_sub(292u64) as usize;
                    let end =
                        (_end.saturating_sub(292u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_events_error(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    assert!(
                        _start <= 312u64 && _end >= 316u64,
                        "partial write for TWI0 EVENTS_BB not implemented",
                    );
                    let start = _start.saturating_sub(312u64) as usize;
                    let end =
                        (_end.saturating_sub(312u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_events_bb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (328..=331, 329..=332) => {
                if _start < 332 && _end > 328 {
                    assert ! (_start <= 328u64 && _end >= 332u64 , "partial write for TWI0 EVENTS_SUSPENDED not implemented" ,);
                    let start = _start.saturating_sub(328u64) as usize;
                    let end =
                        (_end.saturating_sub(328u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_events_suspended(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_twi0_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_spi0twi0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_spi0twi0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1220..=1223, 1221..=1224) => {
                if _start < 1224 && _end > 1220 {
                    let offset = 1220u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1220u64) as usize;
                    let end =
                        (_end.saturating_sub(1220u64) as usize).min(start + 4);
                    self.write_twi0_errorsrc(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_spi0twi0_enable(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1288..=1299, 1289..=1300) => {
                if _start < 1292 && _end > 1288 {
                    assert!(
                        _start <= 1288u64 && _end >= 1292u64,
                        "partial write for SPI0 PSELSCK not implemented",
                    );
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spi0twi0_pselsck(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    assert!(
                        _start <= 1292u64 && _end >= 1296u64,
                        "partial write for SPI0 PSELMOSI not implemented",
                    );
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spi0twi0_pselmosi(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296u64 && _end >= 1300u64,
                        "partial write for SPI0 PSELMISO not implemented",
                    );
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spi0_pselmiso(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1304..=1311, 1305..=1312) => {
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1312 && _end > 1308 {
                    let offset = 1308u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1308u64) as usize;
                    let end =
                        (_end.saturating_sub(1308u64) as usize).min(start + 4);
                    self.write_spi0twi0_txd(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    assert!(
                        _start <= 1316u64 && _end >= 1320u64,
                        "partial write for SPI0 FREQUENCY not implemented",
                    );
                    let start = _start.saturating_sub(1316u64) as usize;
                    let end =
                        (_end.saturating_sub(1316u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spi0twi0_frequency(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1364..=1367, 1365..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let offset = 1364u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1364u64) as usize;
                    let end =
                        (_end.saturating_sub(1364u64) as usize).min(start + 4);
                    self.write_spi0_config(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1416..=1419, 1417..=1420) => {
                if _start < 1420 && _end > 1416 {
                    let offset = 1416u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1416u64) as usize;
                    let end =
                        (_end.saturating_sub(1416u64) as usize).min(start + 4);
                    self.write_twi0_address(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_spi0twi0_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40003000 {
    fn read_spi0twi0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenset_ready()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenset_stopped()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenset_txdsent()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenset_error()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenset_bb()?)
                << 14u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_spi0twi0_intenset_suspended()?,
        ) << 18u32;
        Ok(_value)
    }
    fn write_spi0twi0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenset_ready((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenset_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenset_txdsent((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenset_error((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenset_bb((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0.lock().unwrap().write_spi0twi0_intenset_suspended(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_spi0twi0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenclr_ready()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenclr_stopped()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenclr_txdsent()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenclr_error()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_intenclr_bb()?)
                << 14u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_spi0twi0_intenclr_suspended()?,
        ) << 18u32;
        Ok(_value)
    }
    fn write_spi0twi0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenclr_ready((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenclr_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenclr_txdsent((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenclr_error((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_intenclr_bb((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0.lock().unwrap().write_spi0twi0_intenclr_suspended(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_spi0twi0_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_enable_enable()?)
                << 0u32;
        Ok(_value)
    }
    fn write_spi0twi0_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_enable_enable((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_spi0twi0_rxd(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_rxd_rxd()?) << 0u32;
        Ok(_value)
    }
    fn read_spi0twi0_txd(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_txd_txd()?) << 0u32;
        Ok(_value)
    }
    fn write_spi0twi0_txd(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_txd_txd((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_spi0_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0_config_order()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0_config_cpha()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0_config_cpol()?) << 2u32;
        Ok(_value)
    }
    fn write_spi0_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0_config_order((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0_config_cpha((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0_config_cpol((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spi0twi0_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_power_power()?)
                << 0u32;
        Ok(_value)
    }
    fn write_spi0twi0_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_twi0_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_twi0_shorts_bb_suspend()?)
                << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_twi0_shorts_bb_stop()?)
            << 1u32;
        Ok(_value)
    }
    fn write_twi0_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twi0_shorts_bb_suspend((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twi0_shorts_bb_stop((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_twi0_errorsrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_twi0_errorsrc_overrun()?)
                << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_twi0_errorsrc_anack()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_twi0_errorsrc_dnack()?)
            << 2u32;
        Ok(_value)
    }
    fn write_twi0_errorsrc(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twi0_errorsrc_overrun((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twi0_errorsrc_anack((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twi0_errorsrc_dnack((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_twi0_address(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_twi0_address_address()?)
                << 0u32;
        Ok(_value)
    }
    fn write_twi0_address(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twi0_address_address((_value[_i] >> 0) & 127u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40004000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40004000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073758208;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (36..=43, 37..=44) => return Err(MemError::ReadViolation),
            (260..=263, 261..=264) => {
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_events_end()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_events_endrx()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_events_acquired()?
                        .to_ne_bytes();
                    if _start <= 296 && _end > 296 {
                        _buf[(296 - _start) as usize] = _value[0];
                    }
                    if _start <= 297 && _end > 297 {
                        _buf[(297 - _start) as usize] = _value[1];
                    }
                    if _start <= 298 && _end > 298 {
                        _buf[(298 - _start) as usize] = _value[2];
                    }
                    if _start <= 299 && _end > 299 {
                        _buf[(299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_spis1_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_spis1_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_spis1_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_spis1_semstat()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1088..=1091, 1089..=1092) => {
                if _start < 1092 && _end > 1088 {
                    let _value = self.read_spis1_status()?.to_ne_bytes();
                    if _start <= 1088 && _end > 1088 {
                        _buf[(1088 - _start) as usize] = _value[0];
                    }
                    if _start <= 1089 && _end > 1089 {
                        _buf[(1089 - _start) as usize] = _value[1];
                    }
                    if _start <= 1090 && _end > 1090 {
                        _buf[(1090 - _start) as usize] = _value[2];
                    }
                    if _start <= 1091 && _end > 1091 {
                        _buf[(1091 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_spis1_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1288..=1303, 1289..=1304) => {
                if _start < 1292 && _end > 1288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_pselsck()?
                        .to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_pselmiso()?
                        .to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_pselmosi()?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_pselcsn()?
                        .to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1332..=1343, 1333..=1344) => {
                if _start < 1336 && _end > 1332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_rxdptr()?
                        .to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _value = self.read_spis1_maxrx()?.to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _value = self.read_spis1_amountrx()?.to_ne_bytes();
                    if _start <= 1340 && _end > 1340 {
                        _buf[(1340 - _start) as usize] = _value[0];
                    }
                    if _start <= 1341 && _end > 1341 {
                        _buf[(1341 - _start) as usize] = _value[1];
                    }
                    if _start <= 1342 && _end > 1342 {
                        _buf[(1342 - _start) as usize] = _value[2];
                    }
                    if _start <= 1343 && _end > 1343 {
                        _buf[(1343 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1348..=1359, 1349..=1360) => {
                if _start < 1352 && _end > 1348 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis1_txdptr()?
                        .to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_spis1_maxtx()?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self.read_spis1_amounttx()?.to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1364..=1367, 1365..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let _value = self.read_spis1_config()?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _value = self.read_spis1_def()?.to_ne_bytes();
                    if _start <= 1372 && _end > 1372 {
                        _buf[(1372 - _start) as usize] = _value[0];
                    }
                    if _start <= 1373 && _end > 1373 {
                        _buf[(1373 - _start) as usize] = _value[1];
                    }
                    if _start <= 1374 && _end > 1374 {
                        _buf[(1374 - _start) as usize] = _value[2];
                    }
                    if _start <= 1375 && _end > 1375 {
                        _buf[(1375 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1472..=1475, 1473..=1476) => {
                if _start < 1476 && _end > 1472 {
                    let _value = self.read_spis1_orc()?.to_ne_bytes();
                    if _start <= 1472 && _end > 1472 {
                        _buf[(1472 - _start) as usize] = _value[0];
                    }
                    if _start <= 1473 && _end > 1473 {
                        _buf[(1473 - _start) as usize] = _value[1];
                    }
                    if _start <= 1474 && _end > 1474 {
                        _buf[(1474 - _start) as usize] = _value[2];
                    }
                    if _start <= 1475 && _end > 1475 {
                        _buf[(1475 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_spis1_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073758208;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (36..=43, 37..=44) => {
                if _start < 40 && _end > 36 {
                    assert!(
                        _start <= 36u64 && _end >= 40u64,
                        "partial write for SPIS1 TASKS_ACQUIRE not implemented",
                    );
                    let start = _start.saturating_sub(36u64) as usize;
                    let end =
                        (_end.saturating_sub(36u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_tasks_acquire(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 44 && _end > 40 {
                    assert!(
                        _start <= 40u64 && _end >= 44u64,
                        "partial write for SPIS1 TASKS_RELEASE not implemented",
                    );
                    let start = _start.saturating_sub(40u64) as usize;
                    let end =
                        (_end.saturating_sub(40u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_tasks_release(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (260..=263, 261..=264) => {
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260u64 && _end >= 264u64,
                        "partial write for SPIS1 EVENTS_END not implemented",
                    );
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_events_end(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272u64 && _end >= 276u64,
                        "partial write for SPIS1 EVENTS_ENDRX not implemented",
                    );
                    let start = _start.saturating_sub(272u64) as usize;
                    let end =
                        (_end.saturating_sub(272u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_events_endrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    assert ! (_start <= 296u64 && _end >= 300u64 , "partial write for SPIS1 EVENTS_ACQUIRED not implemented" ,);
                    let start = _start.saturating_sub(296u64) as usize;
                    let end =
                        (_end.saturating_sub(296u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_events_acquired(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_spis1_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_spis1_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_spis1_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => return Err(MemError::WriteViolation),
            (1088..=1091, 1089..=1092) => {
                if _start < 1092 && _end > 1088 {
                    let offset = 1088u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1088u64) as usize;
                    let end =
                        (_end.saturating_sub(1088u64) as usize).min(start + 4);
                    self.write_spis1_status(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_spis1_enable(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1288..=1303, 1289..=1304) => {
                if _start < 1292 && _end > 1288 {
                    assert!(
                        _start <= 1288u64 && _end >= 1292u64,
                        "partial write for SPIS1 PSELSCK not implemented",
                    );
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_pselsck(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    assert!(
                        _start <= 1292u64 && _end >= 1296u64,
                        "partial write for SPIS1 PSELMISO not implemented",
                    );
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_pselmiso(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296u64 && _end >= 1300u64,
                        "partial write for SPIS1 PSELMOSI not implemented",
                    );
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_pselmosi(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    assert!(
                        _start <= 1300u64 && _end >= 1304u64,
                        "partial write for SPIS1 PSELCSN not implemented",
                    );
                    let start = _start.saturating_sub(1300u64) as usize;
                    let end =
                        (_end.saturating_sub(1300u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_pselcsn(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1332..=1343, 1333..=1344) => {
                if _start < 1336 && _end > 1332 {
                    assert!(
                        _start <= 1332u64 && _end >= 1336u64,
                        "partial write for SPIS1 RXDPTR not implemented",
                    );
                    let start = _start.saturating_sub(1332u64) as usize;
                    let end =
                        (_end.saturating_sub(1332u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_rxdptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1340 && _end > 1336 {
                    let offset = 1336u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1336u64) as usize;
                    let end =
                        (_end.saturating_sub(1336u64) as usize).min(start + 4);
                    self.write_spis1_maxrx(offset, &_buf[start..end])?;
                }
                if _start < 1344 && _end > 1340 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1348..=1359, 1349..=1360) => {
                if _start < 1352 && _end > 1348 {
                    assert!(
                        _start <= 1348u64 && _end >= 1352u64,
                        "partial write for SPIS1 TXDPTR not implemented",
                    );
                    let start = _start.saturating_sub(1348u64) as usize;
                    let end =
                        (_end.saturating_sub(1348u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis1_txdptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1356 && _end > 1352 {
                    let offset = 1352u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1352u64) as usize;
                    let end =
                        (_end.saturating_sub(1352u64) as usize).min(start + 4);
                    self.write_spis1_maxtx(offset, &_buf[start..end])?;
                }
                if _start < 1360 && _end > 1356 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1364..=1367, 1365..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let offset = 1364u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1364u64) as usize;
                    let end =
                        (_end.saturating_sub(1364u64) as usize).min(start + 4);
                    self.write_spis1_config(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let offset = 1372u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1372u64) as usize;
                    let end =
                        (_end.saturating_sub(1372u64) as usize).min(start + 4);
                    self.write_spis1_def(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1472..=1475, 1473..=1476) => {
                if _start < 1476 && _end > 1472 {
                    let offset = 1472u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1472u64) as usize;
                    let end =
                        (_end.saturating_sub(1472u64) as usize).min(start + 4);
                    self.write_spis1_orc(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_spis1_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40004000 {
    fn read_spis1_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_shorts_end_acquire()?)
                << 2u32;
        Ok(_value)
    }
    fn write_spis1_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_shorts_end_acquire((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spis1_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_spis1_intenset_end()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_intenset_endrx()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_intenset_acquired()?)
                << 10u32;
        Ok(_value)
    }
    fn write_spis1_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_intenset_end((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_intenset_endrx((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_intenset_acquired((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spis1_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_spis1_intenclr_end()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_intenclr_endrx()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_intenclr_acquired()?)
                << 10u32;
        Ok(_value)
    }
    fn write_spis1_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_intenclr_end((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_intenclr_endrx((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_intenclr_acquired((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spis1_semstat(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_semstat_semstat()?)
                << 0u32;
        Ok(_value)
    }
    fn read_spis1_status(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_status_overread()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_status_overflow()?)
                << 1u32;
        Ok(_value)
    }
    fn write_spis1_status(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_status_overread((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_status_overflow((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spis1_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_spis1_enable_enable()?)
            << 0u32;
        Ok(_value)
    }
    fn write_spis1_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_enable_enable((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_spis1_maxrx(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_maxrx_maxrx()?) << 0u32;
        Ok(_value)
    }
    fn write_spis1_maxrx(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_maxrx_maxrx((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_spis1_amountrx(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_amountrx_amountrx()?)
                << 0u32;
        Ok(_value)
    }
    fn read_spis1_maxtx(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_maxtx_maxtx()?) << 0u32;
        Ok(_value)
    }
    fn write_spis1_maxtx(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_maxtx_maxtx((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_spis1_amounttx(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_amounttx_amounttx()?)
                << 0u32;
        Ok(_value)
    }
    fn read_spis1_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_spis1_config_order()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_config_cpha()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_config_cpol()?) << 2u32;
        Ok(_value)
    }
    fn write_spis1_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_config_order((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_config_cpha((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_config_cpol((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spis1_def(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_def_def()?) << 0u32;
        Ok(_value)
    }
    fn write_spis1_def(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_def_def((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_spis1_orc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_orc_orc()?) << 0u32;
        Ok(_value)
    }
    fn write_spis1_orc(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_orc_orc((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_spis1_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis1_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_spis1_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis1_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40006000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40006000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073766400;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => return Err(MemError::ReadViolation),
            (256..=271, 257..=272) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(0)?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(1)?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 292 && _end > 288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(2)?
                        .to_ne_bytes();
                    if _start <= 288 && _end > 288 {
                        _buf[(288 - _start) as usize] = _value[0];
                    }
                    if _start <= 289 && _end > 289 {
                        _buf[(289 - _start) as usize] = _value[1];
                    }
                    if _start <= 290 && _end > 290 {
                        _buf[(290 - _start) as usize] = _value[2];
                    }
                    if _start <= 291 && _end > 291 {
                        _buf[(291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 308 && _end > 304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(3)?
                        .to_ne_bytes();
                    if _start <= 304 && _end > 304 {
                        _buf[(304 - _start) as usize] = _value[0];
                    }
                    if _start <= 305 && _end > 305 {
                        _buf[(305 - _start) as usize] = _value[1];
                    }
                    if _start <= 306 && _end > 306 {
                        _buf[(306 - _start) as usize] = _value[2];
                    }
                    if _start <= 307 && _end > 307 {
                        _buf[(307 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (380..=383, 381..=384) => {
                if _start < 384 && _end > 380 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_port()?
                        .to_ne_bytes();
                    if _start <= 380 && _end > 380 {
                        _buf[(380 - _start) as usize] = _value[0];
                    }
                    if _start <= 381 && _end > 381 {
                        _buf[(381 - _start) as usize] = _value[1];
                    }
                    if _start <= 382 && _end > 382 {
                        _buf[(382 - _start) as usize] = _value[2];
                    }
                    if _start <= 383 && _end > 383 {
                        _buf[(383 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_gpiote_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_gpiote_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1311, 1297..=1312) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_gpiote_confign(0)?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_gpiote_confign(1)?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _value = self.read_gpiote_confign(2)?.to_ne_bytes();
                    if _start <= 1328 && _end > 1328 {
                        _buf[(1328 - _start) as usize] = _value[0];
                    }
                    if _start <= 1329 && _end > 1329 {
                        _buf[(1329 - _start) as usize] = _value[1];
                    }
                    if _start <= 1330 && _end > 1330 {
                        _buf[(1330 - _start) as usize] = _value[2];
                    }
                    if _start <= 1331 && _end > 1331 {
                        _buf[(1331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_gpiote_confign(3)?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_gpiote_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073766400;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    assert ! (_start <= 0u64 && _end >= 4u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert ! (_start <= 16u64 && _end >= 20u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(16u64) as usize;
                    let end =
                        (_end.saturating_sub(16u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 36 && _end > 32 {
                    assert ! (_start <= 32u64 && _end >= 36u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(32u64) as usize;
                    let end =
                        (_end.saturating_sub(32u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 52 && _end > 48 {
                    assert ! (_start <= 48u64 && _end >= 52u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(48u64) as usize;
                    let end =
                        (_end.saturating_sub(48u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=271, 257..=272) => {
                if _start < 260 && _end > 256 {
                    assert ! (_start <= 256u64 && _end >= 260u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert ! (_start <= 272u64 && _end >= 276u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(272u64) as usize;
                    let end =
                        (_end.saturating_sub(272u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 292 && _end > 288 {
                    assert ! (_start <= 288u64 && _end >= 292u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(288u64) as usize;
                    let end =
                        (_end.saturating_sub(288u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 308 && _end > 304 {
                    assert ! (_start <= 304u64 && _end >= 308u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(304u64) as usize;
                    let end =
                        (_end.saturating_sub(304u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (380..=383, 381..=384) => {
                if _start < 384 && _end > 380 {
                    assert!(
                        _start <= 380u64 && _end >= 384u64,
                        "partial write for GPIOTE EVENTS_PORT not implemented",
                    );
                    let start = _start.saturating_sub(380u64) as usize;
                    let end =
                        (_end.saturating_sub(380u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_port(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_gpiote_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_gpiote_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1311, 1297..=1312) => {
                if _start < 1300 && _end > 1296 {
                    let offset = 1296u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.write_gpiote_confign(0, offset, &_buf[start..end])?;
                }
                if _start < 1316 && _end > 1312 {
                    let offset = 1312u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1312u64) as usize;
                    let end =
                        (_end.saturating_sub(1312u64) as usize).min(start + 4);
                    self.write_gpiote_confign(1, offset, &_buf[start..end])?;
                }
                if _start < 1332 && _end > 1328 {
                    let offset = 1328u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1328u64) as usize;
                    let end =
                        (_end.saturating_sub(1328u64) as usize).min(start + 4);
                    self.write_gpiote_confign(2, offset, &_buf[start..end])?;
                }
                if _start < 1348 && _end > 1344 {
                    let offset = 1344u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1344u64) as usize;
                    let end =
                        (_end.saturating_sub(1344u64) as usize).min(start + 4);
                    self.write_gpiote_confign(3, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_gpiote_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40006000 {
    fn read_gpiote_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in0()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in1()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in2()?)
            << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in3()?)
            << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpiote_intenset_port()?)
                << 31u32;
        Ok(_value)
    }
    fn write_gpiote_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_port((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpiote_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in0()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in1()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in2()?)
            << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in3()?)
            << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpiote_intenclr_port()?)
                << 31u32;
        Ok(_value)
    }
    fn write_gpiote_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_port((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpiote_confign(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpiote_confign_mode(_dim)?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpiote_confign_psel(_dim)?)
                << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_gpiote_confign_polarity(_dim)?,
        ) << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_gpiote_confign_outinit(_dim)?,
        ) << 20u32;
        Ok(_value)
    }
    fn write_gpiote_confign(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_confign_mode(_dim, (_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_confign_psel(_dim, (_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_confign_polarity(_dim, (_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0.lock().unwrap().write_gpiote_confign_outinit(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_gpiote_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_power_power()?)
            << 0u32;
        Ok(_value)
    }
    fn write_gpiote_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40007000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40007000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073770496;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => return Err(MemError::ReadViolation),
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_adc_events_end()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_adc_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_adc_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_adc_busy()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_adc_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_adc_config()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_adc_result()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_adc_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073770496;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for ADC TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_adc_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for ADC TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_adc_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for ADC EVENTS_END not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_adc_events_end(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_adc_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_adc_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => return Err(MemError::WriteViolation),
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_adc_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_adc_config(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_adc_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40007000 {
    fn read_adc_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_intenset_end()?) << 0u32;
        Ok(_value)
    }
    fn write_adc_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_intenset_end((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_adc_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_intenclr_end()?) << 0u32;
        Ok(_value)
    }
    fn write_adc_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_intenclr_end((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_adc_busy(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_busy_busy()?) << 0u32;
        Ok(_value)
    }
    fn read_adc_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_enable_enable()?) << 0u32;
        Ok(_value)
    }
    fn write_adc_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_enable_enable((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_adc_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_config_res()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_config_inpsel()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_config_refsel()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_config_psel()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_config_extrefsel()?)
                << 16u32;
        Ok(_value)
    }
    fn write_adc_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_config_res((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_config_inpsel((_value[_i] >> 2) & 7u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_config_refsel((_value[_i] >> 5) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_config_psel((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_config_extrefsel((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_adc_result(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_result_result()?) << 0u32;
        Ok(_value)
    }
    fn read_adc_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_adc_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_adc_power(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_adc_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40008000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40008000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073774592;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => return Err(MemError::ReadViolation),
            (64..=79, 65..=80) => return Err(MemError::ReadViolation),
            (320..=335, 321..=336) => {
                if _start < 324 && _end > 320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_events_comparen(0)?
                        .to_ne_bytes();
                    if _start <= 320 && _end > 320 {
                        _buf[(320 - _start) as usize] = _value[0];
                    }
                    if _start <= 321 && _end > 321 {
                        _buf[(321 - _start) as usize] = _value[1];
                    }
                    if _start <= 322 && _end > 322 {
                        _buf[(322 - _start) as usize] = _value[2];
                    }
                    if _start <= 323 && _end > 323 {
                        _buf[(323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_events_comparen(1)?
                        .to_ne_bytes();
                    if _start <= 336 && _end > 336 {
                        _buf[(336 - _start) as usize] = _value[0];
                    }
                    if _start <= 337 && _end > 337 {
                        _buf[(337 - _start) as usize] = _value[1];
                    }
                    if _start <= 338 && _end > 338 {
                        _buf[(338 - _start) as usize] = _value[2];
                    }
                    if _start <= 339 && _end > 339 {
                        _buf[(339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 356 && _end > 352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_events_comparen(2)?
                        .to_ne_bytes();
                    if _start <= 352 && _end > 352 {
                        _buf[(352 - _start) as usize] = _value[0];
                    }
                    if _start <= 353 && _end > 353 {
                        _buf[(353 - _start) as usize] = _value[1];
                    }
                    if _start <= 354 && _end > 354 {
                        _buf[(354 - _start) as usize] = _value[2];
                    }
                    if _start <= 355 && _end > 355 {
                        _buf[(355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 372 && _end > 368 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_events_comparen(3)?
                        .to_ne_bytes();
                    if _start <= 368 && _end > 368 {
                        _buf[(368 - _start) as usize] = _value[0];
                    }
                    if _start <= 369 && _end > 369 {
                        _buf[(369 - _start) as usize] = _value[1];
                    }
                    if _start <= 370 && _end > 370 {
                        _buf[(370 - _start) as usize] = _value[2];
                    }
                    if _start <= 371 && _end > 371 {
                        _buf[(371 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_timer0_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_timer0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_timer0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_timer0_mode()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_timer0_bitmode()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_timer0_prescaler()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_ccn(0)?
                        .to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_ccn(1)?
                        .to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1380 && _end > 1376 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_ccn(2)?
                        .to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1396 && _end > 1392 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_ccn(3)?
                        .to_ne_bytes();
                    if _start <= 1392 && _end > 1392 {
                        _buf[(1392 - _start) as usize] = _value[0];
                    }
                    if _start <= 1393 && _end > 1393 {
                        _buf[(1393 - _start) as usize] = _value[1];
                    }
                    if _start <= 1394 && _end > 1394 {
                        _buf[(1394 - _start) as usize] = _value[2];
                    }
                    if _start <= 1395 && _end > 1395 {
                        _buf[(1395 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_timer0_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073774592;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for TIMER0 TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for TIMER0 TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8u64 && _end >= 12u64,
                        "partial write for TIMER0 TASKS_COUNT not implemented",
                    );
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_count(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12u64 && _end >= 16u64,
                        "partial write for TIMER0 TASKS_CLEAR not implemented",
                    );
                    let start = _start.saturating_sub(12u64) as usize;
                    let end =
                        (_end.saturating_sub(12u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_clear(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert ! (_start <= 16u64 && _end >= 20u64 , "partial write for TIMER0 TASKS_SHUTDOWN not implemented" ,);
                    let start = _start.saturating_sub(16u64) as usize;
                    let end =
                        (_end.saturating_sub(16u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_shutdown(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (64..=79, 65..=80) => {
                if _start < 68 && _end > 64 {
                    assert ! (_start <= 64u64 && _end >= 68u64 , "partial write for TIMER0 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(64u64) as usize;
                    let end =
                        (_end.saturating_sub(64u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_capturen(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 84 && _end > 80 {
                    assert ! (_start <= 80u64 && _end >= 84u64 , "partial write for TIMER0 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(80u64) as usize;
                    let end =
                        (_end.saturating_sub(80u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_capturen(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 100 && _end > 96 {
                    assert ! (_start <= 96u64 && _end >= 100u64 , "partial write for TIMER0 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(96u64) as usize;
                    let end =
                        (_end.saturating_sub(96u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_capturen(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 116 && _end > 112 {
                    assert ! (_start <= 112u64 && _end >= 116u64 , "partial write for TIMER0 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(112u64) as usize;
                    let end =
                        (_end.saturating_sub(112u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_capturen(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (320..=335, 321..=336) => {
                if _start < 324 && _end > 320 {
                    assert ! (_start <= 320u64 && _end >= 324u64 , "partial write for TIMER0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(320u64) as usize;
                    let end =
                        (_end.saturating_sub(320u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_events_comparen(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 340 && _end > 336 {
                    assert ! (_start <= 336u64 && _end >= 340u64 , "partial write for TIMER0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(336u64) as usize;
                    let end =
                        (_end.saturating_sub(336u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_events_comparen(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 356 && _end > 352 {
                    assert ! (_start <= 352u64 && _end >= 356u64 , "partial write for TIMER0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(352u64) as usize;
                    let end =
                        (_end.saturating_sub(352u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_events_comparen(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 372 && _end > 368 {
                    assert ! (_start <= 368u64 && _end >= 372u64 , "partial write for TIMER0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(368u64) as usize;
                    let end =
                        (_end.saturating_sub(368u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_events_comparen(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_timer0_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_timer0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_timer0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_timer0_mode(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = 1288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.write_timer0_bitmode(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let offset = 1296u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.write_timer0_prescaler(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    assert!(
                        _start <= 1344u64 && _end >= 1348u64,
                        "partial write for TIMER0 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1344u64) as usize;
                    let end =
                        (_end.saturating_sub(1344u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_ccn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1364 && _end > 1360 {
                    assert!(
                        _start <= 1360u64 && _end >= 1364u64,
                        "partial write for TIMER0 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1360u64) as usize;
                    let end =
                        (_end.saturating_sub(1360u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_ccn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1380 && _end > 1376 {
                    assert!(
                        _start <= 1376u64 && _end >= 1380u64,
                        "partial write for TIMER0 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1376u64) as usize;
                    let end =
                        (_end.saturating_sub(1376u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_ccn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1396 && _end > 1392 {
                    assert!(
                        _start <= 1392u64 && _end >= 1396u64,
                        "partial write for TIMER0 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1392u64) as usize;
                    let end =
                        (_end.saturating_sub(1392u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_ccn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_timer0_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40008000 {
    fn read_timer0_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare0_clear()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare1_clear()?,
        ) << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare2_clear()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare3_clear()?,
        ) << 3u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare0_stop()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare1_stop()?,
        ) << 9u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare2_stop()?,
        ) << 10u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare3_stop()?,
        ) << 11u32;
        Ok(_value)
    }
    fn write_timer0_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare0_clear(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare1_clear(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare2_clear(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare3_clear(
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare0_stop(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare1_stop(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare2_stop(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare3_stop(
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_timer0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenset_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenset_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenset_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenset_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_timer0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenset_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenset_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenset_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenset_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_timer0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenclr_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenclr_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenclr_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenclr_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_timer0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenclr_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenclr_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenclr_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenclr_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_timer0_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_mode_mode()?) << 0u32;
        Ok(_value)
    }
    fn write_timer0_mode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_mode_mode((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_timer0_bitmode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_bitmode_bitmode()?)
                << 0u32;
        Ok(_value)
    }
    fn write_timer0_bitmode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_bitmode_bitmode((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_timer0_prescaler(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_prescaler_prescaler()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_timer0_prescaler(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_prescaler_prescaler((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
    fn read_timer0_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_timer0_power_power()?)
            << 0u32;
        Ok(_value)
    }
    fn write_timer0_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000B000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000B000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073786880;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => return Err(MemError::ReadViolation),
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_tick()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_ovrflw()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (320..=335, 321..=336) => {
                if _start < 324 && _end > 320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_comparen(0)?
                        .to_ne_bytes();
                    if _start <= 320 && _end > 320 {
                        _buf[(320 - _start) as usize] = _value[0];
                    }
                    if _start <= 321 && _end > 321 {
                        _buf[(321 - _start) as usize] = _value[1];
                    }
                    if _start <= 322 && _end > 322 {
                        _buf[(322 - _start) as usize] = _value[2];
                    }
                    if _start <= 323 && _end > 323 {
                        _buf[(323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_comparen(1)?
                        .to_ne_bytes();
                    if _start <= 336 && _end > 336 {
                        _buf[(336 - _start) as usize] = _value[0];
                    }
                    if _start <= 337 && _end > 337 {
                        _buf[(337 - _start) as usize] = _value[1];
                    }
                    if _start <= 338 && _end > 338 {
                        _buf[(338 - _start) as usize] = _value[2];
                    }
                    if _start <= 339 && _end > 339 {
                        _buf[(339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 356 && _end > 352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_comparen(2)?
                        .to_ne_bytes();
                    if _start <= 352 && _end > 352 {
                        _buf[(352 - _start) as usize] = _value[0];
                    }
                    if _start <= 353 && _end > 353 {
                        _buf[(353 - _start) as usize] = _value[1];
                    }
                    if _start <= 354 && _end > 354 {
                        _buf[(354 - _start) as usize] = _value[2];
                    }
                    if _start <= 355 && _end > 355 {
                        _buf[(355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 372 && _end > 368 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_comparen(3)?
                        .to_ne_bytes();
                    if _start <= 368 && _end > 368 {
                        _buf[(368 - _start) as usize] = _value[0];
                    }
                    if _start <= 369 && _end > 369 {
                        _buf[(369 - _start) as usize] = _value[1];
                    }
                    if _start <= 370 && _end > 370 {
                        _buf[(370 - _start) as usize] = _value[2];
                    }
                    if _start <= 371 && _end > 371 {
                        _buf[(371 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_rtc0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_rtc0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (832..=843, 833..=844) => {
                if _start < 836 && _end > 832 {
                    let _value = self.read_rtc0_evten()?.to_ne_bytes();
                    if _start <= 832 && _end > 832 {
                        _buf[(832 - _start) as usize] = _value[0];
                    }
                    if _start <= 833 && _end > 833 {
                        _buf[(833 - _start) as usize] = _value[1];
                    }
                    if _start <= 834 && _end > 834 {
                        _buf[(834 - _start) as usize] = _value[2];
                    }
                    if _start <= 835 && _end > 835 {
                        _buf[(835 - _start) as usize] = _value[3];
                    }
                }
                if _start < 840 && _end > 836 {
                    let _value = self.read_rtc0_evtenset()?.to_ne_bytes();
                    if _start <= 836 && _end > 836 {
                        _buf[(836 - _start) as usize] = _value[0];
                    }
                    if _start <= 837 && _end > 837 {
                        _buf[(837 - _start) as usize] = _value[1];
                    }
                    if _start <= 838 && _end > 838 {
                        _buf[(838 - _start) as usize] = _value[2];
                    }
                    if _start <= 839 && _end > 839 {
                        _buf[(839 - _start) as usize] = _value[3];
                    }
                }
                if _start < 844 && _end > 840 {
                    let _value = self.read_rtc0_evtenclr()?.to_ne_bytes();
                    if _start <= 840 && _end > 840 {
                        _buf[(840 - _start) as usize] = _value[0];
                    }
                    if _start <= 841 && _end > 841 {
                        _buf[(841 - _start) as usize] = _value[1];
                    }
                    if _start <= 842 && _end > 842 {
                        _buf[(842 - _start) as usize] = _value[2];
                    }
                    if _start <= 843 && _end > 843 {
                        _buf[(843 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_rtc0_counter()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_rtc0_prescaler()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_rtc0_ccn(0)?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value = self.read_rtc0_ccn(1)?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1380 && _end > 1376 {
                    let _value = self.read_rtc0_ccn(2)?.to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1396 && _end > 1392 {
                    let _value = self.read_rtc0_ccn(3)?.to_ne_bytes();
                    if _start <= 1392 && _end > 1392 {
                        _buf[(1392 - _start) as usize] = _value[0];
                    }
                    if _start <= 1393 && _end > 1393 {
                        _buf[(1393 - _start) as usize] = _value[1];
                    }
                    if _start <= 1394 && _end > 1394 {
                        _buf[(1394 - _start) as usize] = _value[2];
                    }
                    if _start <= 1395 && _end > 1395 {
                        _buf[(1395 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_rtc0_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073786880;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for RTC0 TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for RTC0 TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8u64 && _end >= 12u64,
                        "partial write for RTC0 TASKS_CLEAR not implemented",
                    );
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_tasks_clear(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert ! (_start <= 12u64 && _end >= 16u64 , "partial write for RTC0 TASKS_TRIGOVRFLW not implemented" ,);
                    let start = _start.saturating_sub(12u64) as usize;
                    let end =
                        (_end.saturating_sub(12u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_tasks_trigovrflw(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for RTC0 EVENTS_TICK not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_tick(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260u64 && _end >= 264u64,
                        "partial write for RTC0 EVENTS_OVRFLW not implemented",
                    );
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_ovrflw(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (320..=335, 321..=336) => {
                if _start < 324 && _end > 320 {
                    assert ! (_start <= 320u64 && _end >= 324u64 , "partial write for RTC0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(320u64) as usize;
                    let end =
                        (_end.saturating_sub(320u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_comparen(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 340 && _end > 336 {
                    assert ! (_start <= 336u64 && _end >= 340u64 , "partial write for RTC0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(336u64) as usize;
                    let end =
                        (_end.saturating_sub(336u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_comparen(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 356 && _end > 352 {
                    assert ! (_start <= 352u64 && _end >= 356u64 , "partial write for RTC0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(352u64) as usize;
                    let end =
                        (_end.saturating_sub(352u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_comparen(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 372 && _end > 368 {
                    assert ! (_start <= 368u64 && _end >= 372u64 , "partial write for RTC0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(368u64) as usize;
                    let end =
                        (_end.saturating_sub(368u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_comparen(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_rtc0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_rtc0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (832..=843, 833..=844) => {
                if _start < 836 && _end > 832 {
                    let offset = 832u64.saturating_sub(_start);
                    let start = _start.saturating_sub(832u64) as usize;
                    let end =
                        (_end.saturating_sub(832u64) as usize).min(start + 4);
                    self.write_rtc0_evten(offset, &_buf[start..end])?;
                }
                if _start < 840 && _end > 836 {
                    let offset = 836u64.saturating_sub(_start);
                    let start = _start.saturating_sub(836u64) as usize;
                    let end =
                        (_end.saturating_sub(836u64) as usize).min(start + 4);
                    self.write_rtc0_evtenset(offset, &_buf[start..end])?;
                }
                if _start < 844 && _end > 840 {
                    let offset = 840u64.saturating_sub(_start);
                    let start = _start.saturating_sub(840u64) as usize;
                    let end =
                        (_end.saturating_sub(840u64) as usize).min(start + 4);
                    self.write_rtc0_evtenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1292 && _end > 1288 {
                    let offset = 1288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.write_rtc0_prescaler(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    let offset = 1344u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1344u64) as usize;
                    let end =
                        (_end.saturating_sub(1344u64) as usize).min(start + 4);
                    self.write_rtc0_ccn(0, offset, &_buf[start..end])?;
                }
                if _start < 1364 && _end > 1360 {
                    let offset = 1360u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1360u64) as usize;
                    let end =
                        (_end.saturating_sub(1360u64) as usize).min(start + 4);
                    self.write_rtc0_ccn(1, offset, &_buf[start..end])?;
                }
                if _start < 1380 && _end > 1376 {
                    let offset = 1376u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1376u64) as usize;
                    let end =
                        (_end.saturating_sub(1376u64) as usize).min(start + 4);
                    self.write_rtc0_ccn(2, offset, &_buf[start..end])?;
                }
                if _start < 1396 && _end > 1392 {
                    let offset = 1392u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1392u64) as usize;
                    let end =
                        (_end.saturating_sub(1392u64) as usize).min(start + 4);
                    self.write_rtc0_ccn(3, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_rtc0_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000B000 {
    fn read_rtc0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_intenset_tick()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_ovrflw()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_rtc0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_intenclr_tick()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_ovrflw()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_rtc0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_evten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evten_tick()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evten_ovrflw()?) << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evten_compare0()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evten_compare1()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evten_compare2()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evten_compare3()?)
            << 19u32;
        Ok(_value)
    }
    fn write_rtc0_evten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_evtenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evtenset_tick()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_ovrflw()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_rtc0_evtenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_evtenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_tick()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_ovrflw()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_rtc0_evtenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_counter(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_counter_counter()?)
                << 0u32;
        Ok(_value)
    }
    fn read_rtc0_prescaler(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_prescaler_prescaler()?)
                << 0u32;
        Ok(_value)
    }
    fn write_rtc0_prescaler(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 15u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_rtc0_prescaler_prescaler(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_rtc0_ccn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_ccn_compare(_dim)?)
                << 0u32;
        Ok(_value)
    }
    fn write_rtc0_ccn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0
                .lock()
                .unwrap()
                .write_rtc0_ccn_compare(_dim, _value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_rtc0_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_rtc0_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000C000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000C000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073790976;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => return Err(MemError::ReadViolation),
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_temp_events_datardy()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_temp_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_temp_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1288..=1291, 1289..=1292) => {
                if _start < 1292 && _end > 1288 {
                    let _value =
                        self.0.lock().unwrap().read_temp_temp()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_temp_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073790976;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for TEMP TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_temp_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for TEMP TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_temp_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for TEMP EVENTS_DATARDY not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_temp_events_datardy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_temp_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_temp_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1288..=1291, 1289..=1292) => return Err(MemError::WriteViolation),
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_temp_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000C000 {
    fn read_temp_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_temp_intenset_datardy()?)
                << 0u32;
        Ok(_value)
    }
    fn write_temp_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_intenset_datardy((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_temp_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_temp_intenclr_datardy()?)
                << 0u32;
        Ok(_value)
    }
    fn write_temp_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_intenclr_datardy((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_temp_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_temp_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000D000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000D000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073795072;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => return Err(MemError::ReadViolation),
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rng_events_valrdy()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_rng_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_rng_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_rng_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_rng_config()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_rng_value()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_rng_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073795072;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for RNG TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rng_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for RNG TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rng_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for RNG EVENTS_VALRDY not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rng_events_valrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_rng_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_rng_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_rng_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_rng_config(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_rng_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000D000 {
    fn read_rng_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rng_shorts_valrdy_stop()?)
                << 0u32;
        Ok(_value)
    }
    fn write_rng_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_shorts_valrdy_stop((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rng_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rng_intenset_valrdy()?)
            << 0u32;
        Ok(_value)
    }
    fn write_rng_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_intenset_valrdy((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rng_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rng_intenclr_valrdy()?)
            << 0u32;
        Ok(_value)
    }
    fn write_rng_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_intenclr_valrdy((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rng_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rng_config_dercen()?) << 0u32;
        Ok(_value)
    }
    fn write_rng_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_config_dercen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rng_value(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rng_value_value()?) << 0u32;
        Ok(_value)
    }
    fn read_rng_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rng_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_rng_power(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000E000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000E000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073799168;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => return Err(MemError::ReadViolation),
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ecb_events_endecb()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ecb_events_errorecb()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_ecb_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_ecb_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1287, 1285..=1288) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ecb_ecbdataptr()?
                        .to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_ecb_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073799168;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for ECB TASKS_STARTECB not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_tasks_startecb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for ECB TASKS_STOPECB not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_tasks_stopecb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for ECB EVENTS_ENDECB not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_events_endecb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260u64 && _end >= 264u64,
                        "partial write for ECB EVENTS_ERRORECB not implemented",
                    );
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_events_errorecb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_ecb_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_ecb_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1287, 1285..=1288) => {
                if _start < 1288 && _end > 1284 {
                    assert!(
                        _start <= 1284u64 && _end >= 1288u64,
                        "partial write for ECB ECBDATAPTR not implemented",
                    );
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_ecbdataptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_ecb_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000E000 {
    fn read_ecb_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_ecb_intenset_endecb()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ecb_intenset_errorecb()?)
                << 1u32;
        Ok(_value)
    }
    fn write_ecb_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_intenset_endecb((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_intenset_errorecb((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ecb_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_ecb_intenclr_endecb()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ecb_intenclr_errorecb()?)
                << 1u32;
        Ok(_value)
    }
    fn write_ecb_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_intenclr_endecb((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_intenclr_errorecb((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ecb_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ecb_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_ecb_power(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000F000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000F000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073803264;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => return Err(MemError::ReadViolation),
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_aarccm_events_end()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_aarccm_events_resolved()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_aarccm_events_notresolved()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_ccm_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_aarccm_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_aarccm_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_aarccm_status()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_aarccm_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_aarccm_nirk()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_aarccm_irkptr()?
                        .to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_aarccm_addrptr()?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_aarccm_scratchptr()?
                        .to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value =
                        self.0.lock().unwrap().read_ccm_inptr()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_aarccm_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073803264;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for AAR TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_aarccm_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8u64 && _end >= 12u64,
                        "partial write for AAR TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_aarccm_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for CCM TASKS_CRYPT not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccm_tasks_crypt(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for AAR EVENTS_END not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_aarccm_events_end(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260u64 && _end >= 264u64,
                        "partial write for AAR EVENTS_RESOLVED not implemented",
                    );
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_aarccm_events_resolved(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264u64 && _end >= 268u64 , "partial write for AAR EVENTS_NOTRESOLVED not implemented" ,);
                    let start = _start.saturating_sub(264u64) as usize;
                    let end =
                        (_end.saturating_sub(264u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_aarccm_events_notresolved(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_ccm_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_aarccm_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_aarccm_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => return Err(MemError::WriteViolation),
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_aarccm_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_aarccm_nirk(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    assert!(
                        _start <= 1288u64 && _end >= 1292u64,
                        "partial write for AAR IRKPTR not implemented",
                    );
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_aarccm_irkptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296u64 && _end >= 1300u64,
                        "partial write for AAR ADDRPTR not implemented",
                    );
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_aarccm_addrptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    assert!(
                        _start <= 1300u64 && _end >= 1304u64,
                        "partial write for AAR SCRATCHPTR not implemented",
                    );
                    let start = _start.saturating_sub(1300u64) as usize;
                    let end =
                        (_end.saturating_sub(1300u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_aarccm_scratchptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    assert!(
                        _start <= 1292u64 && _end >= 1296u64,
                        "partial write for CCM INPTR not implemented",
                    );
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccm_inptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_aarccm_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000F000 {
    fn read_aarccm_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_aarccm_intenset_end()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_aarccm_intenset_resolved()?)
                << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_aarccm_intenset_notresolved()?,
        ) << 2u32;
        Ok(_value)
    }
    fn write_aarccm_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_aarccm_intenset_end((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_aarccm_intenset_resolved((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_aarccm_intenset_notresolved(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_aarccm_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_aarccm_intenclr_end()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_aarccm_intenclr_resolved()?)
                << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_aarccm_intenclr_notresolved()?,
        ) << 2u32;
        Ok(_value)
    }
    fn write_aarccm_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_aarccm_intenclr_end((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_aarccm_intenclr_resolved((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_aarccm_intenclr_notresolved(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_aarccm_status(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_aarccm_status_status()?)
                << 0u32;
        Ok(_value)
    }
    fn read_aarccm_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_aarccm_enable_enable()?)
                << 0u32;
        Ok(_value)
    }
    fn write_aarccm_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_aarccm_enable_enable((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_aarccm_nirk(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_aarccm_nirk_nirk()?) << 0u32;
        Ok(_value)
    }
    fn write_aarccm_nirk(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_aarccm_nirk_nirk((_value[_i] >> 0) & 31u8)?;
        }
        Ok(())
    }
    fn read_aarccm_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_aarccm_power_power()?)
            << 0u32;
        Ok(_value)
    }
    fn write_aarccm_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_aarccm_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ccm_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccm_shorts_endksgen_crypt()?)
                << 0u32;
        Ok(_value)
    }
    fn write_ccm_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccm_shorts_endksgen_crypt((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40010000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40010000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073807360;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => return Err(MemError::ReadViolation),
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_wdt_events_timeout()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_wdt_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_wdt_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1031, 1025..=1032) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_wdt_runstatus()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1032 && _end > 1028 {
                    let _value = self.read_wdt_reqstatus()?.to_ne_bytes();
                    if _start <= 1028 && _end > 1028 {
                        _buf[(1028 - _start) as usize] = _value[0];
                    }
                    if _start <= 1029 && _end > 1029 {
                        _buf[(1029 - _start) as usize] = _value[1];
                    }
                    if _start <= 1030 && _end > 1030 {
                        _buf[(1030 - _start) as usize] = _value[2];
                    }
                    if _start <= 1031 && _end > 1031 {
                        _buf[(1031 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1295, 1285..=1296) => {
                if _start < 1288 && _end > 1284 {
                    let _value =
                        self.0.lock().unwrap().read_wdt_crv()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_wdt_rren()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_wdt_config()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1536..=1567, 1537..=1568) => return Err(MemError::ReadViolation),
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_wdt_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073807360;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for WDT TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for WDT EVENTS_TIMEOUT not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_events_timeout(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_wdt_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_wdt_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1031, 1025..=1032) => return Err(MemError::WriteViolation),
            (1284..=1295, 1285..=1296) => {
                if _start < 1288 && _end > 1284 {
                    assert!(
                        _start <= 1284u64 && _end >= 1288u64,
                        "partial write for WDT CRV not implemented",
                    );
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_crv(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = 1288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.write_wdt_rren(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = 1292u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.write_wdt_config(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1536..=1567, 1537..=1568) => {
                if _start < 1540 && _end > 1536 {
                    assert!(
                        _start <= 1536u64 && _end >= 1540u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1536u64) as usize;
                    let end =
                        (_end.saturating_sub(1536u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1556 && _end > 1552 {
                    assert!(
                        _start <= 1552u64 && _end >= 1556u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1552u64) as usize;
                    let end =
                        (_end.saturating_sub(1552u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1572 && _end > 1568 {
                    assert!(
                        _start <= 1568u64 && _end >= 1572u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1568u64) as usize;
                    let end =
                        (_end.saturating_sub(1568u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1588 && _end > 1584 {
                    assert!(
                        _start <= 1584u64 && _end >= 1588u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1584u64) as usize;
                    let end =
                        (_end.saturating_sub(1584u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1604 && _end > 1600 {
                    assert!(
                        _start <= 1600u64 && _end >= 1604u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1600u64) as usize;
                    let end =
                        (_end.saturating_sub(1600u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1620 && _end > 1616 {
                    assert!(
                        _start <= 1616u64 && _end >= 1620u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1616u64) as usize;
                    let end =
                        (_end.saturating_sub(1616u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1636 && _end > 1632 {
                    assert!(
                        _start <= 1632u64 && _end >= 1636u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1632u64) as usize;
                    let end =
                        (_end.saturating_sub(1632u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1652 && _end > 1648 {
                    assert!(
                        _start <= 1648u64 && _end >= 1652u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1648u64) as usize;
                    let end =
                        (_end.saturating_sub(1648u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_wdt_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40010000 {
    fn read_wdt_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_intenset_timeout()?)
                << 0u32;
        Ok(_value)
    }
    fn write_wdt_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_intenset_timeout((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_wdt_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_intenclr_timeout()?)
                << 0u32;
        Ok(_value)
    }
    fn write_wdt_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_intenclr_timeout((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_wdt_runstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_runstatus_runstatus()?)
                << 0u32;
        Ok(_value)
    }
    fn read_wdt_reqstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr7()?) << 7u32;
        Ok(_value)
    }
    fn read_wdt_rren(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr7()?) << 7u32;
        Ok(_value)
    }
    fn write_wdt_rren(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr7((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_wdt_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_config_sleep()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_config_halt()?) << 3u32;
        Ok(_value)
    }
    fn write_wdt_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_config_sleep((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_config_halt((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_wdt_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_wdt_power(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40012000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40012000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073815552;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => return Err(MemError::ReadViolation),
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_events_samplerdy()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_events_reportrdy()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_events_accof()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_qdec_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_qdec_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_qdec_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_qdec_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_qdec_ledpol()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_qdec_sampleper()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_sample()?
                        .to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_qdec_reportper()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value =
                        self.0.lock().unwrap().read_qdec_acc()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_accread()?
                        .to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_pselled()?
                        .to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value =
                        self.0.lock().unwrap().read_qdec_psela()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value =
                        self.0.lock().unwrap().read_qdec_pselb()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_qdec_dbfen()?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1355, 1345..=1356) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_qdec_ledpre()?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_qdec_accdbl()?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_qdec_accdblread()?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_qdec_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073815552;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for QDEC TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for QDEC TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert ! (_start <= 8u64 && _end >= 12u64 , "partial write for QDEC TASKS_READCLRACC not implemented" ,);
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_tasks_readclracc(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    assert ! (_start <= 256u64 && _end >= 260u64 , "partial write for QDEC EVENTS_SAMPLERDY not implemented" ,);
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_events_samplerdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260u64 && _end >= 264u64 , "partial write for QDEC EVENTS_REPORTRDY not implemented" ,);
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_events_reportrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264u64 && _end >= 268u64,
                        "partial write for QDEC EVENTS_ACCOF not implemented",
                    );
                    let start = _start.saturating_sub(264u64) as usize;
                    let end =
                        (_end.saturating_sub(264u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_events_accof(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_qdec_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_qdec_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_qdec_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_qdec_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_qdec_ledpol(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = 1288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.write_qdec_sampleper(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1300 && _end > 1296 {
                    let offset = 1296u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.write_qdec_reportper(offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1312 && _end > 1308 {
                    assert!(
                        _start <= 1308u64 && _end >= 1312u64,
                        "partial write for QDEC PSELLED not implemented",
                    );
                    let start = _start.saturating_sub(1308u64) as usize;
                    let end =
                        (_end.saturating_sub(1308u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_pselled(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1316 && _end > 1312 {
                    assert!(
                        _start <= 1312u64 && _end >= 1316u64,
                        "partial write for QDEC PSELA not implemented",
                    );
                    let start = _start.saturating_sub(1312u64) as usize;
                    let end =
                        (_end.saturating_sub(1312u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_psela(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1320 && _end > 1316 {
                    assert!(
                        _start <= 1316u64 && _end >= 1320u64,
                        "partial write for QDEC PSELB not implemented",
                    );
                    let start = _start.saturating_sub(1316u64) as usize;
                    let end =
                        (_end.saturating_sub(1316u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_pselb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = 1320u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1320u64) as usize;
                    let end =
                        (_end.saturating_sub(1320u64) as usize).min(start + 4);
                    self.write_qdec_dbfen(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1355, 1345..=1356) => {
                if _start < 1348 && _end > 1344 {
                    let offset = 1344u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1344u64) as usize;
                    let end =
                        (_end.saturating_sub(1344u64) as usize).min(start + 4);
                    self.write_qdec_ledpre(offset, &_buf[start..end])?;
                }
                if _start < 1352 && _end > 1348 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1356 && _end > 1352 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_qdec_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40012000 {
    fn read_qdec_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_qdec_shorts_reportrdy_readclracc()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_qdec_shorts_samplerdy_stop()?,
        ) << 1u32;
        Ok(_value)
    }
    fn write_qdec_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_shorts_reportrdy_readclracc(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_shorts_samplerdy_stop((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenset_samplerdy()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenset_reportrdy()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_intenset_accof()?)
            << 2u32;
        Ok(_value)
    }
    fn write_qdec_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenset_samplerdy((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenset_reportrdy((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenset_accof((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenclr_samplerdy()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenclr_reportrdy()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_intenclr_accof()?)
            << 2u32;
        Ok(_value)
    }
    fn write_qdec_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenclr_samplerdy((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenclr_reportrdy((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenclr_accof((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_enable_enable()?)
            << 0u32;
        Ok(_value)
    }
    fn write_qdec_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_enable_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_ledpol(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_ledpol_ledpol()?)
            << 0u32;
        Ok(_value)
    }
    fn write_qdec_ledpol(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_ledpol_ledpol((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_sampleper(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_sampleper_sampleper()?)
                << 0u32;
        Ok(_value)
    }
    fn write_qdec_sampleper(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_sampleper_sampleper((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_qdec_reportper(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_reportper_reportper()?)
                << 0u32;
        Ok(_value)
    }
    fn write_qdec_reportper(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_reportper_reportper((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_qdec_dbfen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_dbfen_dbfen()?) << 0u32;
        Ok(_value)
    }
    fn write_qdec_dbfen(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_dbfen_dbfen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_ledpre(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_ledpre_ledpre()?)
            << 0u32;
        Ok(_value)
    }
    fn write_qdec_ledpre(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 1u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_qdec_ledpre_ledpre(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_qdec_accdbl(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_accdbl_accdbl()?)
            << 0u32;
        Ok(_value)
    }
    fn read_qdec_accdblread(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_qdec_accdblread_accdblread()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_qdec_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_qdec_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40013000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40013000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073819648;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => return Err(MemError::ReadViolation),
            (256..=271, 257..=272) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_lpcomp_events_ready()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_lpcomp_events_down()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_lpcomp_events_up()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_lpcomp_events_cross()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_lpcomp_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_lpcomp_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_lpcomp_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_lpcomp_result()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1295, 1281..=1296) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_lpcomp_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_lpcomp_psel()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_lpcomp_refsel()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_lpcomp_extrefsel()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1312..=1315, 1313..=1316) => {
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_lpcomp_anadetect()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_lpcomp_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073819648;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for LPCOMP TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_lpcomp_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for LPCOMP TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_lpcomp_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8u64 && _end >= 12u64,
                        "partial write for LPCOMP TASKS_SAMPLE not implemented",
                    );
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_lpcomp_tasks_sample(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=271, 257..=272) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for LPCOMP EVENTS_READY not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_lpcomp_events_ready(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260u64 && _end >= 264u64,
                        "partial write for LPCOMP EVENTS_DOWN not implemented",
                    );
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_lpcomp_events_down(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264u64 && _end >= 268u64,
                        "partial write for LPCOMP EVENTS_UP not implemented",
                    );
                    let start = _start.saturating_sub(264u64) as usize;
                    let end =
                        (_end.saturating_sub(264u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_lpcomp_events_up(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268u64 && _end >= 272u64,
                        "partial write for LPCOMP EVENTS_CROSS not implemented",
                    );
                    let start = _start.saturating_sub(268u64) as usize;
                    let end =
                        (_end.saturating_sub(268u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_lpcomp_events_cross(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = 512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.write_lpcomp_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = 772u64.saturating_sub(_start);
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.write_lpcomp_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = 776u64.saturating_sub(_start);
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.write_lpcomp_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => return Err(MemError::WriteViolation),
            (1280..=1295, 1281..=1296) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_lpcomp_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_lpcomp_psel(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = 1288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.write_lpcomp_refsel(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = 1292u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.write_lpcomp_extrefsel(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1312..=1315, 1313..=1316) => {
                if _start < 1316 && _end > 1312 {
                    let offset = 1312u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1312u64) as usize;
                    let end =
                        (_end.saturating_sub(1312u64) as usize).min(start + 4);
                    self.write_lpcomp_anadetect(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = 4092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(4092u64) as usize;
                    let end =
                        (_end.saturating_sub(4092u64) as usize).min(start + 4);
                    self.write_lpcomp_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40013000 {
    fn read_lpcomp_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_lpcomp_shorts_ready_sample()?,
        ) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_shorts_ready_stop()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_shorts_down_stop()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_shorts_up_stop()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_shorts_cross_stop()?)
                << 4u32;
        Ok(_value)
    }
    fn write_lpcomp_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_shorts_ready_sample((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_shorts_ready_stop((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_shorts_down_stop((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_shorts_up_stop((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_shorts_cross_stop((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_lpcomp_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_intenset_ready()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_intenset_down()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_lpcomp_intenset_up()?)
            << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_intenset_cross()?)
                << 3u32;
        Ok(_value)
    }
    fn write_lpcomp_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_intenset_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_intenset_down((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_intenset_up((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_intenset_cross((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_lpcomp_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_intenclr_ready()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_intenclr_down()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_lpcomp_intenclr_up()?)
            << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_intenclr_cross()?)
                << 3u32;
        Ok(_value)
    }
    fn write_lpcomp_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_intenclr_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_intenclr_down((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_intenclr_up((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_intenclr_cross((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_lpcomp_result(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_result_result()?)
                << 0u32;
        Ok(_value)
    }
    fn read_lpcomp_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_enable_enable()?)
                << 0u32;
        Ok(_value)
    }
    fn write_lpcomp_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_enable_enable((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_lpcomp_psel(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_psel_psel()?) << 0u32;
        Ok(_value)
    }
    fn write_lpcomp_psel(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_psel_psel((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_lpcomp_refsel(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_lpcomp_refsel_refsel()?)
                << 0u32;
        Ok(_value)
    }
    fn write_lpcomp_refsel(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_refsel_refsel((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_lpcomp_extrefsel(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_lpcomp_extrefsel_extrefsel()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_lpcomp_extrefsel(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_extrefsel_extrefsel((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_lpcomp_anadetect(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_lpcomp_anadetect_anadetect()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_lpcomp_anadetect(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_anadetect_anadetect((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_lpcomp_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_lpcomp_power_power()?)
            << 0u32;
        Ok(_value)
    }
    fn write_lpcomp_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40014000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40014000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073823744;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    let _value =
                        self.0.lock().unwrap().read_swi_unused()?.to_ne_bytes();
                    if _start <= 0 && _end > 0 {
                        _buf[(0 - _start) as usize] = _value[0];
                    }
                    if _start <= 1 && _end > 1 {
                        _buf[(1 - _start) as usize] = _value[1];
                    }
                    if _start <= 2 && _end > 2 {
                        _buf[(2 - _start) as usize] = _value[2];
                    }
                    if _start <= 3 && _end > 3 {
                        _buf[(3 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073823744;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => return Err(MemError::WriteViolation),
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40014000 {}
pub(crate) struct PeripheralPage0x4001E000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4001E000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073864704;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_nvmc_ready()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1303, 1285..=1304) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_nvmc_config()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvmc_erasepage()?
                        .to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_nvmc_eraseall()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvmc_erasepcr0()?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_nvmc_eraseuicr()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073864704;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1024..=1027, 1025..=1028) => return Err(MemError::WriteViolation),
            (1284..=1303, 1285..=1304) => {
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_nvmc_config(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    assert!(
                        _start <= 1288u64 && _end >= 1292u64,
                        "partial write for NVMC ERASEPAGE not implemented",
                    );
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvmc_erasepage(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = 1292u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.write_nvmc_eraseall(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296u64 && _end >= 1300u64,
                        "partial write for NVMC ERASEPCR0 not implemented",
                    );
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvmc_erasepcr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = 1300u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1300u64) as usize;
                    let end =
                        (_end.saturating_sub(1300u64) as usize).min(start + 4);
                    self.write_nvmc_eraseuicr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4001E000 {
    fn read_nvmc_ready(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_ready_ready()?) << 0u32;
        Ok(_value)
    }
    fn read_nvmc_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_config_wen()?) << 0u32;
        Ok(_value)
    }
    fn write_nvmc_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvmc_config_wen((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_nvmc_eraseall(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_eraseall_eraseall()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvmc_eraseall(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvmc_eraseall_eraseall((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_nvmc_eraseuicr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_eraseuicr_eraseuicr()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvmc_eraseuicr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvmc_eraseuicr_eraseuicr((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4001F000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4001F000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073868800;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=31, 1..=32) => return Err(MemError::ReadViolation),
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_ppi_chen()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_ppi_chenset()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_ppi_chenclr()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1423, 1297..=1424) => {
                if _start < 1300 && _end > 1296 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(0)?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(1)?.to_ne_bytes();
                    if _start <= 1328 && _end > 1328 {
                        _buf[(1328 - _start) as usize] = _value[0];
                    }
                    if _start <= 1329 && _end > 1329 {
                        _buf[(1329 - _start) as usize] = _value[1];
                    }
                    if _start <= 1330 && _end > 1330 {
                        _buf[(1330 - _start) as usize] = _value[2];
                    }
                    if _start <= 1331 && _end > 1331 {
                        _buf[(1331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(2)?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1396 && _end > 1392 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(3)?.to_ne_bytes();
                    if _start <= 1392 && _end > 1392 {
                        _buf[(1392 - _start) as usize] = _value[0];
                    }
                    if _start <= 1393 && _end > 1393 {
                        _buf[(1393 - _start) as usize] = _value[1];
                    }
                    if _start <= 1394 && _end > 1394 {
                        _buf[(1394 - _start) as usize] = _value[2];
                    }
                    if _start <= 1395 && _end > 1395 {
                        _buf[(1395 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1428 && _end > 1424 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(4)?.to_ne_bytes();
                    if _start <= 1424 && _end > 1424 {
                        _buf[(1424 - _start) as usize] = _value[0];
                    }
                    if _start <= 1425 && _end > 1425 {
                        _buf[(1425 - _start) as usize] = _value[1];
                    }
                    if _start <= 1426 && _end > 1426 {
                        _buf[(1426 - _start) as usize] = _value[2];
                    }
                    if _start <= 1427 && _end > 1427 {
                        _buf[(1427 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1460 && _end > 1456 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(5)?.to_ne_bytes();
                    if _start <= 1456 && _end > 1456 {
                        _buf[(1456 - _start) as usize] = _value[0];
                    }
                    if _start <= 1457 && _end > 1457 {
                        _buf[(1457 - _start) as usize] = _value[1];
                    }
                    if _start <= 1458 && _end > 1458 {
                        _buf[(1458 - _start) as usize] = _value[2];
                    }
                    if _start <= 1459 && _end > 1459 {
                        _buf[(1459 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1492 && _end > 1488 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(6)?.to_ne_bytes();
                    if _start <= 1488 && _end > 1488 {
                        _buf[(1488 - _start) as usize] = _value[0];
                    }
                    if _start <= 1489 && _end > 1489 {
                        _buf[(1489 - _start) as usize] = _value[1];
                    }
                    if _start <= 1490 && _end > 1490 {
                        _buf[(1490 - _start) as usize] = _value[2];
                    }
                    if _start <= 1491 && _end > 1491 {
                        _buf[(1491 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1524 && _end > 1520 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(7)?.to_ne_bytes();
                    if _start <= 1520 && _end > 1520 {
                        _buf[(1520 - _start) as usize] = _value[0];
                    }
                    if _start <= 1521 && _end > 1521 {
                        _buf[(1521 - _start) as usize] = _value[1];
                    }
                    if _start <= 1522 && _end > 1522 {
                        _buf[(1522 - _start) as usize] = _value[2];
                    }
                    if _start <= 1523 && _end > 1523 {
                        _buf[(1523 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1556 && _end > 1552 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(8)?.to_ne_bytes();
                    if _start <= 1552 && _end > 1552 {
                        _buf[(1552 - _start) as usize] = _value[0];
                    }
                    if _start <= 1553 && _end > 1553 {
                        _buf[(1553 - _start) as usize] = _value[1];
                    }
                    if _start <= 1554 && _end > 1554 {
                        _buf[(1554 - _start) as usize] = _value[2];
                    }
                    if _start <= 1555 && _end > 1555 {
                        _buf[(1555 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1588 && _end > 1584 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(9)?.to_ne_bytes();
                    if _start <= 1584 && _end > 1584 {
                        _buf[(1584 - _start) as usize] = _value[0];
                    }
                    if _start <= 1585 && _end > 1585 {
                        _buf[(1585 - _start) as usize] = _value[1];
                    }
                    if _start <= 1586 && _end > 1586 {
                        _buf[(1586 - _start) as usize] = _value[2];
                    }
                    if _start <= 1587 && _end > 1587 {
                        _buf[(1587 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1620 && _end > 1616 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(10)?.to_ne_bytes();
                    if _start <= 1616 && _end > 1616 {
                        _buf[(1616 - _start) as usize] = _value[0];
                    }
                    if _start <= 1617 && _end > 1617 {
                        _buf[(1617 - _start) as usize] = _value[1];
                    }
                    if _start <= 1618 && _end > 1618 {
                        _buf[(1618 - _start) as usize] = _value[2];
                    }
                    if _start <= 1619 && _end > 1619 {
                        _buf[(1619 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1652 && _end > 1648 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(11)?.to_ne_bytes();
                    if _start <= 1648 && _end > 1648 {
                        _buf[(1648 - _start) as usize] = _value[0];
                    }
                    if _start <= 1649 && _end > 1649 {
                        _buf[(1649 - _start) as usize] = _value[1];
                    }
                    if _start <= 1650 && _end > 1650 {
                        _buf[(1650 - _start) as usize] = _value[2];
                    }
                    if _start <= 1651 && _end > 1651 {
                        _buf[(1651 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1684 && _end > 1680 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(12)?.to_ne_bytes();
                    if _start <= 1680 && _end > 1680 {
                        _buf[(1680 - _start) as usize] = _value[0];
                    }
                    if _start <= 1681 && _end > 1681 {
                        _buf[(1681 - _start) as usize] = _value[1];
                    }
                    if _start <= 1682 && _end > 1682 {
                        _buf[(1682 - _start) as usize] = _value[2];
                    }
                    if _start <= 1683 && _end > 1683 {
                        _buf[(1683 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1716 && _end > 1712 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(13)?.to_ne_bytes();
                    if _start <= 1712 && _end > 1712 {
                        _buf[(1712 - _start) as usize] = _value[0];
                    }
                    if _start <= 1713 && _end > 1713 {
                        _buf[(1713 - _start) as usize] = _value[1];
                    }
                    if _start <= 1714 && _end > 1714 {
                        _buf[(1714 - _start) as usize] = _value[2];
                    }
                    if _start <= 1715 && _end > 1715 {
                        _buf[(1715 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1748 && _end > 1744 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(14)?.to_ne_bytes();
                    if _start <= 1744 && _end > 1744 {
                        _buf[(1744 - _start) as usize] = _value[0];
                    }
                    if _start <= 1745 && _end > 1745 {
                        _buf[(1745 - _start) as usize] = _value[1];
                    }
                    if _start <= 1746 && _end > 1746 {
                        _buf[(1746 - _start) as usize] = _value[2];
                    }
                    if _start <= 1747 && _end > 1747 {
                        _buf[(1747 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1780 && _end > 1776 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_eep(15)?.to_ne_bytes();
                    if _start <= 1776 && _end > 1776 {
                        _buf[(1776 - _start) as usize] = _value[0];
                    }
                    if _start <= 1777 && _end > 1777 {
                        _buf[(1777 - _start) as usize] = _value[1];
                    }
                    if _start <= 1778 && _end > 1778 {
                        _buf[(1778 - _start) as usize] = _value[2];
                    }
                    if _start <= 1779 && _end > 1779 {
                        _buf[(1779 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(0)?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(1)?.to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(2)?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1400 && _end > 1396 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(3)?.to_ne_bytes();
                    if _start <= 1396 && _end > 1396 {
                        _buf[(1396 - _start) as usize] = _value[0];
                    }
                    if _start <= 1397 && _end > 1397 {
                        _buf[(1397 - _start) as usize] = _value[1];
                    }
                    if _start <= 1398 && _end > 1398 {
                        _buf[(1398 - _start) as usize] = _value[2];
                    }
                    if _start <= 1399 && _end > 1399 {
                        _buf[(1399 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1432 && _end > 1428 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(4)?.to_ne_bytes();
                    if _start <= 1428 && _end > 1428 {
                        _buf[(1428 - _start) as usize] = _value[0];
                    }
                    if _start <= 1429 && _end > 1429 {
                        _buf[(1429 - _start) as usize] = _value[1];
                    }
                    if _start <= 1430 && _end > 1430 {
                        _buf[(1430 - _start) as usize] = _value[2];
                    }
                    if _start <= 1431 && _end > 1431 {
                        _buf[(1431 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1464 && _end > 1460 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(5)?.to_ne_bytes();
                    if _start <= 1460 && _end > 1460 {
                        _buf[(1460 - _start) as usize] = _value[0];
                    }
                    if _start <= 1461 && _end > 1461 {
                        _buf[(1461 - _start) as usize] = _value[1];
                    }
                    if _start <= 1462 && _end > 1462 {
                        _buf[(1462 - _start) as usize] = _value[2];
                    }
                    if _start <= 1463 && _end > 1463 {
                        _buf[(1463 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1496 && _end > 1492 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(6)?.to_ne_bytes();
                    if _start <= 1492 && _end > 1492 {
                        _buf[(1492 - _start) as usize] = _value[0];
                    }
                    if _start <= 1493 && _end > 1493 {
                        _buf[(1493 - _start) as usize] = _value[1];
                    }
                    if _start <= 1494 && _end > 1494 {
                        _buf[(1494 - _start) as usize] = _value[2];
                    }
                    if _start <= 1495 && _end > 1495 {
                        _buf[(1495 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1528 && _end > 1524 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(7)?.to_ne_bytes();
                    if _start <= 1524 && _end > 1524 {
                        _buf[(1524 - _start) as usize] = _value[0];
                    }
                    if _start <= 1525 && _end > 1525 {
                        _buf[(1525 - _start) as usize] = _value[1];
                    }
                    if _start <= 1526 && _end > 1526 {
                        _buf[(1526 - _start) as usize] = _value[2];
                    }
                    if _start <= 1527 && _end > 1527 {
                        _buf[(1527 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1560 && _end > 1556 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(8)?.to_ne_bytes();
                    if _start <= 1556 && _end > 1556 {
                        _buf[(1556 - _start) as usize] = _value[0];
                    }
                    if _start <= 1557 && _end > 1557 {
                        _buf[(1557 - _start) as usize] = _value[1];
                    }
                    if _start <= 1558 && _end > 1558 {
                        _buf[(1558 - _start) as usize] = _value[2];
                    }
                    if _start <= 1559 && _end > 1559 {
                        _buf[(1559 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1592 && _end > 1588 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(9)?.to_ne_bytes();
                    if _start <= 1588 && _end > 1588 {
                        _buf[(1588 - _start) as usize] = _value[0];
                    }
                    if _start <= 1589 && _end > 1589 {
                        _buf[(1589 - _start) as usize] = _value[1];
                    }
                    if _start <= 1590 && _end > 1590 {
                        _buf[(1590 - _start) as usize] = _value[2];
                    }
                    if _start <= 1591 && _end > 1591 {
                        _buf[(1591 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1624 && _end > 1620 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(10)?.to_ne_bytes();
                    if _start <= 1620 && _end > 1620 {
                        _buf[(1620 - _start) as usize] = _value[0];
                    }
                    if _start <= 1621 && _end > 1621 {
                        _buf[(1621 - _start) as usize] = _value[1];
                    }
                    if _start <= 1622 && _end > 1622 {
                        _buf[(1622 - _start) as usize] = _value[2];
                    }
                    if _start <= 1623 && _end > 1623 {
                        _buf[(1623 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1656 && _end > 1652 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(11)?.to_ne_bytes();
                    if _start <= 1652 && _end > 1652 {
                        _buf[(1652 - _start) as usize] = _value[0];
                    }
                    if _start <= 1653 && _end > 1653 {
                        _buf[(1653 - _start) as usize] = _value[1];
                    }
                    if _start <= 1654 && _end > 1654 {
                        _buf[(1654 - _start) as usize] = _value[2];
                    }
                    if _start <= 1655 && _end > 1655 {
                        _buf[(1655 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1688 && _end > 1684 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(12)?.to_ne_bytes();
                    if _start <= 1684 && _end > 1684 {
                        _buf[(1684 - _start) as usize] = _value[0];
                    }
                    if _start <= 1685 && _end > 1685 {
                        _buf[(1685 - _start) as usize] = _value[1];
                    }
                    if _start <= 1686 && _end > 1686 {
                        _buf[(1686 - _start) as usize] = _value[2];
                    }
                    if _start <= 1687 && _end > 1687 {
                        _buf[(1687 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1720 && _end > 1716 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(13)?.to_ne_bytes();
                    if _start <= 1716 && _end > 1716 {
                        _buf[(1716 - _start) as usize] = _value[0];
                    }
                    if _start <= 1717 && _end > 1717 {
                        _buf[(1717 - _start) as usize] = _value[1];
                    }
                    if _start <= 1718 && _end > 1718 {
                        _buf[(1718 - _start) as usize] = _value[2];
                    }
                    if _start <= 1719 && _end > 1719 {
                        _buf[(1719 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1752 && _end > 1748 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(14)?.to_ne_bytes();
                    if _start <= 1748 && _end > 1748 {
                        _buf[(1748 - _start) as usize] = _value[0];
                    }
                    if _start <= 1749 && _end > 1749 {
                        _buf[(1749 - _start) as usize] = _value[1];
                    }
                    if _start <= 1750 && _end > 1750 {
                        _buf[(1750 - _start) as usize] = _value[2];
                    }
                    if _start <= 1751 && _end > 1751 {
                        _buf[(1751 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1784 && _end > 1780 {
                    let _value =
                        self.0.lock().unwrap().read_ppi_tep(15)?.to_ne_bytes();
                    if _start <= 1780 && _end > 1780 {
                        _buf[(1780 - _start) as usize] = _value[0];
                    }
                    if _start <= 1781 && _end > 1781 {
                        _buf[(1781 - _start) as usize] = _value[1];
                    }
                    if _start <= 1782 && _end > 1782 {
                        _buf[(1782 - _start) as usize] = _value[2];
                    }
                    if _start <= 1783 && _end > 1783 {
                        _buf[(1783 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (2048..=2063, 2049..=2064) => {
                if _start < 2052 && _end > 2048 {
                    let _value = self.read_ppi_chgn(0)?.to_ne_bytes();
                    if _start <= 2048 && _end > 2048 {
                        _buf[(2048 - _start) as usize] = _value[0];
                    }
                    if _start <= 2049 && _end > 2049 {
                        _buf[(2049 - _start) as usize] = _value[1];
                    }
                    if _start <= 2050 && _end > 2050 {
                        _buf[(2050 - _start) as usize] = _value[2];
                    }
                    if _start <= 2051 && _end > 2051 {
                        _buf[(2051 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2068 && _end > 2064 {
                    let _value = self.read_ppi_chgn(1)?.to_ne_bytes();
                    if _start <= 2064 && _end > 2064 {
                        _buf[(2064 - _start) as usize] = _value[0];
                    }
                    if _start <= 2065 && _end > 2065 {
                        _buf[(2065 - _start) as usize] = _value[1];
                    }
                    if _start <= 2066 && _end > 2066 {
                        _buf[(2066 - _start) as usize] = _value[2];
                    }
                    if _start <= 2067 && _end > 2067 {
                        _buf[(2067 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2084 && _end > 2080 {
                    let _value = self.read_ppi_chgn(2)?.to_ne_bytes();
                    if _start <= 2080 && _end > 2080 {
                        _buf[(2080 - _start) as usize] = _value[0];
                    }
                    if _start <= 2081 && _end > 2081 {
                        _buf[(2081 - _start) as usize] = _value[1];
                    }
                    if _start <= 2082 && _end > 2082 {
                        _buf[(2082 - _start) as usize] = _value[2];
                    }
                    if _start <= 2083 && _end > 2083 {
                        _buf[(2083 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2100 && _end > 2096 {
                    let _value = self.read_ppi_chgn(3)?.to_ne_bytes();
                    if _start <= 2096 && _end > 2096 {
                        _buf[(2096 - _start) as usize] = _value[0];
                    }
                    if _start <= 2097 && _end > 2097 {
                        _buf[(2097 - _start) as usize] = _value[1];
                    }
                    if _start <= 2098 && _end > 2098 {
                        _buf[(2098 - _start) as usize] = _value[2];
                    }
                    if _start <= 2099 && _end > 2099 {
                        _buf[(2099 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073868800;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=31, 1..=32) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0u64 && _end >= 4u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(0u64) as usize;
                    let end =
                        (_end.saturating_sub(0u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_en(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 36 && _end > 32 {
                    assert!(
                        _start <= 32u64 && _end >= 36u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(32u64) as usize;
                    let end =
                        (_end.saturating_sub(32u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_en(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 68 && _end > 64 {
                    assert!(
                        _start <= 64u64 && _end >= 68u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(64u64) as usize;
                    let end =
                        (_end.saturating_sub(64u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_en(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 100 && _end > 96 {
                    assert!(
                        _start <= 96u64 && _end >= 100u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(96u64) as usize;
                    let end =
                        (_end.saturating_sub(96u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_en(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4u64 && _end >= 8u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(4u64) as usize;
                    let end =
                        (_end.saturating_sub(4u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_dis(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 40 && _end > 36 {
                    assert!(
                        _start <= 36u64 && _end >= 40u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(36u64) as usize;
                    let end =
                        (_end.saturating_sub(36u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_dis(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 72 && _end > 68 {
                    assert!(
                        _start <= 68u64 && _end >= 72u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(68u64) as usize;
                    let end =
                        (_end.saturating_sub(68u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_dis(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 104 && _end > 100 {
                    assert!(
                        _start <= 100u64 && _end >= 104u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(100u64) as usize;
                    let end =
                        (_end.saturating_sub(100u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_dis(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let offset = 1280u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1280u64) as usize;
                    let end =
                        (_end.saturating_sub(1280u64) as usize).min(start + 4);
                    self.write_ppi_chen(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_ppi_chenset(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = 1288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.write_ppi_chenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1423, 1297..=1424) => {
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296u64 && _end >= 1300u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1296u64) as usize;
                    let end =
                        (_end.saturating_sub(1296u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1332 && _end > 1328 {
                    assert!(
                        _start <= 1328u64 && _end >= 1332u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1328u64) as usize;
                    let end =
                        (_end.saturating_sub(1328u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1364 && _end > 1360 {
                    assert!(
                        _start <= 1360u64 && _end >= 1364u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1360u64) as usize;
                    let end =
                        (_end.saturating_sub(1360u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1396 && _end > 1392 {
                    assert!(
                        _start <= 1392u64 && _end >= 1396u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1392u64) as usize;
                    let end =
                        (_end.saturating_sub(1392u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1428 && _end > 1424 {
                    assert!(
                        _start <= 1424u64 && _end >= 1428u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1424u64) as usize;
                    let end =
                        (_end.saturating_sub(1424u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1460 && _end > 1456 {
                    assert!(
                        _start <= 1456u64 && _end >= 1460u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1456u64) as usize;
                    let end =
                        (_end.saturating_sub(1456u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1492 && _end > 1488 {
                    assert!(
                        _start <= 1488u64 && _end >= 1492u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1488u64) as usize;
                    let end =
                        (_end.saturating_sub(1488u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1524 && _end > 1520 {
                    assert!(
                        _start <= 1520u64 && _end >= 1524u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1520u64) as usize;
                    let end =
                        (_end.saturating_sub(1520u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1556 && _end > 1552 {
                    assert!(
                        _start <= 1552u64 && _end >= 1556u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1552u64) as usize;
                    let end =
                        (_end.saturating_sub(1552u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1588 && _end > 1584 {
                    assert!(
                        _start <= 1584u64 && _end >= 1588u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1584u64) as usize;
                    let end =
                        (_end.saturating_sub(1584u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1620 && _end > 1616 {
                    assert!(
                        _start <= 1616u64 && _end >= 1620u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1616u64) as usize;
                    let end =
                        (_end.saturating_sub(1616u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1652 && _end > 1648 {
                    assert!(
                        _start <= 1648u64 && _end >= 1652u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1648u64) as usize;
                    let end =
                        (_end.saturating_sub(1648u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1684 && _end > 1680 {
                    assert!(
                        _start <= 1680u64 && _end >= 1684u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1680u64) as usize;
                    let end =
                        (_end.saturating_sub(1680u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1716 && _end > 1712 {
                    assert!(
                        _start <= 1712u64 && _end >= 1716u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1712u64) as usize;
                    let end =
                        (_end.saturating_sub(1712u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1748 && _end > 1744 {
                    assert!(
                        _start <= 1744u64 && _end >= 1748u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1744u64) as usize;
                    let end =
                        (_end.saturating_sub(1744u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1780 && _end > 1776 {
                    assert!(
                        _start <= 1776u64 && _end >= 1780u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1776u64) as usize;
                    let end =
                        (_end.saturating_sub(1776u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_eep(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    assert!(
                        _start <= 1300u64 && _end >= 1304u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1300u64) as usize;
                    let end =
                        (_end.saturating_sub(1300u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1336 && _end > 1332 {
                    assert!(
                        _start <= 1332u64 && _end >= 1336u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1332u64) as usize;
                    let end =
                        (_end.saturating_sub(1332u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1368 && _end > 1364 {
                    assert!(
                        _start <= 1364u64 && _end >= 1368u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1364u64) as usize;
                    let end =
                        (_end.saturating_sub(1364u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1400 && _end > 1396 {
                    assert!(
                        _start <= 1396u64 && _end >= 1400u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1396u64) as usize;
                    let end =
                        (_end.saturating_sub(1396u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1432 && _end > 1428 {
                    assert!(
                        _start <= 1428u64 && _end >= 1432u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1428u64) as usize;
                    let end =
                        (_end.saturating_sub(1428u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1464 && _end > 1460 {
                    assert!(
                        _start <= 1460u64 && _end >= 1464u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1460u64) as usize;
                    let end =
                        (_end.saturating_sub(1460u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1496 && _end > 1492 {
                    assert!(
                        _start <= 1492u64 && _end >= 1496u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1492u64) as usize;
                    let end =
                        (_end.saturating_sub(1492u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1528 && _end > 1524 {
                    assert!(
                        _start <= 1524u64 && _end >= 1528u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1524u64) as usize;
                    let end =
                        (_end.saturating_sub(1524u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1560 && _end > 1556 {
                    assert!(
                        _start <= 1556u64 && _end >= 1560u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1556u64) as usize;
                    let end =
                        (_end.saturating_sub(1556u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1592 && _end > 1588 {
                    assert!(
                        _start <= 1588u64 && _end >= 1592u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1588u64) as usize;
                    let end =
                        (_end.saturating_sub(1588u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1624 && _end > 1620 {
                    assert!(
                        _start <= 1620u64 && _end >= 1624u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1620u64) as usize;
                    let end =
                        (_end.saturating_sub(1620u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1656 && _end > 1652 {
                    assert!(
                        _start <= 1652u64 && _end >= 1656u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1652u64) as usize;
                    let end =
                        (_end.saturating_sub(1652u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1688 && _end > 1684 {
                    assert!(
                        _start <= 1684u64 && _end >= 1688u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1684u64) as usize;
                    let end =
                        (_end.saturating_sub(1684u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1720 && _end > 1716 {
                    assert!(
                        _start <= 1716u64 && _end >= 1720u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1716u64) as usize;
                    let end =
                        (_end.saturating_sub(1716u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1752 && _end > 1748 {
                    assert!(
                        _start <= 1748u64 && _end >= 1752u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1748u64) as usize;
                    let end =
                        (_end.saturating_sub(1748u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1784 && _end > 1780 {
                    assert!(
                        _start <= 1780u64 && _end >= 1784u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1780u64) as usize;
                    let end =
                        (_end.saturating_sub(1780u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tep(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (2048..=2063, 2049..=2064) => {
                if _start < 2052 && _end > 2048 {
                    let offset = 2048u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2048u64) as usize;
                    let end =
                        (_end.saturating_sub(2048u64) as usize).min(start + 4);
                    self.write_ppi_chgn(0, offset, &_buf[start..end])?;
                }
                if _start < 2068 && _end > 2064 {
                    let offset = 2064u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2064u64) as usize;
                    let end =
                        (_end.saturating_sub(2064u64) as usize).min(start + 4);
                    self.write_ppi_chgn(1, offset, &_buf[start..end])?;
                }
                if _start < 2084 && _end > 2080 {
                    let offset = 2080u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2080u64) as usize;
                    let end =
                        (_end.saturating_sub(2080u64) as usize).min(start + 4);
                    self.write_ppi_chgn(2, offset, &_buf[start..end])?;
                }
                if _start < 2100 && _end > 2096 {
                    let offset = 2096u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2096u64) as usize;
                    let end =
                        (_end.saturating_sub(2096u64) as usize).min(start + 4);
                    self.write_ppi_chgn(3, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4001F000 {
    fn read_ppi_chen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch31()?) << 31u32;
        Ok(_value)
    }
    fn write_ppi_chen(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ppi_chenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch31()?) << 31u32;
        Ok(_value)
    }
    fn write_ppi_chenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ppi_chenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch31()?) << 31u32;
        Ok(_value)
    }
    fn write_ppi_chenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ppi_chgn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch0(_dim)?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch1(_dim)?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch2(_dim)?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch3(_dim)?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch4(_dim)?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch5(_dim)?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch6(_dim)?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch7(_dim)?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch8(_dim)?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch9(_dim)?) << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch10(_dim)?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch11(_dim)?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch12(_dim)?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch13(_dim)?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch14(_dim)?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch15(_dim)?)
            << 15u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch20(_dim)?)
            << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch21(_dim)?)
            << 21u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch22(_dim)?)
            << 22u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch23(_dim)?)
            << 23u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch24(_dim)?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch25(_dim)?)
            << 25u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch26(_dim)?)
            << 26u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch27(_dim)?)
            << 27u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch28(_dim)?)
            << 28u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch29(_dim)?)
            << 29u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch30(_dim)?)
            << 30u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch31(_dim)?)
            << 31u32;
        Ok(_value)
    }
    fn write_ppi_chgn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch0(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch1(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch2(_dim, (_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch3(_dim, (_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch4(_dim, (_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch5(_dim, (_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch6(_dim, (_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch7(_dim, (_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch8(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch9(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch10(_dim, (_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch11(_dim, (_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch12(_dim, (_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch13(_dim, (_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch14(_dim, (_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch15(_dim, (_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch20(_dim, (_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch21(_dim, (_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch22(_dim, (_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch23(_dim, (_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch24(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch25(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch26(_dim, (_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch27(_dim, (_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch28(_dim, (_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch29(_dim, (_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch30(_dim, (_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch31(_dim, (_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x50000000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x50000000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1342177280;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1284..=1311, 1285..=1312) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_gpio_out()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_gpio_outset()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_gpio_outclr()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_gpio_in()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_gpio_dir()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_gpio_dirset()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_gpio_dirclr()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1792..=1919, 1793..=1920) => {
                if _start < 1796 && _end > 1792 {
                    let _value = self.read_gpio_pin_cnfn(0)?.to_ne_bytes();
                    if _start <= 1792 && _end > 1792 {
                        _buf[(1792 - _start) as usize] = _value[0];
                    }
                    if _start <= 1793 && _end > 1793 {
                        _buf[(1793 - _start) as usize] = _value[1];
                    }
                    if _start <= 1794 && _end > 1794 {
                        _buf[(1794 - _start) as usize] = _value[2];
                    }
                    if _start <= 1795 && _end > 1795 {
                        _buf[(1795 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1812 && _end > 1808 {
                    let _value = self.read_gpio_pin_cnfn(1)?.to_ne_bytes();
                    if _start <= 1808 && _end > 1808 {
                        _buf[(1808 - _start) as usize] = _value[0];
                    }
                    if _start <= 1809 && _end > 1809 {
                        _buf[(1809 - _start) as usize] = _value[1];
                    }
                    if _start <= 1810 && _end > 1810 {
                        _buf[(1810 - _start) as usize] = _value[2];
                    }
                    if _start <= 1811 && _end > 1811 {
                        _buf[(1811 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1828 && _end > 1824 {
                    let _value = self.read_gpio_pin_cnfn(2)?.to_ne_bytes();
                    if _start <= 1824 && _end > 1824 {
                        _buf[(1824 - _start) as usize] = _value[0];
                    }
                    if _start <= 1825 && _end > 1825 {
                        _buf[(1825 - _start) as usize] = _value[1];
                    }
                    if _start <= 1826 && _end > 1826 {
                        _buf[(1826 - _start) as usize] = _value[2];
                    }
                    if _start <= 1827 && _end > 1827 {
                        _buf[(1827 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1844 && _end > 1840 {
                    let _value = self.read_gpio_pin_cnfn(3)?.to_ne_bytes();
                    if _start <= 1840 && _end > 1840 {
                        _buf[(1840 - _start) as usize] = _value[0];
                    }
                    if _start <= 1841 && _end > 1841 {
                        _buf[(1841 - _start) as usize] = _value[1];
                    }
                    if _start <= 1842 && _end > 1842 {
                        _buf[(1842 - _start) as usize] = _value[2];
                    }
                    if _start <= 1843 && _end > 1843 {
                        _buf[(1843 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1860 && _end > 1856 {
                    let _value = self.read_gpio_pin_cnfn(4)?.to_ne_bytes();
                    if _start <= 1856 && _end > 1856 {
                        _buf[(1856 - _start) as usize] = _value[0];
                    }
                    if _start <= 1857 && _end > 1857 {
                        _buf[(1857 - _start) as usize] = _value[1];
                    }
                    if _start <= 1858 && _end > 1858 {
                        _buf[(1858 - _start) as usize] = _value[2];
                    }
                    if _start <= 1859 && _end > 1859 {
                        _buf[(1859 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1876 && _end > 1872 {
                    let _value = self.read_gpio_pin_cnfn(5)?.to_ne_bytes();
                    if _start <= 1872 && _end > 1872 {
                        _buf[(1872 - _start) as usize] = _value[0];
                    }
                    if _start <= 1873 && _end > 1873 {
                        _buf[(1873 - _start) as usize] = _value[1];
                    }
                    if _start <= 1874 && _end > 1874 {
                        _buf[(1874 - _start) as usize] = _value[2];
                    }
                    if _start <= 1875 && _end > 1875 {
                        _buf[(1875 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1892 && _end > 1888 {
                    let _value = self.read_gpio_pin_cnfn(6)?.to_ne_bytes();
                    if _start <= 1888 && _end > 1888 {
                        _buf[(1888 - _start) as usize] = _value[0];
                    }
                    if _start <= 1889 && _end > 1889 {
                        _buf[(1889 - _start) as usize] = _value[1];
                    }
                    if _start <= 1890 && _end > 1890 {
                        _buf[(1890 - _start) as usize] = _value[2];
                    }
                    if _start <= 1891 && _end > 1891 {
                        _buf[(1891 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1908 && _end > 1904 {
                    let _value = self.read_gpio_pin_cnfn(7)?.to_ne_bytes();
                    if _start <= 1904 && _end > 1904 {
                        _buf[(1904 - _start) as usize] = _value[0];
                    }
                    if _start <= 1905 && _end > 1905 {
                        _buf[(1905 - _start) as usize] = _value[1];
                    }
                    if _start <= 1906 && _end > 1906 {
                        _buf[(1906 - _start) as usize] = _value[2];
                    }
                    if _start <= 1907 && _end > 1907 {
                        _buf[(1907 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1924 && _end > 1920 {
                    let _value = self.read_gpio_pin_cnfn(8)?.to_ne_bytes();
                    if _start <= 1920 && _end > 1920 {
                        _buf[(1920 - _start) as usize] = _value[0];
                    }
                    if _start <= 1921 && _end > 1921 {
                        _buf[(1921 - _start) as usize] = _value[1];
                    }
                    if _start <= 1922 && _end > 1922 {
                        _buf[(1922 - _start) as usize] = _value[2];
                    }
                    if _start <= 1923 && _end > 1923 {
                        _buf[(1923 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1940 && _end > 1936 {
                    let _value = self.read_gpio_pin_cnfn(9)?.to_ne_bytes();
                    if _start <= 1936 && _end > 1936 {
                        _buf[(1936 - _start) as usize] = _value[0];
                    }
                    if _start <= 1937 && _end > 1937 {
                        _buf[(1937 - _start) as usize] = _value[1];
                    }
                    if _start <= 1938 && _end > 1938 {
                        _buf[(1938 - _start) as usize] = _value[2];
                    }
                    if _start <= 1939 && _end > 1939 {
                        _buf[(1939 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1956 && _end > 1952 {
                    let _value = self.read_gpio_pin_cnfn(10)?.to_ne_bytes();
                    if _start <= 1952 && _end > 1952 {
                        _buf[(1952 - _start) as usize] = _value[0];
                    }
                    if _start <= 1953 && _end > 1953 {
                        _buf[(1953 - _start) as usize] = _value[1];
                    }
                    if _start <= 1954 && _end > 1954 {
                        _buf[(1954 - _start) as usize] = _value[2];
                    }
                    if _start <= 1955 && _end > 1955 {
                        _buf[(1955 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1972 && _end > 1968 {
                    let _value = self.read_gpio_pin_cnfn(11)?.to_ne_bytes();
                    if _start <= 1968 && _end > 1968 {
                        _buf[(1968 - _start) as usize] = _value[0];
                    }
                    if _start <= 1969 && _end > 1969 {
                        _buf[(1969 - _start) as usize] = _value[1];
                    }
                    if _start <= 1970 && _end > 1970 {
                        _buf[(1970 - _start) as usize] = _value[2];
                    }
                    if _start <= 1971 && _end > 1971 {
                        _buf[(1971 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1988 && _end > 1984 {
                    let _value = self.read_gpio_pin_cnfn(12)?.to_ne_bytes();
                    if _start <= 1984 && _end > 1984 {
                        _buf[(1984 - _start) as usize] = _value[0];
                    }
                    if _start <= 1985 && _end > 1985 {
                        _buf[(1985 - _start) as usize] = _value[1];
                    }
                    if _start <= 1986 && _end > 1986 {
                        _buf[(1986 - _start) as usize] = _value[2];
                    }
                    if _start <= 1987 && _end > 1987 {
                        _buf[(1987 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2004 && _end > 2000 {
                    let _value = self.read_gpio_pin_cnfn(13)?.to_ne_bytes();
                    if _start <= 2000 && _end > 2000 {
                        _buf[(2000 - _start) as usize] = _value[0];
                    }
                    if _start <= 2001 && _end > 2001 {
                        _buf[(2001 - _start) as usize] = _value[1];
                    }
                    if _start <= 2002 && _end > 2002 {
                        _buf[(2002 - _start) as usize] = _value[2];
                    }
                    if _start <= 2003 && _end > 2003 {
                        _buf[(2003 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2020 && _end > 2016 {
                    let _value = self.read_gpio_pin_cnfn(14)?.to_ne_bytes();
                    if _start <= 2016 && _end > 2016 {
                        _buf[(2016 - _start) as usize] = _value[0];
                    }
                    if _start <= 2017 && _end > 2017 {
                        _buf[(2017 - _start) as usize] = _value[1];
                    }
                    if _start <= 2018 && _end > 2018 {
                        _buf[(2018 - _start) as usize] = _value[2];
                    }
                    if _start <= 2019 && _end > 2019 {
                        _buf[(2019 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2036 && _end > 2032 {
                    let _value = self.read_gpio_pin_cnfn(15)?.to_ne_bytes();
                    if _start <= 2032 && _end > 2032 {
                        _buf[(2032 - _start) as usize] = _value[0];
                    }
                    if _start <= 2033 && _end > 2033 {
                        _buf[(2033 - _start) as usize] = _value[1];
                    }
                    if _start <= 2034 && _end > 2034 {
                        _buf[(2034 - _start) as usize] = _value[2];
                    }
                    if _start <= 2035 && _end > 2035 {
                        _buf[(2035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2052 && _end > 2048 {
                    let _value = self.read_gpio_pin_cnfn(16)?.to_ne_bytes();
                    if _start <= 2048 && _end > 2048 {
                        _buf[(2048 - _start) as usize] = _value[0];
                    }
                    if _start <= 2049 && _end > 2049 {
                        _buf[(2049 - _start) as usize] = _value[1];
                    }
                    if _start <= 2050 && _end > 2050 {
                        _buf[(2050 - _start) as usize] = _value[2];
                    }
                    if _start <= 2051 && _end > 2051 {
                        _buf[(2051 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2068 && _end > 2064 {
                    let _value = self.read_gpio_pin_cnfn(17)?.to_ne_bytes();
                    if _start <= 2064 && _end > 2064 {
                        _buf[(2064 - _start) as usize] = _value[0];
                    }
                    if _start <= 2065 && _end > 2065 {
                        _buf[(2065 - _start) as usize] = _value[1];
                    }
                    if _start <= 2066 && _end > 2066 {
                        _buf[(2066 - _start) as usize] = _value[2];
                    }
                    if _start <= 2067 && _end > 2067 {
                        _buf[(2067 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2084 && _end > 2080 {
                    let _value = self.read_gpio_pin_cnfn(18)?.to_ne_bytes();
                    if _start <= 2080 && _end > 2080 {
                        _buf[(2080 - _start) as usize] = _value[0];
                    }
                    if _start <= 2081 && _end > 2081 {
                        _buf[(2081 - _start) as usize] = _value[1];
                    }
                    if _start <= 2082 && _end > 2082 {
                        _buf[(2082 - _start) as usize] = _value[2];
                    }
                    if _start <= 2083 && _end > 2083 {
                        _buf[(2083 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2100 && _end > 2096 {
                    let _value = self.read_gpio_pin_cnfn(19)?.to_ne_bytes();
                    if _start <= 2096 && _end > 2096 {
                        _buf[(2096 - _start) as usize] = _value[0];
                    }
                    if _start <= 2097 && _end > 2097 {
                        _buf[(2097 - _start) as usize] = _value[1];
                    }
                    if _start <= 2098 && _end > 2098 {
                        _buf[(2098 - _start) as usize] = _value[2];
                    }
                    if _start <= 2099 && _end > 2099 {
                        _buf[(2099 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2116 && _end > 2112 {
                    let _value = self.read_gpio_pin_cnfn(20)?.to_ne_bytes();
                    if _start <= 2112 && _end > 2112 {
                        _buf[(2112 - _start) as usize] = _value[0];
                    }
                    if _start <= 2113 && _end > 2113 {
                        _buf[(2113 - _start) as usize] = _value[1];
                    }
                    if _start <= 2114 && _end > 2114 {
                        _buf[(2114 - _start) as usize] = _value[2];
                    }
                    if _start <= 2115 && _end > 2115 {
                        _buf[(2115 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2132 && _end > 2128 {
                    let _value = self.read_gpio_pin_cnfn(21)?.to_ne_bytes();
                    if _start <= 2128 && _end > 2128 {
                        _buf[(2128 - _start) as usize] = _value[0];
                    }
                    if _start <= 2129 && _end > 2129 {
                        _buf[(2129 - _start) as usize] = _value[1];
                    }
                    if _start <= 2130 && _end > 2130 {
                        _buf[(2130 - _start) as usize] = _value[2];
                    }
                    if _start <= 2131 && _end > 2131 {
                        _buf[(2131 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2148 && _end > 2144 {
                    let _value = self.read_gpio_pin_cnfn(22)?.to_ne_bytes();
                    if _start <= 2144 && _end > 2144 {
                        _buf[(2144 - _start) as usize] = _value[0];
                    }
                    if _start <= 2145 && _end > 2145 {
                        _buf[(2145 - _start) as usize] = _value[1];
                    }
                    if _start <= 2146 && _end > 2146 {
                        _buf[(2146 - _start) as usize] = _value[2];
                    }
                    if _start <= 2147 && _end > 2147 {
                        _buf[(2147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2164 && _end > 2160 {
                    let _value = self.read_gpio_pin_cnfn(23)?.to_ne_bytes();
                    if _start <= 2160 && _end > 2160 {
                        _buf[(2160 - _start) as usize] = _value[0];
                    }
                    if _start <= 2161 && _end > 2161 {
                        _buf[(2161 - _start) as usize] = _value[1];
                    }
                    if _start <= 2162 && _end > 2162 {
                        _buf[(2162 - _start) as usize] = _value[2];
                    }
                    if _start <= 2163 && _end > 2163 {
                        _buf[(2163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2180 && _end > 2176 {
                    let _value = self.read_gpio_pin_cnfn(24)?.to_ne_bytes();
                    if _start <= 2176 && _end > 2176 {
                        _buf[(2176 - _start) as usize] = _value[0];
                    }
                    if _start <= 2177 && _end > 2177 {
                        _buf[(2177 - _start) as usize] = _value[1];
                    }
                    if _start <= 2178 && _end > 2178 {
                        _buf[(2178 - _start) as usize] = _value[2];
                    }
                    if _start <= 2179 && _end > 2179 {
                        _buf[(2179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2196 && _end > 2192 {
                    let _value = self.read_gpio_pin_cnfn(25)?.to_ne_bytes();
                    if _start <= 2192 && _end > 2192 {
                        _buf[(2192 - _start) as usize] = _value[0];
                    }
                    if _start <= 2193 && _end > 2193 {
                        _buf[(2193 - _start) as usize] = _value[1];
                    }
                    if _start <= 2194 && _end > 2194 {
                        _buf[(2194 - _start) as usize] = _value[2];
                    }
                    if _start <= 2195 && _end > 2195 {
                        _buf[(2195 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2212 && _end > 2208 {
                    let _value = self.read_gpio_pin_cnfn(26)?.to_ne_bytes();
                    if _start <= 2208 && _end > 2208 {
                        _buf[(2208 - _start) as usize] = _value[0];
                    }
                    if _start <= 2209 && _end > 2209 {
                        _buf[(2209 - _start) as usize] = _value[1];
                    }
                    if _start <= 2210 && _end > 2210 {
                        _buf[(2210 - _start) as usize] = _value[2];
                    }
                    if _start <= 2211 && _end > 2211 {
                        _buf[(2211 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2228 && _end > 2224 {
                    let _value = self.read_gpio_pin_cnfn(27)?.to_ne_bytes();
                    if _start <= 2224 && _end > 2224 {
                        _buf[(2224 - _start) as usize] = _value[0];
                    }
                    if _start <= 2225 && _end > 2225 {
                        _buf[(2225 - _start) as usize] = _value[1];
                    }
                    if _start <= 2226 && _end > 2226 {
                        _buf[(2226 - _start) as usize] = _value[2];
                    }
                    if _start <= 2227 && _end > 2227 {
                        _buf[(2227 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2244 && _end > 2240 {
                    let _value = self.read_gpio_pin_cnfn(28)?.to_ne_bytes();
                    if _start <= 2240 && _end > 2240 {
                        _buf[(2240 - _start) as usize] = _value[0];
                    }
                    if _start <= 2241 && _end > 2241 {
                        _buf[(2241 - _start) as usize] = _value[1];
                    }
                    if _start <= 2242 && _end > 2242 {
                        _buf[(2242 - _start) as usize] = _value[2];
                    }
                    if _start <= 2243 && _end > 2243 {
                        _buf[(2243 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2260 && _end > 2256 {
                    let _value = self.read_gpio_pin_cnfn(29)?.to_ne_bytes();
                    if _start <= 2256 && _end > 2256 {
                        _buf[(2256 - _start) as usize] = _value[0];
                    }
                    if _start <= 2257 && _end > 2257 {
                        _buf[(2257 - _start) as usize] = _value[1];
                    }
                    if _start <= 2258 && _end > 2258 {
                        _buf[(2258 - _start) as usize] = _value[2];
                    }
                    if _start <= 2259 && _end > 2259 {
                        _buf[(2259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2276 && _end > 2272 {
                    let _value = self.read_gpio_pin_cnfn(30)?.to_ne_bytes();
                    if _start <= 2272 && _end > 2272 {
                        _buf[(2272 - _start) as usize] = _value[0];
                    }
                    if _start <= 2273 && _end > 2273 {
                        _buf[(2273 - _start) as usize] = _value[1];
                    }
                    if _start <= 2274 && _end > 2274 {
                        _buf[(2274 - _start) as usize] = _value[2];
                    }
                    if _start <= 2275 && _end > 2275 {
                        _buf[(2275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2292 && _end > 2288 {
                    let _value = self.read_gpio_pin_cnfn(31)?.to_ne_bytes();
                    if _start <= 2288 && _end > 2288 {
                        _buf[(2288 - _start) as usize] = _value[0];
                    }
                    if _start <= 2289 && _end > 2289 {
                        _buf[(2289 - _start) as usize] = _value[1];
                    }
                    if _start <= 2290 && _end > 2290 {
                        _buf[(2290 - _start) as usize] = _value[2];
                    }
                    if _start <= 2291 && _end > 2291 {
                        _buf[(2291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1342177280;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1284..=1311, 1285..=1312) => {
                if _start < 1288 && _end > 1284 {
                    let offset = 1284u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1284u64) as usize;
                    let end =
                        (_end.saturating_sub(1284u64) as usize).min(start + 4);
                    self.write_gpio_out(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = 1288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1288u64) as usize;
                    let end =
                        (_end.saturating_sub(1288u64) as usize).min(start + 4);
                    self.write_gpio_outset(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = 1292u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1292u64) as usize;
                    let end =
                        (_end.saturating_sub(1292u64) as usize).min(start + 4);
                    self.write_gpio_outclr(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1304 && _end > 1300 {
                    let offset = 1300u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1300u64) as usize;
                    let end =
                        (_end.saturating_sub(1300u64) as usize).min(start + 4);
                    self.write_gpio_dir(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = 1304u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1304u64) as usize;
                    let end =
                        (_end.saturating_sub(1304u64) as usize).min(start + 4);
                    self.write_gpio_dirset(offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    let offset = 1308u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1308u64) as usize;
                    let end =
                        (_end.saturating_sub(1308u64) as usize).min(start + 4);
                    self.write_gpio_dirclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1792..=1919, 1793..=1920) => {
                if _start < 1796 && _end > 1792 {
                    let offset = 1792u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1792u64) as usize;
                    let end =
                        (_end.saturating_sub(1792u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(0, offset, &_buf[start..end])?;
                }
                if _start < 1812 && _end > 1808 {
                    let offset = 1808u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1808u64) as usize;
                    let end =
                        (_end.saturating_sub(1808u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(1, offset, &_buf[start..end])?;
                }
                if _start < 1828 && _end > 1824 {
                    let offset = 1824u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1824u64) as usize;
                    let end =
                        (_end.saturating_sub(1824u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(2, offset, &_buf[start..end])?;
                }
                if _start < 1844 && _end > 1840 {
                    let offset = 1840u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1840u64) as usize;
                    let end =
                        (_end.saturating_sub(1840u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(3, offset, &_buf[start..end])?;
                }
                if _start < 1860 && _end > 1856 {
                    let offset = 1856u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1856u64) as usize;
                    let end =
                        (_end.saturating_sub(1856u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(4, offset, &_buf[start..end])?;
                }
                if _start < 1876 && _end > 1872 {
                    let offset = 1872u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1872u64) as usize;
                    let end =
                        (_end.saturating_sub(1872u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(5, offset, &_buf[start..end])?;
                }
                if _start < 1892 && _end > 1888 {
                    let offset = 1888u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1888u64) as usize;
                    let end =
                        (_end.saturating_sub(1888u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(6, offset, &_buf[start..end])?;
                }
                if _start < 1908 && _end > 1904 {
                    let offset = 1904u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1904u64) as usize;
                    let end =
                        (_end.saturating_sub(1904u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(7, offset, &_buf[start..end])?;
                }
                if _start < 1924 && _end > 1920 {
                    let offset = 1920u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1920u64) as usize;
                    let end =
                        (_end.saturating_sub(1920u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(8, offset, &_buf[start..end])?;
                }
                if _start < 1940 && _end > 1936 {
                    let offset = 1936u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1936u64) as usize;
                    let end =
                        (_end.saturating_sub(1936u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(9, offset, &_buf[start..end])?;
                }
                if _start < 1956 && _end > 1952 {
                    let offset = 1952u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1952u64) as usize;
                    let end =
                        (_end.saturating_sub(1952u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(10, offset, &_buf[start..end])?;
                }
                if _start < 1972 && _end > 1968 {
                    let offset = 1968u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1968u64) as usize;
                    let end =
                        (_end.saturating_sub(1968u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(11, offset, &_buf[start..end])?;
                }
                if _start < 1988 && _end > 1984 {
                    let offset = 1984u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1984u64) as usize;
                    let end =
                        (_end.saturating_sub(1984u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(12, offset, &_buf[start..end])?;
                }
                if _start < 2004 && _end > 2000 {
                    let offset = 2000u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2000u64) as usize;
                    let end =
                        (_end.saturating_sub(2000u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(13, offset, &_buf[start..end])?;
                }
                if _start < 2020 && _end > 2016 {
                    let offset = 2016u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2016u64) as usize;
                    let end =
                        (_end.saturating_sub(2016u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(14, offset, &_buf[start..end])?;
                }
                if _start < 2036 && _end > 2032 {
                    let offset = 2032u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2032u64) as usize;
                    let end =
                        (_end.saturating_sub(2032u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(15, offset, &_buf[start..end])?;
                }
                if _start < 2052 && _end > 2048 {
                    let offset = 2048u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2048u64) as usize;
                    let end =
                        (_end.saturating_sub(2048u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(16, offset, &_buf[start..end])?;
                }
                if _start < 2068 && _end > 2064 {
                    let offset = 2064u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2064u64) as usize;
                    let end =
                        (_end.saturating_sub(2064u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(17, offset, &_buf[start..end])?;
                }
                if _start < 2084 && _end > 2080 {
                    let offset = 2080u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2080u64) as usize;
                    let end =
                        (_end.saturating_sub(2080u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(18, offset, &_buf[start..end])?;
                }
                if _start < 2100 && _end > 2096 {
                    let offset = 2096u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2096u64) as usize;
                    let end =
                        (_end.saturating_sub(2096u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(19, offset, &_buf[start..end])?;
                }
                if _start < 2116 && _end > 2112 {
                    let offset = 2112u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2112u64) as usize;
                    let end =
                        (_end.saturating_sub(2112u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(20, offset, &_buf[start..end])?;
                }
                if _start < 2132 && _end > 2128 {
                    let offset = 2128u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2128u64) as usize;
                    let end =
                        (_end.saturating_sub(2128u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(21, offset, &_buf[start..end])?;
                }
                if _start < 2148 && _end > 2144 {
                    let offset = 2144u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2144u64) as usize;
                    let end =
                        (_end.saturating_sub(2144u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(22, offset, &_buf[start..end])?;
                }
                if _start < 2164 && _end > 2160 {
                    let offset = 2160u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2160u64) as usize;
                    let end =
                        (_end.saturating_sub(2160u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(23, offset, &_buf[start..end])?;
                }
                if _start < 2180 && _end > 2176 {
                    let offset = 2176u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2176u64) as usize;
                    let end =
                        (_end.saturating_sub(2176u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(24, offset, &_buf[start..end])?;
                }
                if _start < 2196 && _end > 2192 {
                    let offset = 2192u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2192u64) as usize;
                    let end =
                        (_end.saturating_sub(2192u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(25, offset, &_buf[start..end])?;
                }
                if _start < 2212 && _end > 2208 {
                    let offset = 2208u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2208u64) as usize;
                    let end =
                        (_end.saturating_sub(2208u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(26, offset, &_buf[start..end])?;
                }
                if _start < 2228 && _end > 2224 {
                    let offset = 2224u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2224u64) as usize;
                    let end =
                        (_end.saturating_sub(2224u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(27, offset, &_buf[start..end])?;
                }
                if _start < 2244 && _end > 2240 {
                    let offset = 2240u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2240u64) as usize;
                    let end =
                        (_end.saturating_sub(2240u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(28, offset, &_buf[start..end])?;
                }
                if _start < 2260 && _end > 2256 {
                    let offset = 2256u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2256u64) as usize;
                    let end =
                        (_end.saturating_sub(2256u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(29, offset, &_buf[start..end])?;
                }
                if _start < 2276 && _end > 2272 {
                    let offset = 2272u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2272u64) as usize;
                    let end =
                        (_end.saturating_sub(2272u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(30, offset, &_buf[start..end])?;
                }
                if _start < 2292 && _end > 2288 {
                    let offset = 2288u64.saturating_sub(_start);
                    let start = _start.saturating_sub(2288u64) as usize;
                    let end =
                        (_end.saturating_sub(2288u64) as usize).min(start + 4);
                    self.write_gpio_pin_cnfn(31, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x50000000 {
    fn read_gpio_out(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_out_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_gpio_out(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_out_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpio_outset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outset_pin9()?) << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin10()?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin11()?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin12()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin13()?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin14()?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin15()?)
            << 15u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin16()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin17()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin18()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin19()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin20()?)
            << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin21()?)
            << 21u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin22()?)
            << 22u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin23()?)
            << 23u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin24()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin25()?)
            << 25u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin26()?)
            << 26u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin27()?)
            << 27u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin28()?)
            << 28u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin29()?)
            << 29u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin30()?)
            << 30u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outset_pin31()?)
            << 31u32;
        Ok(_value)
    }
    fn write_gpio_outset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outset_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpio_outclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_outclr_pin9()?) << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin10()?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin11()?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin12()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin13()?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin14()?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin15()?)
            << 15u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin16()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin17()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin18()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin19()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin20()?)
            << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin21()?)
            << 21u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin22()?)
            << 22u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin23()?)
            << 23u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin24()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin25()?)
            << 25u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin26()?)
            << 26u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin27()?)
            << 27u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin28()?)
            << 28u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin29()?)
            << 29u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin30()?)
            << 30u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_outclr_pin31()?)
            << 31u32;
        Ok(_value)
    }
    fn write_gpio_outclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_outclr_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpio_in(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_in_pin31()?) << 31u32;
        Ok(_value)
    }
    fn read_gpio_dir(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dir_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_gpio_dir(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dir_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpio_dirset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirset_pin9()?) << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin10()?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin11()?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin12()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin13()?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin14()?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin15()?)
            << 15u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin16()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin17()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin18()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin19()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin20()?)
            << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin21()?)
            << 21u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin22()?)
            << 22u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin23()?)
            << 23u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin24()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin25()?)
            << 25u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin26()?)
            << 26u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin27()?)
            << 27u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin28()?)
            << 28u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin29()?)
            << 29u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin30()?)
            << 30u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirset_pin31()?)
            << 31u32;
        Ok(_value)
    }
    fn write_gpio_dirset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirset_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpio_dirclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin9()?) << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin10()?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin11()?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin12()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin13()?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin14()?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin15()?)
            << 15u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin16()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin17()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin18()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin19()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin20()?)
            << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin21()?)
            << 21u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin22()?)
            << 22u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin23()?)
            << 23u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin24()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin25()?)
            << 25u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin26()?)
            << 26u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin27()?)
            << 27u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin28()?)
            << 28u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin29()?)
            << 29u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin30()?)
            << 30u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpio_dirclr_pin31()?)
            << 31u32;
        Ok(_value)
    }
    fn write_gpio_dirclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_dirclr_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpio_pin_cnfn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_pin_cnfn_dir(_dim)?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_pin_cnfn_input(_dim)?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_pin_cnfn_pull(_dim)?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_pin_cnfn_drive(_dim)?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpio_pin_cnfn_sense(_dim)?)
                << 16u32;
        Ok(_value)
    }
    fn write_gpio_pin_cnfn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_pin_cnfn_dir(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_pin_cnfn_input(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_pin_cnfn_pull(_dim, (_value[_i] >> 2) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_pin_cnfn_drive(_dim, (_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpio_pin_cnfn_sense(_dim, (_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0xE000E000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0xE000E000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 3758153728;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=11, 5..=12) => {
                if _start < 12 && _end > 8 {
                    let _value = self.read_control_actlr()?.to_ne_bytes();
                    if _start <= 8 && _end > 8 {
                        _buf[(8 - _start) as usize] = _value[0];
                    }
                    if _start <= 9 && _end > 9 {
                        _buf[(9 - _start) as usize] = _value[1];
                    }
                    if _start <= 10 && _end > 10 {
                        _buf[(10 - _start) as usize] = _value[2];
                    }
                    if _start <= 11 && _end > 11 {
                        _buf[(11 - _start) as usize] = _value[3];
                    }
                }
                if _start < 8 && _end > 4 {
                    let _value = self.read_nvic_ictr()?.to_ne_bytes();
                    if _start <= 4 && _end > 4 {
                        _buf[(4 - _start) as usize] = _value[0];
                    }
                    if _start <= 5 && _end > 5 {
                        _buf[(5 - _start) as usize] = _value[1];
                    }
                    if _start <= 6 && _end > 6 {
                        _buf[(6 - _start) as usize] = _value[2];
                    }
                    if _start <= 7 && _end > 7 {
                        _buf[(7 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (16..=31, 17..=32) => {
                if _start < 20 && _end > 16 {
                    let _value = self.read_systick_stcsr()?.to_ne_bytes();
                    if _start <= 16 && _end > 16 {
                        _buf[(16 - _start) as usize] = _value[0];
                    }
                    if _start <= 17 && _end > 17 {
                        _buf[(17 - _start) as usize] = _value[1];
                    }
                    if _start <= 18 && _end > 18 {
                        _buf[(18 - _start) as usize] = _value[2];
                    }
                    if _start <= 19 && _end > 19 {
                        _buf[(19 - _start) as usize] = _value[3];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _value = self.read_systick_strvr()?.to_ne_bytes();
                    if _start <= 20 && _end > 20 {
                        _buf[(20 - _start) as usize] = _value[0];
                    }
                    if _start <= 21 && _end > 21 {
                        _buf[(21 - _start) as usize] = _value[1];
                    }
                    if _start <= 22 && _end > 22 {
                        _buf[(22 - _start) as usize] = _value[2];
                    }
                    if _start <= 23 && _end > 23 {
                        _buf[(23 - _start) as usize] = _value[3];
                    }
                }
                if _start < 28 && _end > 24 {
                    let _value = self.read_systick_stcvr()?.to_ne_bytes();
                    if _start <= 24 && _end > 24 {
                        _buf[(24 - _start) as usize] = _value[0];
                    }
                    if _start <= 25 && _end > 25 {
                        _buf[(25 - _start) as usize] = _value[1];
                    }
                    if _start <= 26 && _end > 26 {
                        _buf[(26 - _start) as usize] = _value[2];
                    }
                    if _start <= 27 && _end > 27 {
                        _buf[(27 - _start) as usize] = _value[3];
                    }
                }
                if _start < 32 && _end > 28 {
                    let _value = self.read_systick_stcr()?.to_ne_bytes();
                    if _start <= 28 && _end > 28 {
                        _buf[(28 - _start) as usize] = _value[0];
                    }
                    if _start <= 29 && _end > 29 {
                        _buf[(29 - _start) as usize] = _value[1];
                    }
                    if _start <= 30 && _end > 30 {
                        _buf[(30 - _start) as usize] = _value[2];
                    }
                    if _start <= 31 && _end > 31 {
                        _buf[(31 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser0()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser1()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser2()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser3()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser4()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser5()?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser6()?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser7()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (384..=415, 385..=416) => {
                if _start < 388 && _end > 384 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer0()?
                        .to_ne_bytes();
                    if _start <= 384 && _end > 384 {
                        _buf[(384 - _start) as usize] = _value[0];
                    }
                    if _start <= 385 && _end > 385 {
                        _buf[(385 - _start) as usize] = _value[1];
                    }
                    if _start <= 386 && _end > 386 {
                        _buf[(386 - _start) as usize] = _value[2];
                    }
                    if _start <= 387 && _end > 387 {
                        _buf[(387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 392 && _end > 388 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer1()?
                        .to_ne_bytes();
                    if _start <= 388 && _end > 388 {
                        _buf[(388 - _start) as usize] = _value[0];
                    }
                    if _start <= 389 && _end > 389 {
                        _buf[(389 - _start) as usize] = _value[1];
                    }
                    if _start <= 390 && _end > 390 {
                        _buf[(390 - _start) as usize] = _value[2];
                    }
                    if _start <= 391 && _end > 391 {
                        _buf[(391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 396 && _end > 392 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer2()?
                        .to_ne_bytes();
                    if _start <= 392 && _end > 392 {
                        _buf[(392 - _start) as usize] = _value[0];
                    }
                    if _start <= 393 && _end > 393 {
                        _buf[(393 - _start) as usize] = _value[1];
                    }
                    if _start <= 394 && _end > 394 {
                        _buf[(394 - _start) as usize] = _value[2];
                    }
                    if _start <= 395 && _end > 395 {
                        _buf[(395 - _start) as usize] = _value[3];
                    }
                }
                if _start < 400 && _end > 396 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer3()?
                        .to_ne_bytes();
                    if _start <= 396 && _end > 396 {
                        _buf[(396 - _start) as usize] = _value[0];
                    }
                    if _start <= 397 && _end > 397 {
                        _buf[(397 - _start) as usize] = _value[1];
                    }
                    if _start <= 398 && _end > 398 {
                        _buf[(398 - _start) as usize] = _value[2];
                    }
                    if _start <= 399 && _end > 399 {
                        _buf[(399 - _start) as usize] = _value[3];
                    }
                }
                if _start < 404 && _end > 400 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer4()?
                        .to_ne_bytes();
                    if _start <= 400 && _end > 400 {
                        _buf[(400 - _start) as usize] = _value[0];
                    }
                    if _start <= 401 && _end > 401 {
                        _buf[(401 - _start) as usize] = _value[1];
                    }
                    if _start <= 402 && _end > 402 {
                        _buf[(402 - _start) as usize] = _value[2];
                    }
                    if _start <= 403 && _end > 403 {
                        _buf[(403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 408 && _end > 404 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer5()?
                        .to_ne_bytes();
                    if _start <= 404 && _end > 404 {
                        _buf[(404 - _start) as usize] = _value[0];
                    }
                    if _start <= 405 && _end > 405 {
                        _buf[(405 - _start) as usize] = _value[1];
                    }
                    if _start <= 406 && _end > 406 {
                        _buf[(406 - _start) as usize] = _value[2];
                    }
                    if _start <= 407 && _end > 407 {
                        _buf[(407 - _start) as usize] = _value[3];
                    }
                }
                if _start < 412 && _end > 408 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer6()?
                        .to_ne_bytes();
                    if _start <= 408 && _end > 408 {
                        _buf[(408 - _start) as usize] = _value[0];
                    }
                    if _start <= 409 && _end > 409 {
                        _buf[(409 - _start) as usize] = _value[1];
                    }
                    if _start <= 410 && _end > 410 {
                        _buf[(410 - _start) as usize] = _value[2];
                    }
                    if _start <= 411 && _end > 411 {
                        _buf[(411 - _start) as usize] = _value[3];
                    }
                }
                if _start < 416 && _end > 412 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer7()?
                        .to_ne_bytes();
                    if _start <= 412 && _end > 412 {
                        _buf[(412 - _start) as usize] = _value[0];
                    }
                    if _start <= 413 && _end > 413 {
                        _buf[(413 - _start) as usize] = _value[1];
                    }
                    if _start <= 414 && _end > 414 {
                        _buf[(414 - _start) as usize] = _value[2];
                    }
                    if _start <= 415 && _end > 415 {
                        _buf[(415 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=543, 513..=544) => {
                if _start < 516 && _end > 512 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr0()?
                        .to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                if _start < 520 && _end > 516 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr1()?
                        .to_ne_bytes();
                    if _start <= 516 && _end > 516 {
                        _buf[(516 - _start) as usize] = _value[0];
                    }
                    if _start <= 517 && _end > 517 {
                        _buf[(517 - _start) as usize] = _value[1];
                    }
                    if _start <= 518 && _end > 518 {
                        _buf[(518 - _start) as usize] = _value[2];
                    }
                    if _start <= 519 && _end > 519 {
                        _buf[(519 - _start) as usize] = _value[3];
                    }
                }
                if _start < 524 && _end > 520 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr2()?
                        .to_ne_bytes();
                    if _start <= 520 && _end > 520 {
                        _buf[(520 - _start) as usize] = _value[0];
                    }
                    if _start <= 521 && _end > 521 {
                        _buf[(521 - _start) as usize] = _value[1];
                    }
                    if _start <= 522 && _end > 522 {
                        _buf[(522 - _start) as usize] = _value[2];
                    }
                    if _start <= 523 && _end > 523 {
                        _buf[(523 - _start) as usize] = _value[3];
                    }
                }
                if _start < 528 && _end > 524 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr3()?
                        .to_ne_bytes();
                    if _start <= 524 && _end > 524 {
                        _buf[(524 - _start) as usize] = _value[0];
                    }
                    if _start <= 525 && _end > 525 {
                        _buf[(525 - _start) as usize] = _value[1];
                    }
                    if _start <= 526 && _end > 526 {
                        _buf[(526 - _start) as usize] = _value[2];
                    }
                    if _start <= 527 && _end > 527 {
                        _buf[(527 - _start) as usize] = _value[3];
                    }
                }
                if _start < 532 && _end > 528 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr4()?
                        .to_ne_bytes();
                    if _start <= 528 && _end > 528 {
                        _buf[(528 - _start) as usize] = _value[0];
                    }
                    if _start <= 529 && _end > 529 {
                        _buf[(529 - _start) as usize] = _value[1];
                    }
                    if _start <= 530 && _end > 530 {
                        _buf[(530 - _start) as usize] = _value[2];
                    }
                    if _start <= 531 && _end > 531 {
                        _buf[(531 - _start) as usize] = _value[3];
                    }
                }
                if _start < 536 && _end > 532 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr5()?
                        .to_ne_bytes();
                    if _start <= 532 && _end > 532 {
                        _buf[(532 - _start) as usize] = _value[0];
                    }
                    if _start <= 533 && _end > 533 {
                        _buf[(533 - _start) as usize] = _value[1];
                    }
                    if _start <= 534 && _end > 534 {
                        _buf[(534 - _start) as usize] = _value[2];
                    }
                    if _start <= 535 && _end > 535 {
                        _buf[(535 - _start) as usize] = _value[3];
                    }
                }
                if _start < 540 && _end > 536 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr6()?
                        .to_ne_bytes();
                    if _start <= 536 && _end > 536 {
                        _buf[(536 - _start) as usize] = _value[0];
                    }
                    if _start <= 537 && _end > 537 {
                        _buf[(537 - _start) as usize] = _value[1];
                    }
                    if _start <= 538 && _end > 538 {
                        _buf[(538 - _start) as usize] = _value[2];
                    }
                    if _start <= 539 && _end > 539 {
                        _buf[(539 - _start) as usize] = _value[3];
                    }
                }
                if _start < 544 && _end > 540 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr7()?
                        .to_ne_bytes();
                    if _start <= 540 && _end > 540 {
                        _buf[(540 - _start) as usize] = _value[0];
                    }
                    if _start <= 541 && _end > 541 {
                        _buf[(541 - _start) as usize] = _value[1];
                    }
                    if _start <= 542 && _end > 542 {
                        _buf[(542 - _start) as usize] = _value[2];
                    }
                    if _start <= 543 && _end > 543 {
                        _buf[(543 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (640..=671, 641..=672) => {
                if _start < 644 && _end > 640 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr0()?
                        .to_ne_bytes();
                    if _start <= 640 && _end > 640 {
                        _buf[(640 - _start) as usize] = _value[0];
                    }
                    if _start <= 641 && _end > 641 {
                        _buf[(641 - _start) as usize] = _value[1];
                    }
                    if _start <= 642 && _end > 642 {
                        _buf[(642 - _start) as usize] = _value[2];
                    }
                    if _start <= 643 && _end > 643 {
                        _buf[(643 - _start) as usize] = _value[3];
                    }
                }
                if _start < 648 && _end > 644 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr1()?
                        .to_ne_bytes();
                    if _start <= 644 && _end > 644 {
                        _buf[(644 - _start) as usize] = _value[0];
                    }
                    if _start <= 645 && _end > 645 {
                        _buf[(645 - _start) as usize] = _value[1];
                    }
                    if _start <= 646 && _end > 646 {
                        _buf[(646 - _start) as usize] = _value[2];
                    }
                    if _start <= 647 && _end > 647 {
                        _buf[(647 - _start) as usize] = _value[3];
                    }
                }
                if _start < 652 && _end > 648 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr2()?
                        .to_ne_bytes();
                    if _start <= 648 && _end > 648 {
                        _buf[(648 - _start) as usize] = _value[0];
                    }
                    if _start <= 649 && _end > 649 {
                        _buf[(649 - _start) as usize] = _value[1];
                    }
                    if _start <= 650 && _end > 650 {
                        _buf[(650 - _start) as usize] = _value[2];
                    }
                    if _start <= 651 && _end > 651 {
                        _buf[(651 - _start) as usize] = _value[3];
                    }
                }
                if _start < 656 && _end > 652 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr3()?
                        .to_ne_bytes();
                    if _start <= 652 && _end > 652 {
                        _buf[(652 - _start) as usize] = _value[0];
                    }
                    if _start <= 653 && _end > 653 {
                        _buf[(653 - _start) as usize] = _value[1];
                    }
                    if _start <= 654 && _end > 654 {
                        _buf[(654 - _start) as usize] = _value[2];
                    }
                    if _start <= 655 && _end > 655 {
                        _buf[(655 - _start) as usize] = _value[3];
                    }
                }
                if _start < 660 && _end > 656 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr4()?
                        .to_ne_bytes();
                    if _start <= 656 && _end > 656 {
                        _buf[(656 - _start) as usize] = _value[0];
                    }
                    if _start <= 657 && _end > 657 {
                        _buf[(657 - _start) as usize] = _value[1];
                    }
                    if _start <= 658 && _end > 658 {
                        _buf[(658 - _start) as usize] = _value[2];
                    }
                    if _start <= 659 && _end > 659 {
                        _buf[(659 - _start) as usize] = _value[3];
                    }
                }
                if _start < 664 && _end > 660 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr5()?
                        .to_ne_bytes();
                    if _start <= 660 && _end > 660 {
                        _buf[(660 - _start) as usize] = _value[0];
                    }
                    if _start <= 661 && _end > 661 {
                        _buf[(661 - _start) as usize] = _value[1];
                    }
                    if _start <= 662 && _end > 662 {
                        _buf[(662 - _start) as usize] = _value[2];
                    }
                    if _start <= 663 && _end > 663 {
                        _buf[(663 - _start) as usize] = _value[3];
                    }
                }
                if _start < 668 && _end > 664 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr6()?
                        .to_ne_bytes();
                    if _start <= 664 && _end > 664 {
                        _buf[(664 - _start) as usize] = _value[0];
                    }
                    if _start <= 665 && _end > 665 {
                        _buf[(665 - _start) as usize] = _value[1];
                    }
                    if _start <= 666 && _end > 666 {
                        _buf[(666 - _start) as usize] = _value[2];
                    }
                    if _start <= 667 && _end > 667 {
                        _buf[(667 - _start) as usize] = _value[3];
                    }
                }
                if _start < 672 && _end > 668 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr7()?
                        .to_ne_bytes();
                    if _start <= 668 && _end > 668 {
                        _buf[(668 - _start) as usize] = _value[0];
                    }
                    if _start <= 669 && _end > 669 {
                        _buf[(669 - _start) as usize] = _value[1];
                    }
                    if _start <= 670 && _end > 670 {
                        _buf[(670 - _start) as usize] = _value[2];
                    }
                    if _start <= 671 && _end > 671 {
                        _buf[(671 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=799, 769..=800) => {
                if _start < 772 && _end > 768 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr0()?
                        .to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr1()?
                        .to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr2()?
                        .to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                if _start < 784 && _end > 780 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr3()?
                        .to_ne_bytes();
                    if _start <= 780 && _end > 780 {
                        _buf[(780 - _start) as usize] = _value[0];
                    }
                    if _start <= 781 && _end > 781 {
                        _buf[(781 - _start) as usize] = _value[1];
                    }
                    if _start <= 782 && _end > 782 {
                        _buf[(782 - _start) as usize] = _value[2];
                    }
                    if _start <= 783 && _end > 783 {
                        _buf[(783 - _start) as usize] = _value[3];
                    }
                }
                if _start < 788 && _end > 784 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr4()?
                        .to_ne_bytes();
                    if _start <= 784 && _end > 784 {
                        _buf[(784 - _start) as usize] = _value[0];
                    }
                    if _start <= 785 && _end > 785 {
                        _buf[(785 - _start) as usize] = _value[1];
                    }
                    if _start <= 786 && _end > 786 {
                        _buf[(786 - _start) as usize] = _value[2];
                    }
                    if _start <= 787 && _end > 787 {
                        _buf[(787 - _start) as usize] = _value[3];
                    }
                }
                if _start < 792 && _end > 788 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr5()?
                        .to_ne_bytes();
                    if _start <= 788 && _end > 788 {
                        _buf[(788 - _start) as usize] = _value[0];
                    }
                    if _start <= 789 && _end > 789 {
                        _buf[(789 - _start) as usize] = _value[1];
                    }
                    if _start <= 790 && _end > 790 {
                        _buf[(790 - _start) as usize] = _value[2];
                    }
                    if _start <= 791 && _end > 791 {
                        _buf[(791 - _start) as usize] = _value[3];
                    }
                }
                if _start < 796 && _end > 792 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr6()?
                        .to_ne_bytes();
                    if _start <= 792 && _end > 792 {
                        _buf[(792 - _start) as usize] = _value[0];
                    }
                    if _start <= 793 && _end > 793 {
                        _buf[(793 - _start) as usize] = _value[1];
                    }
                    if _start <= 794 && _end > 794 {
                        _buf[(794 - _start) as usize] = _value[2];
                    }
                    if _start <= 795 && _end > 795 {
                        _buf[(795 - _start) as usize] = _value[3];
                    }
                }
                if _start < 800 && _end > 796 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr7()?
                        .to_ne_bytes();
                    if _start <= 796 && _end > 796 {
                        _buf[(796 - _start) as usize] = _value[0];
                    }
                    if _start <= 797 && _end > 797 {
                        _buf[(797 - _start) as usize] = _value[1];
                    }
                    if _start <= 798 && _end > 798 {
                        _buf[(798 - _start) as usize] = _value[2];
                    }
                    if _start <= 799 && _end > 799 {
                        _buf[(799 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1263, 1025..=1264) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_nvic_nvic_ipr0()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1032 && _end > 1028 {
                    let _value = self.read_nvic_nvic_ipr1()?.to_ne_bytes();
                    if _start <= 1028 && _end > 1028 {
                        _buf[(1028 - _start) as usize] = _value[0];
                    }
                    if _start <= 1029 && _end > 1029 {
                        _buf[(1029 - _start) as usize] = _value[1];
                    }
                    if _start <= 1030 && _end > 1030 {
                        _buf[(1030 - _start) as usize] = _value[2];
                    }
                    if _start <= 1031 && _end > 1031 {
                        _buf[(1031 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1036 && _end > 1032 {
                    let _value = self.read_nvic_nvic_ipr2()?.to_ne_bytes();
                    if _start <= 1032 && _end > 1032 {
                        _buf[(1032 - _start) as usize] = _value[0];
                    }
                    if _start <= 1033 && _end > 1033 {
                        _buf[(1033 - _start) as usize] = _value[1];
                    }
                    if _start <= 1034 && _end > 1034 {
                        _buf[(1034 - _start) as usize] = _value[2];
                    }
                    if _start <= 1035 && _end > 1035 {
                        _buf[(1035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _value = self.read_nvic_nvic_ipr3()?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1044 && _end > 1040 {
                    let _value = self.read_nvic_nvic_ipr4()?.to_ne_bytes();
                    if _start <= 1040 && _end > 1040 {
                        _buf[(1040 - _start) as usize] = _value[0];
                    }
                    if _start <= 1041 && _end > 1041 {
                        _buf[(1041 - _start) as usize] = _value[1];
                    }
                    if _start <= 1042 && _end > 1042 {
                        _buf[(1042 - _start) as usize] = _value[2];
                    }
                    if _start <= 1043 && _end > 1043 {
                        _buf[(1043 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1048 && _end > 1044 {
                    let _value = self.read_nvic_nvic_ipr5()?.to_ne_bytes();
                    if _start <= 1044 && _end > 1044 {
                        _buf[(1044 - _start) as usize] = _value[0];
                    }
                    if _start <= 1045 && _end > 1045 {
                        _buf[(1045 - _start) as usize] = _value[1];
                    }
                    if _start <= 1046 && _end > 1046 {
                        _buf[(1046 - _start) as usize] = _value[2];
                    }
                    if _start <= 1047 && _end > 1047 {
                        _buf[(1047 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1052 && _end > 1048 {
                    let _value = self.read_nvic_nvic_ipr6()?.to_ne_bytes();
                    if _start <= 1048 && _end > 1048 {
                        _buf[(1048 - _start) as usize] = _value[0];
                    }
                    if _start <= 1049 && _end > 1049 {
                        _buf[(1049 - _start) as usize] = _value[1];
                    }
                    if _start <= 1050 && _end > 1050 {
                        _buf[(1050 - _start) as usize] = _value[2];
                    }
                    if _start <= 1051 && _end > 1051 {
                        _buf[(1051 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1056 && _end > 1052 {
                    let _value = self.read_nvic_nvic_ipr7()?.to_ne_bytes();
                    if _start <= 1052 && _end > 1052 {
                        _buf[(1052 - _start) as usize] = _value[0];
                    }
                    if _start <= 1053 && _end > 1053 {
                        _buf[(1053 - _start) as usize] = _value[1];
                    }
                    if _start <= 1054 && _end > 1054 {
                        _buf[(1054 - _start) as usize] = _value[2];
                    }
                    if _start <= 1055 && _end > 1055 {
                        _buf[(1055 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1060 && _end > 1056 {
                    let _value = self.read_nvic_nvic_ipr8()?.to_ne_bytes();
                    if _start <= 1056 && _end > 1056 {
                        _buf[(1056 - _start) as usize] = _value[0];
                    }
                    if _start <= 1057 && _end > 1057 {
                        _buf[(1057 - _start) as usize] = _value[1];
                    }
                    if _start <= 1058 && _end > 1058 {
                        _buf[(1058 - _start) as usize] = _value[2];
                    }
                    if _start <= 1059 && _end > 1059 {
                        _buf[(1059 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1064 && _end > 1060 {
                    let _value = self.read_nvic_nvic_ipr9()?.to_ne_bytes();
                    if _start <= 1060 && _end > 1060 {
                        _buf[(1060 - _start) as usize] = _value[0];
                    }
                    if _start <= 1061 && _end > 1061 {
                        _buf[(1061 - _start) as usize] = _value[1];
                    }
                    if _start <= 1062 && _end > 1062 {
                        _buf[(1062 - _start) as usize] = _value[2];
                    }
                    if _start <= 1063 && _end > 1063 {
                        _buf[(1063 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1068 && _end > 1064 {
                    let _value = self.read_nvic_nvic_ipr10()?.to_ne_bytes();
                    if _start <= 1064 && _end > 1064 {
                        _buf[(1064 - _start) as usize] = _value[0];
                    }
                    if _start <= 1065 && _end > 1065 {
                        _buf[(1065 - _start) as usize] = _value[1];
                    }
                    if _start <= 1066 && _end > 1066 {
                        _buf[(1066 - _start) as usize] = _value[2];
                    }
                    if _start <= 1067 && _end > 1067 {
                        _buf[(1067 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1072 && _end > 1068 {
                    let _value = self.read_nvic_nvic_ipr11()?.to_ne_bytes();
                    if _start <= 1068 && _end > 1068 {
                        _buf[(1068 - _start) as usize] = _value[0];
                    }
                    if _start <= 1069 && _end > 1069 {
                        _buf[(1069 - _start) as usize] = _value[1];
                    }
                    if _start <= 1070 && _end > 1070 {
                        _buf[(1070 - _start) as usize] = _value[2];
                    }
                    if _start <= 1071 && _end > 1071 {
                        _buf[(1071 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1076 && _end > 1072 {
                    let _value = self.read_nvic_nvic_ipr12()?.to_ne_bytes();
                    if _start <= 1072 && _end > 1072 {
                        _buf[(1072 - _start) as usize] = _value[0];
                    }
                    if _start <= 1073 && _end > 1073 {
                        _buf[(1073 - _start) as usize] = _value[1];
                    }
                    if _start <= 1074 && _end > 1074 {
                        _buf[(1074 - _start) as usize] = _value[2];
                    }
                    if _start <= 1075 && _end > 1075 {
                        _buf[(1075 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1080 && _end > 1076 {
                    let _value = self.read_nvic_nvic_ipr13()?.to_ne_bytes();
                    if _start <= 1076 && _end > 1076 {
                        _buf[(1076 - _start) as usize] = _value[0];
                    }
                    if _start <= 1077 && _end > 1077 {
                        _buf[(1077 - _start) as usize] = _value[1];
                    }
                    if _start <= 1078 && _end > 1078 {
                        _buf[(1078 - _start) as usize] = _value[2];
                    }
                    if _start <= 1079 && _end > 1079 {
                        _buf[(1079 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1084 && _end > 1080 {
                    let _value = self.read_nvic_nvic_ipr14()?.to_ne_bytes();
                    if _start <= 1080 && _end > 1080 {
                        _buf[(1080 - _start) as usize] = _value[0];
                    }
                    if _start <= 1081 && _end > 1081 {
                        _buf[(1081 - _start) as usize] = _value[1];
                    }
                    if _start <= 1082 && _end > 1082 {
                        _buf[(1082 - _start) as usize] = _value[2];
                    }
                    if _start <= 1083 && _end > 1083 {
                        _buf[(1083 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1088 && _end > 1084 {
                    let _value = self.read_nvic_nvic_ipr15()?.to_ne_bytes();
                    if _start <= 1084 && _end > 1084 {
                        _buf[(1084 - _start) as usize] = _value[0];
                    }
                    if _start <= 1085 && _end > 1085 {
                        _buf[(1085 - _start) as usize] = _value[1];
                    }
                    if _start <= 1086 && _end > 1086 {
                        _buf[(1086 - _start) as usize] = _value[2];
                    }
                    if _start <= 1087 && _end > 1087 {
                        _buf[(1087 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1092 && _end > 1088 {
                    let _value = self.read_nvic_nvic_ipr16()?.to_ne_bytes();
                    if _start <= 1088 && _end > 1088 {
                        _buf[(1088 - _start) as usize] = _value[0];
                    }
                    if _start <= 1089 && _end > 1089 {
                        _buf[(1089 - _start) as usize] = _value[1];
                    }
                    if _start <= 1090 && _end > 1090 {
                        _buf[(1090 - _start) as usize] = _value[2];
                    }
                    if _start <= 1091 && _end > 1091 {
                        _buf[(1091 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1096 && _end > 1092 {
                    let _value = self.read_nvic_nvic_ipr17()?.to_ne_bytes();
                    if _start <= 1092 && _end > 1092 {
                        _buf[(1092 - _start) as usize] = _value[0];
                    }
                    if _start <= 1093 && _end > 1093 {
                        _buf[(1093 - _start) as usize] = _value[1];
                    }
                    if _start <= 1094 && _end > 1094 {
                        _buf[(1094 - _start) as usize] = _value[2];
                    }
                    if _start <= 1095 && _end > 1095 {
                        _buf[(1095 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1100 && _end > 1096 {
                    let _value = self.read_nvic_nvic_ipr18()?.to_ne_bytes();
                    if _start <= 1096 && _end > 1096 {
                        _buf[(1096 - _start) as usize] = _value[0];
                    }
                    if _start <= 1097 && _end > 1097 {
                        _buf[(1097 - _start) as usize] = _value[1];
                    }
                    if _start <= 1098 && _end > 1098 {
                        _buf[(1098 - _start) as usize] = _value[2];
                    }
                    if _start <= 1099 && _end > 1099 {
                        _buf[(1099 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1104 && _end > 1100 {
                    let _value = self.read_nvic_nvic_ipr19()?.to_ne_bytes();
                    if _start <= 1100 && _end > 1100 {
                        _buf[(1100 - _start) as usize] = _value[0];
                    }
                    if _start <= 1101 && _end > 1101 {
                        _buf[(1101 - _start) as usize] = _value[1];
                    }
                    if _start <= 1102 && _end > 1102 {
                        _buf[(1102 - _start) as usize] = _value[2];
                    }
                    if _start <= 1103 && _end > 1103 {
                        _buf[(1103 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1108 && _end > 1104 {
                    let _value = self.read_nvic_nvic_ipr20()?.to_ne_bytes();
                    if _start <= 1104 && _end > 1104 {
                        _buf[(1104 - _start) as usize] = _value[0];
                    }
                    if _start <= 1105 && _end > 1105 {
                        _buf[(1105 - _start) as usize] = _value[1];
                    }
                    if _start <= 1106 && _end > 1106 {
                        _buf[(1106 - _start) as usize] = _value[2];
                    }
                    if _start <= 1107 && _end > 1107 {
                        _buf[(1107 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1112 && _end > 1108 {
                    let _value = self.read_nvic_nvic_ipr21()?.to_ne_bytes();
                    if _start <= 1108 && _end > 1108 {
                        _buf[(1108 - _start) as usize] = _value[0];
                    }
                    if _start <= 1109 && _end > 1109 {
                        _buf[(1109 - _start) as usize] = _value[1];
                    }
                    if _start <= 1110 && _end > 1110 {
                        _buf[(1110 - _start) as usize] = _value[2];
                    }
                    if _start <= 1111 && _end > 1111 {
                        _buf[(1111 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1116 && _end > 1112 {
                    let _value = self.read_nvic_nvic_ipr22()?.to_ne_bytes();
                    if _start <= 1112 && _end > 1112 {
                        _buf[(1112 - _start) as usize] = _value[0];
                    }
                    if _start <= 1113 && _end > 1113 {
                        _buf[(1113 - _start) as usize] = _value[1];
                    }
                    if _start <= 1114 && _end > 1114 {
                        _buf[(1114 - _start) as usize] = _value[2];
                    }
                    if _start <= 1115 && _end > 1115 {
                        _buf[(1115 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1120 && _end > 1116 {
                    let _value = self.read_nvic_nvic_ipr23()?.to_ne_bytes();
                    if _start <= 1116 && _end > 1116 {
                        _buf[(1116 - _start) as usize] = _value[0];
                    }
                    if _start <= 1117 && _end > 1117 {
                        _buf[(1117 - _start) as usize] = _value[1];
                    }
                    if _start <= 1118 && _end > 1118 {
                        _buf[(1118 - _start) as usize] = _value[2];
                    }
                    if _start <= 1119 && _end > 1119 {
                        _buf[(1119 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1124 && _end > 1120 {
                    let _value = self.read_nvic_nvic_ipr24()?.to_ne_bytes();
                    if _start <= 1120 && _end > 1120 {
                        _buf[(1120 - _start) as usize] = _value[0];
                    }
                    if _start <= 1121 && _end > 1121 {
                        _buf[(1121 - _start) as usize] = _value[1];
                    }
                    if _start <= 1122 && _end > 1122 {
                        _buf[(1122 - _start) as usize] = _value[2];
                    }
                    if _start <= 1123 && _end > 1123 {
                        _buf[(1123 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1128 && _end > 1124 {
                    let _value = self.read_nvic_nvic_ipr25()?.to_ne_bytes();
                    if _start <= 1124 && _end > 1124 {
                        _buf[(1124 - _start) as usize] = _value[0];
                    }
                    if _start <= 1125 && _end > 1125 {
                        _buf[(1125 - _start) as usize] = _value[1];
                    }
                    if _start <= 1126 && _end > 1126 {
                        _buf[(1126 - _start) as usize] = _value[2];
                    }
                    if _start <= 1127 && _end > 1127 {
                        _buf[(1127 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1132 && _end > 1128 {
                    let _value = self.read_nvic_nvic_ipr26()?.to_ne_bytes();
                    if _start <= 1128 && _end > 1128 {
                        _buf[(1128 - _start) as usize] = _value[0];
                    }
                    if _start <= 1129 && _end > 1129 {
                        _buf[(1129 - _start) as usize] = _value[1];
                    }
                    if _start <= 1130 && _end > 1130 {
                        _buf[(1130 - _start) as usize] = _value[2];
                    }
                    if _start <= 1131 && _end > 1131 {
                        _buf[(1131 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1136 && _end > 1132 {
                    let _value = self.read_nvic_nvic_ipr27()?.to_ne_bytes();
                    if _start <= 1132 && _end > 1132 {
                        _buf[(1132 - _start) as usize] = _value[0];
                    }
                    if _start <= 1133 && _end > 1133 {
                        _buf[(1133 - _start) as usize] = _value[1];
                    }
                    if _start <= 1134 && _end > 1134 {
                        _buf[(1134 - _start) as usize] = _value[2];
                    }
                    if _start <= 1135 && _end > 1135 {
                        _buf[(1135 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1140 && _end > 1136 {
                    let _value = self.read_nvic_nvic_ipr28()?.to_ne_bytes();
                    if _start <= 1136 && _end > 1136 {
                        _buf[(1136 - _start) as usize] = _value[0];
                    }
                    if _start <= 1137 && _end > 1137 {
                        _buf[(1137 - _start) as usize] = _value[1];
                    }
                    if _start <= 1138 && _end > 1138 {
                        _buf[(1138 - _start) as usize] = _value[2];
                    }
                    if _start <= 1139 && _end > 1139 {
                        _buf[(1139 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1144 && _end > 1140 {
                    let _value = self.read_nvic_nvic_ipr29()?.to_ne_bytes();
                    if _start <= 1140 && _end > 1140 {
                        _buf[(1140 - _start) as usize] = _value[0];
                    }
                    if _start <= 1141 && _end > 1141 {
                        _buf[(1141 - _start) as usize] = _value[1];
                    }
                    if _start <= 1142 && _end > 1142 {
                        _buf[(1142 - _start) as usize] = _value[2];
                    }
                    if _start <= 1143 && _end > 1143 {
                        _buf[(1143 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1148 && _end > 1144 {
                    let _value = self.read_nvic_nvic_ipr30()?.to_ne_bytes();
                    if _start <= 1144 && _end > 1144 {
                        _buf[(1144 - _start) as usize] = _value[0];
                    }
                    if _start <= 1145 && _end > 1145 {
                        _buf[(1145 - _start) as usize] = _value[1];
                    }
                    if _start <= 1146 && _end > 1146 {
                        _buf[(1146 - _start) as usize] = _value[2];
                    }
                    if _start <= 1147 && _end > 1147 {
                        _buf[(1147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1152 && _end > 1148 {
                    let _value = self.read_nvic_nvic_ipr31()?.to_ne_bytes();
                    if _start <= 1148 && _end > 1148 {
                        _buf[(1148 - _start) as usize] = _value[0];
                    }
                    if _start <= 1149 && _end > 1149 {
                        _buf[(1149 - _start) as usize] = _value[1];
                    }
                    if _start <= 1150 && _end > 1150 {
                        _buf[(1150 - _start) as usize] = _value[2];
                    }
                    if _start <= 1151 && _end > 1151 {
                        _buf[(1151 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1156 && _end > 1152 {
                    let _value = self.read_nvic_nvic_ipr32()?.to_ne_bytes();
                    if _start <= 1152 && _end > 1152 {
                        _buf[(1152 - _start) as usize] = _value[0];
                    }
                    if _start <= 1153 && _end > 1153 {
                        _buf[(1153 - _start) as usize] = _value[1];
                    }
                    if _start <= 1154 && _end > 1154 {
                        _buf[(1154 - _start) as usize] = _value[2];
                    }
                    if _start <= 1155 && _end > 1155 {
                        _buf[(1155 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1160 && _end > 1156 {
                    let _value = self.read_nvic_nvic_ipr33()?.to_ne_bytes();
                    if _start <= 1156 && _end > 1156 {
                        _buf[(1156 - _start) as usize] = _value[0];
                    }
                    if _start <= 1157 && _end > 1157 {
                        _buf[(1157 - _start) as usize] = _value[1];
                    }
                    if _start <= 1158 && _end > 1158 {
                        _buf[(1158 - _start) as usize] = _value[2];
                    }
                    if _start <= 1159 && _end > 1159 {
                        _buf[(1159 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1164 && _end > 1160 {
                    let _value = self.read_nvic_nvic_ipr34()?.to_ne_bytes();
                    if _start <= 1160 && _end > 1160 {
                        _buf[(1160 - _start) as usize] = _value[0];
                    }
                    if _start <= 1161 && _end > 1161 {
                        _buf[(1161 - _start) as usize] = _value[1];
                    }
                    if _start <= 1162 && _end > 1162 {
                        _buf[(1162 - _start) as usize] = _value[2];
                    }
                    if _start <= 1163 && _end > 1163 {
                        _buf[(1163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1168 && _end > 1164 {
                    let _value = self.read_nvic_nvic_ipr35()?.to_ne_bytes();
                    if _start <= 1164 && _end > 1164 {
                        _buf[(1164 - _start) as usize] = _value[0];
                    }
                    if _start <= 1165 && _end > 1165 {
                        _buf[(1165 - _start) as usize] = _value[1];
                    }
                    if _start <= 1166 && _end > 1166 {
                        _buf[(1166 - _start) as usize] = _value[2];
                    }
                    if _start <= 1167 && _end > 1167 {
                        _buf[(1167 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1172 && _end > 1168 {
                    let _value = self.read_nvic_nvic_ipr36()?.to_ne_bytes();
                    if _start <= 1168 && _end > 1168 {
                        _buf[(1168 - _start) as usize] = _value[0];
                    }
                    if _start <= 1169 && _end > 1169 {
                        _buf[(1169 - _start) as usize] = _value[1];
                    }
                    if _start <= 1170 && _end > 1170 {
                        _buf[(1170 - _start) as usize] = _value[2];
                    }
                    if _start <= 1171 && _end > 1171 {
                        _buf[(1171 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1176 && _end > 1172 {
                    let _value = self.read_nvic_nvic_ipr37()?.to_ne_bytes();
                    if _start <= 1172 && _end > 1172 {
                        _buf[(1172 - _start) as usize] = _value[0];
                    }
                    if _start <= 1173 && _end > 1173 {
                        _buf[(1173 - _start) as usize] = _value[1];
                    }
                    if _start <= 1174 && _end > 1174 {
                        _buf[(1174 - _start) as usize] = _value[2];
                    }
                    if _start <= 1175 && _end > 1175 {
                        _buf[(1175 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1180 && _end > 1176 {
                    let _value = self.read_nvic_nvic_ipr38()?.to_ne_bytes();
                    if _start <= 1176 && _end > 1176 {
                        _buf[(1176 - _start) as usize] = _value[0];
                    }
                    if _start <= 1177 && _end > 1177 {
                        _buf[(1177 - _start) as usize] = _value[1];
                    }
                    if _start <= 1178 && _end > 1178 {
                        _buf[(1178 - _start) as usize] = _value[2];
                    }
                    if _start <= 1179 && _end > 1179 {
                        _buf[(1179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1184 && _end > 1180 {
                    let _value = self.read_nvic_nvic_ipr39()?.to_ne_bytes();
                    if _start <= 1180 && _end > 1180 {
                        _buf[(1180 - _start) as usize] = _value[0];
                    }
                    if _start <= 1181 && _end > 1181 {
                        _buf[(1181 - _start) as usize] = _value[1];
                    }
                    if _start <= 1182 && _end > 1182 {
                        _buf[(1182 - _start) as usize] = _value[2];
                    }
                    if _start <= 1183 && _end > 1183 {
                        _buf[(1183 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1188 && _end > 1184 {
                    let _value = self.read_nvic_nvic_ipr40()?.to_ne_bytes();
                    if _start <= 1184 && _end > 1184 {
                        _buf[(1184 - _start) as usize] = _value[0];
                    }
                    if _start <= 1185 && _end > 1185 {
                        _buf[(1185 - _start) as usize] = _value[1];
                    }
                    if _start <= 1186 && _end > 1186 {
                        _buf[(1186 - _start) as usize] = _value[2];
                    }
                    if _start <= 1187 && _end > 1187 {
                        _buf[(1187 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1192 && _end > 1188 {
                    let _value = self.read_nvic_nvic_ipr41()?.to_ne_bytes();
                    if _start <= 1188 && _end > 1188 {
                        _buf[(1188 - _start) as usize] = _value[0];
                    }
                    if _start <= 1189 && _end > 1189 {
                        _buf[(1189 - _start) as usize] = _value[1];
                    }
                    if _start <= 1190 && _end > 1190 {
                        _buf[(1190 - _start) as usize] = _value[2];
                    }
                    if _start <= 1191 && _end > 1191 {
                        _buf[(1191 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1196 && _end > 1192 {
                    let _value = self.read_nvic_nvic_ipr42()?.to_ne_bytes();
                    if _start <= 1192 && _end > 1192 {
                        _buf[(1192 - _start) as usize] = _value[0];
                    }
                    if _start <= 1193 && _end > 1193 {
                        _buf[(1193 - _start) as usize] = _value[1];
                    }
                    if _start <= 1194 && _end > 1194 {
                        _buf[(1194 - _start) as usize] = _value[2];
                    }
                    if _start <= 1195 && _end > 1195 {
                        _buf[(1195 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1200 && _end > 1196 {
                    let _value = self.read_nvic_nvic_ipr43()?.to_ne_bytes();
                    if _start <= 1196 && _end > 1196 {
                        _buf[(1196 - _start) as usize] = _value[0];
                    }
                    if _start <= 1197 && _end > 1197 {
                        _buf[(1197 - _start) as usize] = _value[1];
                    }
                    if _start <= 1198 && _end > 1198 {
                        _buf[(1198 - _start) as usize] = _value[2];
                    }
                    if _start <= 1199 && _end > 1199 {
                        _buf[(1199 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1204 && _end > 1200 {
                    let _value = self.read_nvic_nvic_ipr44()?.to_ne_bytes();
                    if _start <= 1200 && _end > 1200 {
                        _buf[(1200 - _start) as usize] = _value[0];
                    }
                    if _start <= 1201 && _end > 1201 {
                        _buf[(1201 - _start) as usize] = _value[1];
                    }
                    if _start <= 1202 && _end > 1202 {
                        _buf[(1202 - _start) as usize] = _value[2];
                    }
                    if _start <= 1203 && _end > 1203 {
                        _buf[(1203 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1208 && _end > 1204 {
                    let _value = self.read_nvic_nvic_ipr45()?.to_ne_bytes();
                    if _start <= 1204 && _end > 1204 {
                        _buf[(1204 - _start) as usize] = _value[0];
                    }
                    if _start <= 1205 && _end > 1205 {
                        _buf[(1205 - _start) as usize] = _value[1];
                    }
                    if _start <= 1206 && _end > 1206 {
                        _buf[(1206 - _start) as usize] = _value[2];
                    }
                    if _start <= 1207 && _end > 1207 {
                        _buf[(1207 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1212 && _end > 1208 {
                    let _value = self.read_nvic_nvic_ipr46()?.to_ne_bytes();
                    if _start <= 1208 && _end > 1208 {
                        _buf[(1208 - _start) as usize] = _value[0];
                    }
                    if _start <= 1209 && _end > 1209 {
                        _buf[(1209 - _start) as usize] = _value[1];
                    }
                    if _start <= 1210 && _end > 1210 {
                        _buf[(1210 - _start) as usize] = _value[2];
                    }
                    if _start <= 1211 && _end > 1211 {
                        _buf[(1211 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1216 && _end > 1212 {
                    let _value = self.read_nvic_nvic_ipr47()?.to_ne_bytes();
                    if _start <= 1212 && _end > 1212 {
                        _buf[(1212 - _start) as usize] = _value[0];
                    }
                    if _start <= 1213 && _end > 1213 {
                        _buf[(1213 - _start) as usize] = _value[1];
                    }
                    if _start <= 1214 && _end > 1214 {
                        _buf[(1214 - _start) as usize] = _value[2];
                    }
                    if _start <= 1215 && _end > 1215 {
                        _buf[(1215 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1220 && _end > 1216 {
                    let _value = self.read_nvic_nvic_ipr48()?.to_ne_bytes();
                    if _start <= 1216 && _end > 1216 {
                        _buf[(1216 - _start) as usize] = _value[0];
                    }
                    if _start <= 1217 && _end > 1217 {
                        _buf[(1217 - _start) as usize] = _value[1];
                    }
                    if _start <= 1218 && _end > 1218 {
                        _buf[(1218 - _start) as usize] = _value[2];
                    }
                    if _start <= 1219 && _end > 1219 {
                        _buf[(1219 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1224 && _end > 1220 {
                    let _value = self.read_nvic_nvic_ipr49()?.to_ne_bytes();
                    if _start <= 1220 && _end > 1220 {
                        _buf[(1220 - _start) as usize] = _value[0];
                    }
                    if _start <= 1221 && _end > 1221 {
                        _buf[(1221 - _start) as usize] = _value[1];
                    }
                    if _start <= 1222 && _end > 1222 {
                        _buf[(1222 - _start) as usize] = _value[2];
                    }
                    if _start <= 1223 && _end > 1223 {
                        _buf[(1223 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1228 && _end > 1224 {
                    let _value = self.read_nvic_nvic_ipr50()?.to_ne_bytes();
                    if _start <= 1224 && _end > 1224 {
                        _buf[(1224 - _start) as usize] = _value[0];
                    }
                    if _start <= 1225 && _end > 1225 {
                        _buf[(1225 - _start) as usize] = _value[1];
                    }
                    if _start <= 1226 && _end > 1226 {
                        _buf[(1226 - _start) as usize] = _value[2];
                    }
                    if _start <= 1227 && _end > 1227 {
                        _buf[(1227 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1232 && _end > 1228 {
                    let _value = self.read_nvic_nvic_ipr51()?.to_ne_bytes();
                    if _start <= 1228 && _end > 1228 {
                        _buf[(1228 - _start) as usize] = _value[0];
                    }
                    if _start <= 1229 && _end > 1229 {
                        _buf[(1229 - _start) as usize] = _value[1];
                    }
                    if _start <= 1230 && _end > 1230 {
                        _buf[(1230 - _start) as usize] = _value[2];
                    }
                    if _start <= 1231 && _end > 1231 {
                        _buf[(1231 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1236 && _end > 1232 {
                    let _value = self.read_nvic_nvic_ipr52()?.to_ne_bytes();
                    if _start <= 1232 && _end > 1232 {
                        _buf[(1232 - _start) as usize] = _value[0];
                    }
                    if _start <= 1233 && _end > 1233 {
                        _buf[(1233 - _start) as usize] = _value[1];
                    }
                    if _start <= 1234 && _end > 1234 {
                        _buf[(1234 - _start) as usize] = _value[2];
                    }
                    if _start <= 1235 && _end > 1235 {
                        _buf[(1235 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1240 && _end > 1236 {
                    let _value = self.read_nvic_nvic_ipr53()?.to_ne_bytes();
                    if _start <= 1236 && _end > 1236 {
                        _buf[(1236 - _start) as usize] = _value[0];
                    }
                    if _start <= 1237 && _end > 1237 {
                        _buf[(1237 - _start) as usize] = _value[1];
                    }
                    if _start <= 1238 && _end > 1238 {
                        _buf[(1238 - _start) as usize] = _value[2];
                    }
                    if _start <= 1239 && _end > 1239 {
                        _buf[(1239 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1244 && _end > 1240 {
                    let _value = self.read_nvic_nvic_ipr54()?.to_ne_bytes();
                    if _start <= 1240 && _end > 1240 {
                        _buf[(1240 - _start) as usize] = _value[0];
                    }
                    if _start <= 1241 && _end > 1241 {
                        _buf[(1241 - _start) as usize] = _value[1];
                    }
                    if _start <= 1242 && _end > 1242 {
                        _buf[(1242 - _start) as usize] = _value[2];
                    }
                    if _start <= 1243 && _end > 1243 {
                        _buf[(1243 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1248 && _end > 1244 {
                    let _value = self.read_nvic_nvic_ipr55()?.to_ne_bytes();
                    if _start <= 1244 && _end > 1244 {
                        _buf[(1244 - _start) as usize] = _value[0];
                    }
                    if _start <= 1245 && _end > 1245 {
                        _buf[(1245 - _start) as usize] = _value[1];
                    }
                    if _start <= 1246 && _end > 1246 {
                        _buf[(1246 - _start) as usize] = _value[2];
                    }
                    if _start <= 1247 && _end > 1247 {
                        _buf[(1247 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1252 && _end > 1248 {
                    let _value = self.read_nvic_nvic_ipr56()?.to_ne_bytes();
                    if _start <= 1248 && _end > 1248 {
                        _buf[(1248 - _start) as usize] = _value[0];
                    }
                    if _start <= 1249 && _end > 1249 {
                        _buf[(1249 - _start) as usize] = _value[1];
                    }
                    if _start <= 1250 && _end > 1250 {
                        _buf[(1250 - _start) as usize] = _value[2];
                    }
                    if _start <= 1251 && _end > 1251 {
                        _buf[(1251 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1256 && _end > 1252 {
                    let _value = self.read_nvic_nvic_ipr57()?.to_ne_bytes();
                    if _start <= 1252 && _end > 1252 {
                        _buf[(1252 - _start) as usize] = _value[0];
                    }
                    if _start <= 1253 && _end > 1253 {
                        _buf[(1253 - _start) as usize] = _value[1];
                    }
                    if _start <= 1254 && _end > 1254 {
                        _buf[(1254 - _start) as usize] = _value[2];
                    }
                    if _start <= 1255 && _end > 1255 {
                        _buf[(1255 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1260 && _end > 1256 {
                    let _value = self.read_nvic_nvic_ipr58()?.to_ne_bytes();
                    if _start <= 1256 && _end > 1256 {
                        _buf[(1256 - _start) as usize] = _value[0];
                    }
                    if _start <= 1257 && _end > 1257 {
                        _buf[(1257 - _start) as usize] = _value[1];
                    }
                    if _start <= 1258 && _end > 1258 {
                        _buf[(1258 - _start) as usize] = _value[2];
                    }
                    if _start <= 1259 && _end > 1259 {
                        _buf[(1259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1264 && _end > 1260 {
                    let _value = self.read_nvic_nvic_ipr59()?.to_ne_bytes();
                    if _start <= 1260 && _end > 1260 {
                        _buf[(1260 - _start) as usize] = _value[0];
                    }
                    if _start <= 1261 && _end > 1261 {
                        _buf[(1261 - _start) as usize] = _value[1];
                    }
                    if _start <= 1262 && _end > 1262 {
                        _buf[(1262 - _start) as usize] = _value[2];
                    }
                    if _start <= 1263 && _end > 1263 {
                        _buf[(1263 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3328..=3443, 3329..=3444) => {
                if _start < 3336 && _end > 3332 {
                    let _value = self.read_control_icsr()?.to_ne_bytes();
                    if _start <= 3332 && _end > 3332 {
                        _buf[(3332 - _start) as usize] = _value[0];
                    }
                    if _start <= 3333 && _end > 3333 {
                        _buf[(3333 - _start) as usize] = _value[1];
                    }
                    if _start <= 3334 && _end > 3334 {
                        _buf[(3334 - _start) as usize] = _value[2];
                    }
                    if _start <= 3335 && _end > 3335 {
                        _buf[(3335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3340 && _end > 3336 {
                    let _value = self.read_control_vtor()?.to_ne_bytes();
                    if _start <= 3336 && _end > 3336 {
                        _buf[(3336 - _start) as usize] = _value[0];
                    }
                    if _start <= 3337 && _end > 3337 {
                        _buf[(3337 - _start) as usize] = _value[1];
                    }
                    if _start <= 3338 && _end > 3338 {
                        _buf[(3338 - _start) as usize] = _value[2];
                    }
                    if _start <= 3339 && _end > 3339 {
                        _buf[(3339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3344 && _end > 3340 {
                    let _value = self.read_control_aircr()?.to_ne_bytes();
                    if _start <= 3340 && _end > 3340 {
                        _buf[(3340 - _start) as usize] = _value[0];
                    }
                    if _start <= 3341 && _end > 3341 {
                        _buf[(3341 - _start) as usize] = _value[1];
                    }
                    if _start <= 3342 && _end > 3342 {
                        _buf[(3342 - _start) as usize] = _value[2];
                    }
                    if _start <= 3343 && _end > 3343 {
                        _buf[(3343 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3348 && _end > 3344 {
                    let _value = self.read_control_scr()?.to_ne_bytes();
                    if _start <= 3344 && _end > 3344 {
                        _buf[(3344 - _start) as usize] = _value[0];
                    }
                    if _start <= 3345 && _end > 3345 {
                        _buf[(3345 - _start) as usize] = _value[1];
                    }
                    if _start <= 3346 && _end > 3346 {
                        _buf[(3346 - _start) as usize] = _value[2];
                    }
                    if _start <= 3347 && _end > 3347 {
                        _buf[(3347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3352 && _end > 3348 {
                    let _value = self.read_control_ccr()?.to_ne_bytes();
                    if _start <= 3348 && _end > 3348 {
                        _buf[(3348 - _start) as usize] = _value[0];
                    }
                    if _start <= 3349 && _end > 3349 {
                        _buf[(3349 - _start) as usize] = _value[1];
                    }
                    if _start <= 3350 && _end > 3350 {
                        _buf[(3350 - _start) as usize] = _value[2];
                    }
                    if _start <= 3351 && _end > 3351 {
                        _buf[(3351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3356 && _end > 3352 {
                    let _value = self.read_control_shpr1()?.to_ne_bytes();
                    if _start <= 3352 && _end > 3352 {
                        _buf[(3352 - _start) as usize] = _value[0];
                    }
                    if _start <= 3353 && _end > 3353 {
                        _buf[(3353 - _start) as usize] = _value[1];
                    }
                    if _start <= 3354 && _end > 3354 {
                        _buf[(3354 - _start) as usize] = _value[2];
                    }
                    if _start <= 3355 && _end > 3355 {
                        _buf[(3355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3360 && _end > 3356 {
                    let _value = self.read_control_shpr2()?.to_ne_bytes();
                    if _start <= 3356 && _end > 3356 {
                        _buf[(3356 - _start) as usize] = _value[0];
                    }
                    if _start <= 3357 && _end > 3357 {
                        _buf[(3357 - _start) as usize] = _value[1];
                    }
                    if _start <= 3358 && _end > 3358 {
                        _buf[(3358 - _start) as usize] = _value[2];
                    }
                    if _start <= 3359 && _end > 3359 {
                        _buf[(3359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3364 && _end > 3360 {
                    let _value = self.read_control_shpr3()?.to_ne_bytes();
                    if _start <= 3360 && _end > 3360 {
                        _buf[(3360 - _start) as usize] = _value[0];
                    }
                    if _start <= 3361 && _end > 3361 {
                        _buf[(3361 - _start) as usize] = _value[1];
                    }
                    if _start <= 3362 && _end > 3362 {
                        _buf[(3362 - _start) as usize] = _value[2];
                    }
                    if _start <= 3363 && _end > 3363 {
                        _buf[(3363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3368 && _end > 3364 {
                    let _value = self.read_control_shcsr()?.to_ne_bytes();
                    if _start <= 3364 && _end > 3364 {
                        _buf[(3364 - _start) as usize] = _value[0];
                    }
                    if _start <= 3365 && _end > 3365 {
                        _buf[(3365 - _start) as usize] = _value[1];
                    }
                    if _start <= 3366 && _end > 3366 {
                        _buf[(3366 - _start) as usize] = _value[2];
                    }
                    if _start <= 3367 && _end > 3367 {
                        _buf[(3367 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3372 && _end > 3368 {
                    let _value = self.read_control_cfsr()?.to_ne_bytes();
                    if _start <= 3368 && _end > 3368 {
                        _buf[(3368 - _start) as usize] = _value[0];
                    }
                    if _start <= 3369 && _end > 3369 {
                        _buf[(3369 - _start) as usize] = _value[1];
                    }
                    if _start <= 3370 && _end > 3370 {
                        _buf[(3370 - _start) as usize] = _value[2];
                    }
                    if _start <= 3371 && _end > 3371 {
                        _buf[(3371 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3376 && _end > 3372 {
                    let _value = self.read_control_hfsr()?.to_ne_bytes();
                    if _start <= 3372 && _end > 3372 {
                        _buf[(3372 - _start) as usize] = _value[0];
                    }
                    if _start <= 3373 && _end > 3373 {
                        _buf[(3373 - _start) as usize] = _value[1];
                    }
                    if _start <= 3374 && _end > 3374 {
                        _buf[(3374 - _start) as usize] = _value[2];
                    }
                    if _start <= 3375 && _end > 3375 {
                        _buf[(3375 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3380 && _end > 3376 {
                    let _value = self.read_control_dfsr()?.to_ne_bytes();
                    if _start <= 3376 && _end > 3376 {
                        _buf[(3376 - _start) as usize] = _value[0];
                    }
                    if _start <= 3377 && _end > 3377 {
                        _buf[(3377 - _start) as usize] = _value[1];
                    }
                    if _start <= 3378 && _end > 3378 {
                        _buf[(3378 - _start) as usize] = _value[2];
                    }
                    if _start <= 3379 && _end > 3379 {
                        _buf[(3379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3384 && _end > 3380 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_control_mmfar()?
                        .to_ne_bytes();
                    if _start <= 3380 && _end > 3380 {
                        _buf[(3380 - _start) as usize] = _value[0];
                    }
                    if _start <= 3381 && _end > 3381 {
                        _buf[(3381 - _start) as usize] = _value[1];
                    }
                    if _start <= 3382 && _end > 3382 {
                        _buf[(3382 - _start) as usize] = _value[2];
                    }
                    if _start <= 3383 && _end > 3383 {
                        _buf[(3383 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3388 && _end > 3384 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_control_bfar()?
                        .to_ne_bytes();
                    if _start <= 3384 && _end > 3384 {
                        _buf[(3384 - _start) as usize] = _value[0];
                    }
                    if _start <= 3385 && _end > 3385 {
                        _buf[(3385 - _start) as usize] = _value[1];
                    }
                    if _start <= 3386 && _end > 3386 {
                        _buf[(3386 - _start) as usize] = _value[2];
                    }
                    if _start <= 3387 && _end > 3387 {
                        _buf[(3387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3392 && _end > 3388 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_control_afsr()?
                        .to_ne_bytes();
                    if _start <= 3388 && _end > 3388 {
                        _buf[(3388 - _start) as usize] = _value[0];
                    }
                    if _start <= 3389 && _end > 3389 {
                        _buf[(3389 - _start) as usize] = _value[1];
                    }
                    if _start <= 3390 && _end > 3390 {
                        _buf[(3390 - _start) as usize] = _value[2];
                    }
                    if _start <= 3391 && _end > 3391 {
                        _buf[(3391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3332 && _end > 3328 {
                    let _value = self.read_id_cpuid()?.to_ne_bytes();
                    if _start <= 3328 && _end > 3328 {
                        _buf[(3328 - _start) as usize] = _value[0];
                    }
                    if _start <= 3329 && _end > 3329 {
                        _buf[(3329 - _start) as usize] = _value[1];
                    }
                    if _start <= 3330 && _end > 3330 {
                        _buf[(3330 - _start) as usize] = _value[2];
                    }
                    if _start <= 3331 && _end > 3331 {
                        _buf[(3331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3396 && _end > 3392 {
                    let _value = self.read_id_id_pfr0()?.to_ne_bytes();
                    if _start <= 3392 && _end > 3392 {
                        _buf[(3392 - _start) as usize] = _value[0];
                    }
                    if _start <= 3393 && _end > 3393 {
                        _buf[(3393 - _start) as usize] = _value[1];
                    }
                    if _start <= 3394 && _end > 3394 {
                        _buf[(3394 - _start) as usize] = _value[2];
                    }
                    if _start <= 3395 && _end > 3395 {
                        _buf[(3395 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3400 && _end > 3396 {
                    let _value = self.read_id_id_pfr1()?.to_ne_bytes();
                    if _start <= 3396 && _end > 3396 {
                        _buf[(3396 - _start) as usize] = _value[0];
                    }
                    if _start <= 3397 && _end > 3397 {
                        _buf[(3397 - _start) as usize] = _value[1];
                    }
                    if _start <= 3398 && _end > 3398 {
                        _buf[(3398 - _start) as usize] = _value[2];
                    }
                    if _start <= 3399 && _end > 3399 {
                        _buf[(3399 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3404 && _end > 3400 {
                    let _value = self.read_id_id_dfr0()?.to_ne_bytes();
                    if _start <= 3400 && _end > 3400 {
                        _buf[(3400 - _start) as usize] = _value[0];
                    }
                    if _start <= 3401 && _end > 3401 {
                        _buf[(3401 - _start) as usize] = _value[1];
                    }
                    if _start <= 3402 && _end > 3402 {
                        _buf[(3402 - _start) as usize] = _value[2];
                    }
                    if _start <= 3403 && _end > 3403 {
                        _buf[(3403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3408 && _end > 3404 {
                    let _value =
                        self.0.lock().unwrap().read_id_id_afr0()?.to_ne_bytes();
                    if _start <= 3404 && _end > 3404 {
                        _buf[(3404 - _start) as usize] = _value[0];
                    }
                    if _start <= 3405 && _end > 3405 {
                        _buf[(3405 - _start) as usize] = _value[1];
                    }
                    if _start <= 3406 && _end > 3406 {
                        _buf[(3406 - _start) as usize] = _value[2];
                    }
                    if _start <= 3407 && _end > 3407 {
                        _buf[(3407 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3412 && _end > 3408 {
                    let _value = self.read_id_id_mmfr0()?.to_ne_bytes();
                    if _start <= 3408 && _end > 3408 {
                        _buf[(3408 - _start) as usize] = _value[0];
                    }
                    if _start <= 3409 && _end > 3409 {
                        _buf[(3409 - _start) as usize] = _value[1];
                    }
                    if _start <= 3410 && _end > 3410 {
                        _buf[(3410 - _start) as usize] = _value[2];
                    }
                    if _start <= 3411 && _end > 3411 {
                        _buf[(3411 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3416 && _end > 3412 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_id_id_mmfr1()?
                        .to_ne_bytes();
                    if _start <= 3412 && _end > 3412 {
                        _buf[(3412 - _start) as usize] = _value[0];
                    }
                    if _start <= 3413 && _end > 3413 {
                        _buf[(3413 - _start) as usize] = _value[1];
                    }
                    if _start <= 3414 && _end > 3414 {
                        _buf[(3414 - _start) as usize] = _value[2];
                    }
                    if _start <= 3415 && _end > 3415 {
                        _buf[(3415 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3420 && _end > 3416 {
                    let _value = self.read_id_id_mmfr2()?.to_ne_bytes();
                    if _start <= 3416 && _end > 3416 {
                        _buf[(3416 - _start) as usize] = _value[0];
                    }
                    if _start <= 3417 && _end > 3417 {
                        _buf[(3417 - _start) as usize] = _value[1];
                    }
                    if _start <= 3418 && _end > 3418 {
                        _buf[(3418 - _start) as usize] = _value[2];
                    }
                    if _start <= 3419 && _end > 3419 {
                        _buf[(3419 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3424 && _end > 3420 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_id_id_mmfr3()?
                        .to_ne_bytes();
                    if _start <= 3420 && _end > 3420 {
                        _buf[(3420 - _start) as usize] = _value[0];
                    }
                    if _start <= 3421 && _end > 3421 {
                        _buf[(3421 - _start) as usize] = _value[1];
                    }
                    if _start <= 3422 && _end > 3422 {
                        _buf[(3422 - _start) as usize] = _value[2];
                    }
                    if _start <= 3423 && _end > 3423 {
                        _buf[(3423 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3428 && _end > 3424 {
                    let _value = self.read_id_id_isar0()?.to_ne_bytes();
                    if _start <= 3424 && _end > 3424 {
                        _buf[(3424 - _start) as usize] = _value[0];
                    }
                    if _start <= 3425 && _end > 3425 {
                        _buf[(3425 - _start) as usize] = _value[1];
                    }
                    if _start <= 3426 && _end > 3426 {
                        _buf[(3426 - _start) as usize] = _value[2];
                    }
                    if _start <= 3427 && _end > 3427 {
                        _buf[(3427 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3432 && _end > 3428 {
                    let _value = self.read_id_id_isar1()?.to_ne_bytes();
                    if _start <= 3428 && _end > 3428 {
                        _buf[(3428 - _start) as usize] = _value[0];
                    }
                    if _start <= 3429 && _end > 3429 {
                        _buf[(3429 - _start) as usize] = _value[1];
                    }
                    if _start <= 3430 && _end > 3430 {
                        _buf[(3430 - _start) as usize] = _value[2];
                    }
                    if _start <= 3431 && _end > 3431 {
                        _buf[(3431 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3436 && _end > 3432 {
                    let _value = self.read_id_id_isar2()?.to_ne_bytes();
                    if _start <= 3432 && _end > 3432 {
                        _buf[(3432 - _start) as usize] = _value[0];
                    }
                    if _start <= 3433 && _end > 3433 {
                        _buf[(3433 - _start) as usize] = _value[1];
                    }
                    if _start <= 3434 && _end > 3434 {
                        _buf[(3434 - _start) as usize] = _value[2];
                    }
                    if _start <= 3435 && _end > 3435 {
                        _buf[(3435 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3440 && _end > 3436 {
                    let _value = self.read_id_id_isar3()?.to_ne_bytes();
                    if _start <= 3436 && _end > 3436 {
                        _buf[(3436 - _start) as usize] = _value[0];
                    }
                    if _start <= 3437 && _end > 3437 {
                        _buf[(3437 - _start) as usize] = _value[1];
                    }
                    if _start <= 3438 && _end > 3438 {
                        _buf[(3438 - _start) as usize] = _value[2];
                    }
                    if _start <= 3439 && _end > 3439 {
                        _buf[(3439 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3444 && _end > 3440 {
                    let _value = self.read_id_id_isar4()?.to_ne_bytes();
                    if _start <= 3440 && _end > 3440 {
                        _buf[(3440 - _start) as usize] = _value[0];
                    }
                    if _start <= 3441 && _end > 3441 {
                        _buf[(3441 - _start) as usize] = _value[1];
                    }
                    if _start <= 3442 && _end > 3442 {
                        _buf[(3442 - _start) as usize] = _value[2];
                    }
                    if _start <= 3443 && _end > 3443 {
                        _buf[(3443 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3464..=3467, 3465..=3468) => {
                if _start < 3468 && _end > 3464 {
                    let _value = self.read_control_cpacr()?.to_ne_bytes();
                    if _start <= 3464 && _end > 3464 {
                        _buf[(3464 - _start) as usize] = _value[0];
                    }
                    if _start <= 3465 && _end > 3465 {
                        _buf[(3465 - _start) as usize] = _value[1];
                    }
                    if _start <= 3466 && _end > 3466 {
                        _buf[(3466 - _start) as usize] = _value[2];
                    }
                    if _start <= 3467 && _end > 3467 {
                        _buf[(3467 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3472..=3515, 3473..=3516) => {
                if _start < 3476 && _end > 3472 {
                    let _value = self.read_mpu_mpu_type()?.to_ne_bytes();
                    if _start <= 3472 && _end > 3472 {
                        _buf[(3472 - _start) as usize] = _value[0];
                    }
                    if _start <= 3473 && _end > 3473 {
                        _buf[(3473 - _start) as usize] = _value[1];
                    }
                    if _start <= 3474 && _end > 3474 {
                        _buf[(3474 - _start) as usize] = _value[2];
                    }
                    if _start <= 3475 && _end > 3475 {
                        _buf[(3475 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3480 && _end > 3476 {
                    let _value = self.read_mpu_mpu_ctrl()?.to_ne_bytes();
                    if _start <= 3476 && _end > 3476 {
                        _buf[(3476 - _start) as usize] = _value[0];
                    }
                    if _start <= 3477 && _end > 3477 {
                        _buf[(3477 - _start) as usize] = _value[1];
                    }
                    if _start <= 3478 && _end > 3478 {
                        _buf[(3478 - _start) as usize] = _value[2];
                    }
                    if _start <= 3479 && _end > 3479 {
                        _buf[(3479 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3484 && _end > 3480 {
                    let _value = self.read_mpu_mpu_rnr()?.to_ne_bytes();
                    if _start <= 3480 && _end > 3480 {
                        _buf[(3480 - _start) as usize] = _value[0];
                    }
                    if _start <= 3481 && _end > 3481 {
                        _buf[(3481 - _start) as usize] = _value[1];
                    }
                    if _start <= 3482 && _end > 3482 {
                        _buf[(3482 - _start) as usize] = _value[2];
                    }
                    if _start <= 3483 && _end > 3483 {
                        _buf[(3483 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3488 && _end > 3484 {
                    let _value = self.read_mpu_mpu_rbar()?.to_ne_bytes();
                    if _start <= 3484 && _end > 3484 {
                        _buf[(3484 - _start) as usize] = _value[0];
                    }
                    if _start <= 3485 && _end > 3485 {
                        _buf[(3485 - _start) as usize] = _value[1];
                    }
                    if _start <= 3486 && _end > 3486 {
                        _buf[(3486 - _start) as usize] = _value[2];
                    }
                    if _start <= 3487 && _end > 3487 {
                        _buf[(3487 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3492 && _end > 3488 {
                    let _value = self.read_mpu_mpu_rasr()?.to_ne_bytes();
                    if _start <= 3488 && _end > 3488 {
                        _buf[(3488 - _start) as usize] = _value[0];
                    }
                    if _start <= 3489 && _end > 3489 {
                        _buf[(3489 - _start) as usize] = _value[1];
                    }
                    if _start <= 3490 && _end > 3490 {
                        _buf[(3490 - _start) as usize] = _value[2];
                    }
                    if _start <= 3491 && _end > 3491 {
                        _buf[(3491 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3496 && _end > 3492 {
                    let _value = self.read_mpu_mpu_rbar_a1()?.to_ne_bytes();
                    if _start <= 3492 && _end > 3492 {
                        _buf[(3492 - _start) as usize] = _value[0];
                    }
                    if _start <= 3493 && _end > 3493 {
                        _buf[(3493 - _start) as usize] = _value[1];
                    }
                    if _start <= 3494 && _end > 3494 {
                        _buf[(3494 - _start) as usize] = _value[2];
                    }
                    if _start <= 3495 && _end > 3495 {
                        _buf[(3495 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3500 && _end > 3496 {
                    let _value = self.read_mpu_mpu_rasr_a1()?.to_ne_bytes();
                    if _start <= 3496 && _end > 3496 {
                        _buf[(3496 - _start) as usize] = _value[0];
                    }
                    if _start <= 3497 && _end > 3497 {
                        _buf[(3497 - _start) as usize] = _value[1];
                    }
                    if _start <= 3498 && _end > 3498 {
                        _buf[(3498 - _start) as usize] = _value[2];
                    }
                    if _start <= 3499 && _end > 3499 {
                        _buf[(3499 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3504 && _end > 3500 {
                    let _value = self.read_mpu_mpu_rbar_a2()?.to_ne_bytes();
                    if _start <= 3500 && _end > 3500 {
                        _buf[(3500 - _start) as usize] = _value[0];
                    }
                    if _start <= 3501 && _end > 3501 {
                        _buf[(3501 - _start) as usize] = _value[1];
                    }
                    if _start <= 3502 && _end > 3502 {
                        _buf[(3502 - _start) as usize] = _value[2];
                    }
                    if _start <= 3503 && _end > 3503 {
                        _buf[(3503 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3508 && _end > 3504 {
                    let _value = self.read_mpu_mpu_rasr_a2()?.to_ne_bytes();
                    if _start <= 3504 && _end > 3504 {
                        _buf[(3504 - _start) as usize] = _value[0];
                    }
                    if _start <= 3505 && _end > 3505 {
                        _buf[(3505 - _start) as usize] = _value[1];
                    }
                    if _start <= 3506 && _end > 3506 {
                        _buf[(3506 - _start) as usize] = _value[2];
                    }
                    if _start <= 3507 && _end > 3507 {
                        _buf[(3507 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3512 && _end > 3508 {
                    let _value = self.read_mpu_mpu_rbar_a3()?.to_ne_bytes();
                    if _start <= 3508 && _end > 3508 {
                        _buf[(3508 - _start) as usize] = _value[0];
                    }
                    if _start <= 3509 && _end > 3509 {
                        _buf[(3509 - _start) as usize] = _value[1];
                    }
                    if _start <= 3510 && _end > 3510 {
                        _buf[(3510 - _start) as usize] = _value[2];
                    }
                    if _start <= 3511 && _end > 3511 {
                        _buf[(3511 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3516 && _end > 3512 {
                    let _value = self.read_mpu_mpu_rasr_a3()?.to_ne_bytes();
                    if _start <= 3512 && _end > 3512 {
                        _buf[(3512 - _start) as usize] = _value[0];
                    }
                    if _start <= 3513 && _end > 3513 {
                        _buf[(3513 - _start) as usize] = _value[1];
                    }
                    if _start <= 3514 && _end > 3514 {
                        _buf[(3514 - _start) as usize] = _value[2];
                    }
                    if _start <= 3515 && _end > 3515 {
                        _buf[(3515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3580..=3583, 3581..=3584) => {
                if _start < 3584 && _end > 3580 {
                    let _value = self.read_control_demcr()?.to_ne_bytes();
                    if _start <= 3580 && _end > 3580 {
                        _buf[(3580 - _start) as usize] = _value[0];
                    }
                    if _start <= 3581 && _end > 3581 {
                        _buf[(3581 - _start) as usize] = _value[1];
                    }
                    if _start <= 3582 && _end > 3582 {
                        _buf[(3582 - _start) as usize] = _value[2];
                    }
                    if _start <= 3583 && _end > 3583 {
                        _buf[(3583 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3840..=3843, 3841..=3844) => return Err(MemError::ReadViolation),
            (3892..=3911, 3893..=3912) => {
                if _start < 3896 && _end > 3892 {
                    let _value = self.read_fpe_fpccr()?.to_ne_bytes();
                    if _start <= 3892 && _end > 3892 {
                        _buf[(3892 - _start) as usize] = _value[0];
                    }
                    if _start <= 3893 && _end > 3893 {
                        _buf[(3893 - _start) as usize] = _value[1];
                    }
                    if _start <= 3894 && _end > 3894 {
                        _buf[(3894 - _start) as usize] = _value[2];
                    }
                    if _start <= 3895 && _end > 3895 {
                        _buf[(3895 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3900 && _end > 3896 {
                    let _value =
                        self.0.lock().unwrap().read_fpe_fpcar()?.to_ne_bytes();
                    if _start <= 3896 && _end > 3896 {
                        _buf[(3896 - _start) as usize] = _value[0];
                    }
                    if _start <= 3897 && _end > 3897 {
                        _buf[(3897 - _start) as usize] = _value[1];
                    }
                    if _start <= 3898 && _end > 3898 {
                        _buf[(3898 - _start) as usize] = _value[2];
                    }
                    if _start <= 3899 && _end > 3899 {
                        _buf[(3899 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3904 && _end > 3900 {
                    let _value = self.read_fpe_fpdscr()?.to_ne_bytes();
                    if _start <= 3900 && _end > 3900 {
                        _buf[(3900 - _start) as usize] = _value[0];
                    }
                    if _start <= 3901 && _end > 3901 {
                        _buf[(3901 - _start) as usize] = _value[1];
                    }
                    if _start <= 3902 && _end > 3902 {
                        _buf[(3902 - _start) as usize] = _value[2];
                    }
                    if _start <= 3903 && _end > 3903 {
                        _buf[(3903 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3908 && _end > 3904 {
                    let _value = self.read_fpe_mvfr0()?.to_ne_bytes();
                    if _start <= 3904 && _end > 3904 {
                        _buf[(3904 - _start) as usize] = _value[0];
                    }
                    if _start <= 3905 && _end > 3905 {
                        _buf[(3905 - _start) as usize] = _value[1];
                    }
                    if _start <= 3906 && _end > 3906 {
                        _buf[(3906 - _start) as usize] = _value[2];
                    }
                    if _start <= 3907 && _end > 3907 {
                        _buf[(3907 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3912 && _end > 3908 {
                    let _value = self.read_fpe_mvfr1()?.to_ne_bytes();
                    if _start <= 3908 && _end > 3908 {
                        _buf[(3908 - _start) as usize] = _value[0];
                    }
                    if _start <= 3909 && _end > 3909 {
                        _buf[(3909 - _start) as usize] = _value[1];
                    }
                    if _start <= 3910 && _end > 3910 {
                        _buf[(3910 - _start) as usize] = _value[2];
                    }
                    if _start <= 3911 && _end > 3911 {
                        _buf[(3911 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 3758153728;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=11, 5..=12) => {
                if _start < 12 && _end > 8 {
                    let offset = 8u64.saturating_sub(_start);
                    let start = _start.saturating_sub(8u64) as usize;
                    let end =
                        (_end.saturating_sub(8u64) as usize).min(start + 4);
                    self.write_control_actlr(offset, &_buf[start..end])?;
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (16..=31, 17..=32) => {
                if _start < 20 && _end > 16 {
                    let offset = 16u64.saturating_sub(_start);
                    let start = _start.saturating_sub(16u64) as usize;
                    let end =
                        (_end.saturating_sub(16u64) as usize).min(start + 4);
                    self.write_systick_stcsr(offset, &_buf[start..end])?;
                }
                if _start < 24 && _end > 20 {
                    let offset = 20u64.saturating_sub(_start);
                    let start = _start.saturating_sub(20u64) as usize;
                    let end =
                        (_end.saturating_sub(20u64) as usize).min(start + 4);
                    self.write_systick_strvr(offset, &_buf[start..end])?;
                }
                if _start < 28 && _end > 24 {
                    let offset = 24u64.saturating_sub(_start);
                    let start = _start.saturating_sub(24u64) as usize;
                    let end =
                        (_end.saturating_sub(24u64) as usize).min(start + 4);
                    self.write_systick_stcvr(offset, &_buf[start..end])?;
                }
                if _start < 32 && _end > 28 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256u64 && _end >= 260u64,
                        "partial write for NVIC NVIC_ISER0 not implemented",
                    );
                    let start = _start.saturating_sub(256u64) as usize;
                    let end =
                        (_end.saturating_sub(256u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260u64 && _end >= 264u64,
                        "partial write for NVIC NVIC_ISER1 not implemented",
                    );
                    let start = _start.saturating_sub(260u64) as usize;
                    let end =
                        (_end.saturating_sub(260u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264u64 && _end >= 268u64,
                        "partial write for NVIC NVIC_ISER2 not implemented",
                    );
                    let start = _start.saturating_sub(264u64) as usize;
                    let end =
                        (_end.saturating_sub(264u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268u64 && _end >= 272u64,
                        "partial write for NVIC NVIC_ISER3 not implemented",
                    );
                    let start = _start.saturating_sub(268u64) as usize;
                    let end =
                        (_end.saturating_sub(268u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272u64 && _end >= 276u64,
                        "partial write for NVIC NVIC_ISER4 not implemented",
                    );
                    let start = _start.saturating_sub(272u64) as usize;
                    let end =
                        (_end.saturating_sub(272u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert!(
                        _start <= 276u64 && _end >= 280u64,
                        "partial write for NVIC NVIC_ISER5 not implemented",
                    );
                    let start = _start.saturating_sub(276u64) as usize;
                    let end =
                        (_end.saturating_sub(276u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert!(
                        _start <= 280u64 && _end >= 284u64,
                        "partial write for NVIC NVIC_ISER6 not implemented",
                    );
                    let start = _start.saturating_sub(280u64) as usize;
                    let end =
                        (_end.saturating_sub(280u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284u64 && _end >= 288u64,
                        "partial write for NVIC NVIC_ISER7 not implemented",
                    );
                    let start = _start.saturating_sub(284u64) as usize;
                    let end =
                        (_end.saturating_sub(284u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (384..=415, 385..=416) => {
                if _start < 388 && _end > 384 {
                    assert!(
                        _start <= 384u64 && _end >= 388u64,
                        "partial write for NVIC NVIC_ICER0 not implemented",
                    );
                    let start = _start.saturating_sub(384u64) as usize;
                    let end =
                        (_end.saturating_sub(384u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 392 && _end > 388 {
                    assert!(
                        _start <= 388u64 && _end >= 392u64,
                        "partial write for NVIC NVIC_ICER1 not implemented",
                    );
                    let start = _start.saturating_sub(388u64) as usize;
                    let end =
                        (_end.saturating_sub(388u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 396 && _end > 392 {
                    assert!(
                        _start <= 392u64 && _end >= 396u64,
                        "partial write for NVIC NVIC_ICER2 not implemented",
                    );
                    let start = _start.saturating_sub(392u64) as usize;
                    let end =
                        (_end.saturating_sub(392u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 400 && _end > 396 {
                    assert!(
                        _start <= 396u64 && _end >= 400u64,
                        "partial write for NVIC NVIC_ICER3 not implemented",
                    );
                    let start = _start.saturating_sub(396u64) as usize;
                    let end =
                        (_end.saturating_sub(396u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 404 && _end > 400 {
                    assert!(
                        _start <= 400u64 && _end >= 404u64,
                        "partial write for NVIC NVIC_ICER4 not implemented",
                    );
                    let start = _start.saturating_sub(400u64) as usize;
                    let end =
                        (_end.saturating_sub(400u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 408 && _end > 404 {
                    assert!(
                        _start <= 404u64 && _end >= 408u64,
                        "partial write for NVIC NVIC_ICER5 not implemented",
                    );
                    let start = _start.saturating_sub(404u64) as usize;
                    let end =
                        (_end.saturating_sub(404u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 412 && _end > 408 {
                    assert!(
                        _start <= 408u64 && _end >= 412u64,
                        "partial write for NVIC NVIC_ICER6 not implemented",
                    );
                    let start = _start.saturating_sub(408u64) as usize;
                    let end =
                        (_end.saturating_sub(408u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 416 && _end > 412 {
                    assert!(
                        _start <= 412u64 && _end >= 416u64,
                        "partial write for NVIC NVIC_ICER7 not implemented",
                    );
                    let start = _start.saturating_sub(412u64) as usize;
                    let end =
                        (_end.saturating_sub(412u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=543, 513..=544) => {
                if _start < 516 && _end > 512 {
                    assert!(
                        _start <= 512u64 && _end >= 516u64,
                        "partial write for NVIC NVIC_ISPR0 not implemented",
                    );
                    let start = _start.saturating_sub(512u64) as usize;
                    let end =
                        (_end.saturating_sub(512u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 520 && _end > 516 {
                    assert!(
                        _start <= 516u64 && _end >= 520u64,
                        "partial write for NVIC NVIC_ISPR1 not implemented",
                    );
                    let start = _start.saturating_sub(516u64) as usize;
                    let end =
                        (_end.saturating_sub(516u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 524 && _end > 520 {
                    assert!(
                        _start <= 520u64 && _end >= 524u64,
                        "partial write for NVIC NVIC_ISPR2 not implemented",
                    );
                    let start = _start.saturating_sub(520u64) as usize;
                    let end =
                        (_end.saturating_sub(520u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 528 && _end > 524 {
                    assert!(
                        _start <= 524u64 && _end >= 528u64,
                        "partial write for NVIC NVIC_ISPR3 not implemented",
                    );
                    let start = _start.saturating_sub(524u64) as usize;
                    let end =
                        (_end.saturating_sub(524u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 532 && _end > 528 {
                    assert!(
                        _start <= 528u64 && _end >= 532u64,
                        "partial write for NVIC NVIC_ISPR4 not implemented",
                    );
                    let start = _start.saturating_sub(528u64) as usize;
                    let end =
                        (_end.saturating_sub(528u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 536 && _end > 532 {
                    assert!(
                        _start <= 532u64 && _end >= 536u64,
                        "partial write for NVIC NVIC_ISPR5 not implemented",
                    );
                    let start = _start.saturating_sub(532u64) as usize;
                    let end =
                        (_end.saturating_sub(532u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 540 && _end > 536 {
                    assert!(
                        _start <= 536u64 && _end >= 540u64,
                        "partial write for NVIC NVIC_ISPR6 not implemented",
                    );
                    let start = _start.saturating_sub(536u64) as usize;
                    let end =
                        (_end.saturating_sub(536u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 544 && _end > 540 {
                    assert!(
                        _start <= 540u64 && _end >= 544u64,
                        "partial write for NVIC NVIC_ISPR7 not implemented",
                    );
                    let start = _start.saturating_sub(540u64) as usize;
                    let end =
                        (_end.saturating_sub(540u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (640..=671, 641..=672) => {
                if _start < 644 && _end > 640 {
                    assert!(
                        _start <= 640u64 && _end >= 644u64,
                        "partial write for NVIC NVIC_ICPR0 not implemented",
                    );
                    let start = _start.saturating_sub(640u64) as usize;
                    let end =
                        (_end.saturating_sub(640u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 648 && _end > 644 {
                    assert!(
                        _start <= 644u64 && _end >= 648u64,
                        "partial write for NVIC NVIC_ICPR1 not implemented",
                    );
                    let start = _start.saturating_sub(644u64) as usize;
                    let end =
                        (_end.saturating_sub(644u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 652 && _end > 648 {
                    assert!(
                        _start <= 648u64 && _end >= 652u64,
                        "partial write for NVIC NVIC_ICPR2 not implemented",
                    );
                    let start = _start.saturating_sub(648u64) as usize;
                    let end =
                        (_end.saturating_sub(648u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 656 && _end > 652 {
                    assert!(
                        _start <= 652u64 && _end >= 656u64,
                        "partial write for NVIC NVIC_ICPR3 not implemented",
                    );
                    let start = _start.saturating_sub(652u64) as usize;
                    let end =
                        (_end.saturating_sub(652u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 660 && _end > 656 {
                    assert!(
                        _start <= 656u64 && _end >= 660u64,
                        "partial write for NVIC NVIC_ICPR4 not implemented",
                    );
                    let start = _start.saturating_sub(656u64) as usize;
                    let end =
                        (_end.saturating_sub(656u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 664 && _end > 660 {
                    assert!(
                        _start <= 660u64 && _end >= 664u64,
                        "partial write for NVIC NVIC_ICPR5 not implemented",
                    );
                    let start = _start.saturating_sub(660u64) as usize;
                    let end =
                        (_end.saturating_sub(660u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 668 && _end > 664 {
                    assert!(
                        _start <= 664u64 && _end >= 668u64,
                        "partial write for NVIC NVIC_ICPR6 not implemented",
                    );
                    let start = _start.saturating_sub(664u64) as usize;
                    let end =
                        (_end.saturating_sub(664u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 672 && _end > 668 {
                    assert!(
                        _start <= 668u64 && _end >= 672u64,
                        "partial write for NVIC NVIC_ICPR7 not implemented",
                    );
                    let start = _start.saturating_sub(668u64) as usize;
                    let end =
                        (_end.saturating_sub(668u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (768..=799, 769..=800) => {
                if _start < 772 && _end > 768 {
                    assert!(
                        _start <= 768u64 && _end >= 772u64,
                        "partial write for NVIC NVIC_IABR0 not implemented",
                    );
                    let start = _start.saturating_sub(768u64) as usize;
                    let end =
                        (_end.saturating_sub(768u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 776 && _end > 772 {
                    assert!(
                        _start <= 772u64 && _end >= 776u64,
                        "partial write for NVIC NVIC_IABR1 not implemented",
                    );
                    let start = _start.saturating_sub(772u64) as usize;
                    let end =
                        (_end.saturating_sub(772u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 780 && _end > 776 {
                    assert!(
                        _start <= 776u64 && _end >= 780u64,
                        "partial write for NVIC NVIC_IABR2 not implemented",
                    );
                    let start = _start.saturating_sub(776u64) as usize;
                    let end =
                        (_end.saturating_sub(776u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 784 && _end > 780 {
                    assert!(
                        _start <= 780u64 && _end >= 784u64,
                        "partial write for NVIC NVIC_IABR3 not implemented",
                    );
                    let start = _start.saturating_sub(780u64) as usize;
                    let end =
                        (_end.saturating_sub(780u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 788 && _end > 784 {
                    assert!(
                        _start <= 784u64 && _end >= 788u64,
                        "partial write for NVIC NVIC_IABR4 not implemented",
                    );
                    let start = _start.saturating_sub(784u64) as usize;
                    let end =
                        (_end.saturating_sub(784u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 792 && _end > 788 {
                    assert!(
                        _start <= 788u64 && _end >= 792u64,
                        "partial write for NVIC NVIC_IABR5 not implemented",
                    );
                    let start = _start.saturating_sub(788u64) as usize;
                    let end =
                        (_end.saturating_sub(788u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 796 && _end > 792 {
                    assert!(
                        _start <= 792u64 && _end >= 796u64,
                        "partial write for NVIC NVIC_IABR6 not implemented",
                    );
                    let start = _start.saturating_sub(792u64) as usize;
                    let end =
                        (_end.saturating_sub(792u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 800 && _end > 796 {
                    assert!(
                        _start <= 796u64 && _end >= 800u64,
                        "partial write for NVIC NVIC_IABR7 not implemented",
                    );
                    let start = _start.saturating_sub(796u64) as usize;
                    let end =
                        (_end.saturating_sub(796u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1024..=1263, 1025..=1264) => {
                if _start < 1028 && _end > 1024 {
                    let offset = 1024u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1024u64) as usize;
                    let end =
                        (_end.saturating_sub(1024u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr0(offset, &_buf[start..end])?;
                }
                if _start < 1032 && _end > 1028 {
                    let offset = 1028u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1028u64) as usize;
                    let end =
                        (_end.saturating_sub(1028u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr1(offset, &_buf[start..end])?;
                }
                if _start < 1036 && _end > 1032 {
                    let offset = 1032u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1032u64) as usize;
                    let end =
                        (_end.saturating_sub(1032u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr2(offset, &_buf[start..end])?;
                }
                if _start < 1040 && _end > 1036 {
                    let offset = 1036u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1036u64) as usize;
                    let end =
                        (_end.saturating_sub(1036u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr3(offset, &_buf[start..end])?;
                }
                if _start < 1044 && _end > 1040 {
                    let offset = 1040u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1040u64) as usize;
                    let end =
                        (_end.saturating_sub(1040u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr4(offset, &_buf[start..end])?;
                }
                if _start < 1048 && _end > 1044 {
                    let offset = 1044u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1044u64) as usize;
                    let end =
                        (_end.saturating_sub(1044u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr5(offset, &_buf[start..end])?;
                }
                if _start < 1052 && _end > 1048 {
                    let offset = 1048u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1048u64) as usize;
                    let end =
                        (_end.saturating_sub(1048u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr6(offset, &_buf[start..end])?;
                }
                if _start < 1056 && _end > 1052 {
                    let offset = 1052u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1052u64) as usize;
                    let end =
                        (_end.saturating_sub(1052u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr7(offset, &_buf[start..end])?;
                }
                if _start < 1060 && _end > 1056 {
                    let offset = 1056u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1056u64) as usize;
                    let end =
                        (_end.saturating_sub(1056u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr8(offset, &_buf[start..end])?;
                }
                if _start < 1064 && _end > 1060 {
                    let offset = 1060u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1060u64) as usize;
                    let end =
                        (_end.saturating_sub(1060u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr9(offset, &_buf[start..end])?;
                }
                if _start < 1068 && _end > 1064 {
                    let offset = 1064u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1064u64) as usize;
                    let end =
                        (_end.saturating_sub(1064u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr10(offset, &_buf[start..end])?;
                }
                if _start < 1072 && _end > 1068 {
                    let offset = 1068u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1068u64) as usize;
                    let end =
                        (_end.saturating_sub(1068u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr11(offset, &_buf[start..end])?;
                }
                if _start < 1076 && _end > 1072 {
                    let offset = 1072u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1072u64) as usize;
                    let end =
                        (_end.saturating_sub(1072u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr12(offset, &_buf[start..end])?;
                }
                if _start < 1080 && _end > 1076 {
                    let offset = 1076u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1076u64) as usize;
                    let end =
                        (_end.saturating_sub(1076u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr13(offset, &_buf[start..end])?;
                }
                if _start < 1084 && _end > 1080 {
                    let offset = 1080u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1080u64) as usize;
                    let end =
                        (_end.saturating_sub(1080u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr14(offset, &_buf[start..end])?;
                }
                if _start < 1088 && _end > 1084 {
                    let offset = 1084u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1084u64) as usize;
                    let end =
                        (_end.saturating_sub(1084u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr15(offset, &_buf[start..end])?;
                }
                if _start < 1092 && _end > 1088 {
                    let offset = 1088u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1088u64) as usize;
                    let end =
                        (_end.saturating_sub(1088u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr16(offset, &_buf[start..end])?;
                }
                if _start < 1096 && _end > 1092 {
                    let offset = 1092u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1092u64) as usize;
                    let end =
                        (_end.saturating_sub(1092u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr17(offset, &_buf[start..end])?;
                }
                if _start < 1100 && _end > 1096 {
                    let offset = 1096u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1096u64) as usize;
                    let end =
                        (_end.saturating_sub(1096u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr18(offset, &_buf[start..end])?;
                }
                if _start < 1104 && _end > 1100 {
                    let offset = 1100u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1100u64) as usize;
                    let end =
                        (_end.saturating_sub(1100u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr19(offset, &_buf[start..end])?;
                }
                if _start < 1108 && _end > 1104 {
                    let offset = 1104u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1104u64) as usize;
                    let end =
                        (_end.saturating_sub(1104u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr20(offset, &_buf[start..end])?;
                }
                if _start < 1112 && _end > 1108 {
                    let offset = 1108u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1108u64) as usize;
                    let end =
                        (_end.saturating_sub(1108u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr21(offset, &_buf[start..end])?;
                }
                if _start < 1116 && _end > 1112 {
                    let offset = 1112u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1112u64) as usize;
                    let end =
                        (_end.saturating_sub(1112u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr22(offset, &_buf[start..end])?;
                }
                if _start < 1120 && _end > 1116 {
                    let offset = 1116u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1116u64) as usize;
                    let end =
                        (_end.saturating_sub(1116u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr23(offset, &_buf[start..end])?;
                }
                if _start < 1124 && _end > 1120 {
                    let offset = 1120u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1120u64) as usize;
                    let end =
                        (_end.saturating_sub(1120u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr24(offset, &_buf[start..end])?;
                }
                if _start < 1128 && _end > 1124 {
                    let offset = 1124u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1124u64) as usize;
                    let end =
                        (_end.saturating_sub(1124u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr25(offset, &_buf[start..end])?;
                }
                if _start < 1132 && _end > 1128 {
                    let offset = 1128u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1128u64) as usize;
                    let end =
                        (_end.saturating_sub(1128u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr26(offset, &_buf[start..end])?;
                }
                if _start < 1136 && _end > 1132 {
                    let offset = 1132u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1132u64) as usize;
                    let end =
                        (_end.saturating_sub(1132u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr27(offset, &_buf[start..end])?;
                }
                if _start < 1140 && _end > 1136 {
                    let offset = 1136u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1136u64) as usize;
                    let end =
                        (_end.saturating_sub(1136u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr28(offset, &_buf[start..end])?;
                }
                if _start < 1144 && _end > 1140 {
                    let offset = 1140u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1140u64) as usize;
                    let end =
                        (_end.saturating_sub(1140u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr29(offset, &_buf[start..end])?;
                }
                if _start < 1148 && _end > 1144 {
                    let offset = 1144u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1144u64) as usize;
                    let end =
                        (_end.saturating_sub(1144u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr30(offset, &_buf[start..end])?;
                }
                if _start < 1152 && _end > 1148 {
                    let offset = 1148u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1148u64) as usize;
                    let end =
                        (_end.saturating_sub(1148u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr31(offset, &_buf[start..end])?;
                }
                if _start < 1156 && _end > 1152 {
                    let offset = 1152u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1152u64) as usize;
                    let end =
                        (_end.saturating_sub(1152u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr32(offset, &_buf[start..end])?;
                }
                if _start < 1160 && _end > 1156 {
                    let offset = 1156u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1156u64) as usize;
                    let end =
                        (_end.saturating_sub(1156u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr33(offset, &_buf[start..end])?;
                }
                if _start < 1164 && _end > 1160 {
                    let offset = 1160u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1160u64) as usize;
                    let end =
                        (_end.saturating_sub(1160u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr34(offset, &_buf[start..end])?;
                }
                if _start < 1168 && _end > 1164 {
                    let offset = 1164u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1164u64) as usize;
                    let end =
                        (_end.saturating_sub(1164u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr35(offset, &_buf[start..end])?;
                }
                if _start < 1172 && _end > 1168 {
                    let offset = 1168u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1168u64) as usize;
                    let end =
                        (_end.saturating_sub(1168u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr36(offset, &_buf[start..end])?;
                }
                if _start < 1176 && _end > 1172 {
                    let offset = 1172u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1172u64) as usize;
                    let end =
                        (_end.saturating_sub(1172u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr37(offset, &_buf[start..end])?;
                }
                if _start < 1180 && _end > 1176 {
                    let offset = 1176u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1176u64) as usize;
                    let end =
                        (_end.saturating_sub(1176u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr38(offset, &_buf[start..end])?;
                }
                if _start < 1184 && _end > 1180 {
                    let offset = 1180u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1180u64) as usize;
                    let end =
                        (_end.saturating_sub(1180u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr39(offset, &_buf[start..end])?;
                }
                if _start < 1188 && _end > 1184 {
                    let offset = 1184u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1184u64) as usize;
                    let end =
                        (_end.saturating_sub(1184u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr40(offset, &_buf[start..end])?;
                }
                if _start < 1192 && _end > 1188 {
                    let offset = 1188u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1188u64) as usize;
                    let end =
                        (_end.saturating_sub(1188u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr41(offset, &_buf[start..end])?;
                }
                if _start < 1196 && _end > 1192 {
                    let offset = 1192u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1192u64) as usize;
                    let end =
                        (_end.saturating_sub(1192u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr42(offset, &_buf[start..end])?;
                }
                if _start < 1200 && _end > 1196 {
                    let offset = 1196u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1196u64) as usize;
                    let end =
                        (_end.saturating_sub(1196u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr43(offset, &_buf[start..end])?;
                }
                if _start < 1204 && _end > 1200 {
                    let offset = 1200u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1200u64) as usize;
                    let end =
                        (_end.saturating_sub(1200u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr44(offset, &_buf[start..end])?;
                }
                if _start < 1208 && _end > 1204 {
                    let offset = 1204u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1204u64) as usize;
                    let end =
                        (_end.saturating_sub(1204u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr45(offset, &_buf[start..end])?;
                }
                if _start < 1212 && _end > 1208 {
                    let offset = 1208u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1208u64) as usize;
                    let end =
                        (_end.saturating_sub(1208u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr46(offset, &_buf[start..end])?;
                }
                if _start < 1216 && _end > 1212 {
                    let offset = 1212u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1212u64) as usize;
                    let end =
                        (_end.saturating_sub(1212u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr47(offset, &_buf[start..end])?;
                }
                if _start < 1220 && _end > 1216 {
                    let offset = 1216u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1216u64) as usize;
                    let end =
                        (_end.saturating_sub(1216u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr48(offset, &_buf[start..end])?;
                }
                if _start < 1224 && _end > 1220 {
                    let offset = 1220u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1220u64) as usize;
                    let end =
                        (_end.saturating_sub(1220u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr49(offset, &_buf[start..end])?;
                }
                if _start < 1228 && _end > 1224 {
                    let offset = 1224u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1224u64) as usize;
                    let end =
                        (_end.saturating_sub(1224u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr50(offset, &_buf[start..end])?;
                }
                if _start < 1232 && _end > 1228 {
                    let offset = 1228u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1228u64) as usize;
                    let end =
                        (_end.saturating_sub(1228u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr51(offset, &_buf[start..end])?;
                }
                if _start < 1236 && _end > 1232 {
                    let offset = 1232u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1232u64) as usize;
                    let end =
                        (_end.saturating_sub(1232u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr52(offset, &_buf[start..end])?;
                }
                if _start < 1240 && _end > 1236 {
                    let offset = 1236u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1236u64) as usize;
                    let end =
                        (_end.saturating_sub(1236u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr53(offset, &_buf[start..end])?;
                }
                if _start < 1244 && _end > 1240 {
                    let offset = 1240u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1240u64) as usize;
                    let end =
                        (_end.saturating_sub(1240u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr54(offset, &_buf[start..end])?;
                }
                if _start < 1248 && _end > 1244 {
                    let offset = 1244u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1244u64) as usize;
                    let end =
                        (_end.saturating_sub(1244u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr55(offset, &_buf[start..end])?;
                }
                if _start < 1252 && _end > 1248 {
                    let offset = 1248u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1248u64) as usize;
                    let end =
                        (_end.saturating_sub(1248u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr56(offset, &_buf[start..end])?;
                }
                if _start < 1256 && _end > 1252 {
                    let offset = 1252u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1252u64) as usize;
                    let end =
                        (_end.saturating_sub(1252u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr57(offset, &_buf[start..end])?;
                }
                if _start < 1260 && _end > 1256 {
                    let offset = 1256u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1256u64) as usize;
                    let end =
                        (_end.saturating_sub(1256u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr58(offset, &_buf[start..end])?;
                }
                if _start < 1264 && _end > 1260 {
                    let offset = 1260u64.saturating_sub(_start);
                    let start = _start.saturating_sub(1260u64) as usize;
                    let end =
                        (_end.saturating_sub(1260u64) as usize).min(start + 4);
                    self.write_nvic_nvic_ipr59(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (3328..=3443, 3329..=3444) => {
                if _start < 3336 && _end > 3332 {
                    let offset = 3332u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3332u64) as usize;
                    let end =
                        (_end.saturating_sub(3332u64) as usize).min(start + 4);
                    self.write_control_icsr(offset, &_buf[start..end])?;
                }
                if _start < 3340 && _end > 3336 {
                    let offset = 3336u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3336u64) as usize;
                    let end =
                        (_end.saturating_sub(3336u64) as usize).min(start + 4);
                    self.write_control_vtor(offset, &_buf[start..end])?;
                }
                if _start < 3344 && _end > 3340 {
                    let offset = 3340u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3340u64) as usize;
                    let end =
                        (_end.saturating_sub(3340u64) as usize).min(start + 4);
                    self.write_control_aircr(offset, &_buf[start..end])?;
                }
                if _start < 3348 && _end > 3344 {
                    let offset = 3344u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3344u64) as usize;
                    let end =
                        (_end.saturating_sub(3344u64) as usize).min(start + 4);
                    self.write_control_scr(offset, &_buf[start..end])?;
                }
                if _start < 3352 && _end > 3348 {
                    let offset = 3348u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3348u64) as usize;
                    let end =
                        (_end.saturating_sub(3348u64) as usize).min(start + 4);
                    self.write_control_ccr(offset, &_buf[start..end])?;
                }
                if _start < 3356 && _end > 3352 {
                    let offset = 3352u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3352u64) as usize;
                    let end =
                        (_end.saturating_sub(3352u64) as usize).min(start + 4);
                    self.write_control_shpr1(offset, &_buf[start..end])?;
                }
                if _start < 3360 && _end > 3356 {
                    let offset = 3356u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3356u64) as usize;
                    let end =
                        (_end.saturating_sub(3356u64) as usize).min(start + 4);
                    self.write_control_shpr2(offset, &_buf[start..end])?;
                }
                if _start < 3364 && _end > 3360 {
                    let offset = 3360u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3360u64) as usize;
                    let end =
                        (_end.saturating_sub(3360u64) as usize).min(start + 4);
                    self.write_control_shpr3(offset, &_buf[start..end])?;
                }
                if _start < 3368 && _end > 3364 {
                    let offset = 3364u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3364u64) as usize;
                    let end =
                        (_end.saturating_sub(3364u64) as usize).min(start + 4);
                    self.write_control_shcsr(offset, &_buf[start..end])?;
                }
                if _start < 3372 && _end > 3368 {
                    let offset = 3368u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3368u64) as usize;
                    let end =
                        (_end.saturating_sub(3368u64) as usize).min(start + 4);
                    self.write_control_cfsr(offset, &_buf[start..end])?;
                }
                if _start < 3376 && _end > 3372 {
                    let offset = 3372u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3372u64) as usize;
                    let end =
                        (_end.saturating_sub(3372u64) as usize).min(start + 4);
                    self.write_control_hfsr(offset, &_buf[start..end])?;
                }
                if _start < 3380 && _end > 3376 {
                    let offset = 3376u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3376u64) as usize;
                    let end =
                        (_end.saturating_sub(3376u64) as usize).min(start + 4);
                    self.write_control_dfsr(offset, &_buf[start..end])?;
                }
                if _start < 3384 && _end > 3380 {
                    assert!(
                        _start <= 3380u64 && _end >= 3384u64,
                        "partial write for Control MMFAR not implemented",
                    );
                    let start = _start.saturating_sub(3380u64) as usize;
                    let end =
                        (_end.saturating_sub(3380u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_control_mmfar(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 3388 && _end > 3384 {
                    assert!(
                        _start <= 3384u64 && _end >= 3388u64,
                        "partial write for Control BFAR not implemented",
                    );
                    let start = _start.saturating_sub(3384u64) as usize;
                    let end =
                        (_end.saturating_sub(3384u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_control_bfar(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 3392 && _end > 3388 {
                    assert!(
                        _start <= 3388u64 && _end >= 3392u64,
                        "partial write for Control AFSR not implemented",
                    );
                    let start = _start.saturating_sub(3388u64) as usize;
                    let end =
                        (_end.saturating_sub(3388u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_control_afsr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 3332 && _end > 3328 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3396 && _end > 3392 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3400 && _end > 3396 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3404 && _end > 3400 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3408 && _end > 3404 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3412 && _end > 3408 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3416 && _end > 3412 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3420 && _end > 3416 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3424 && _end > 3420 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3428 && _end > 3424 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3432 && _end > 3428 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3436 && _end > 3432 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3440 && _end > 3436 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3444 && _end > 3440 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (3464..=3467, 3465..=3468) => {
                if _start < 3468 && _end > 3464 {
                    let offset = 3464u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3464u64) as usize;
                    let end =
                        (_end.saturating_sub(3464u64) as usize).min(start + 4);
                    self.write_control_cpacr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (3472..=3515, 3473..=3516) => {
                if _start < 3476 && _end > 3472 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3480 && _end > 3476 {
                    let offset = 3476u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3476u64) as usize;
                    let end =
                        (_end.saturating_sub(3476u64) as usize).min(start + 4);
                    self.write_mpu_mpu_ctrl(offset, &_buf[start..end])?;
                }
                if _start < 3484 && _end > 3480 {
                    let offset = 3480u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3480u64) as usize;
                    let end =
                        (_end.saturating_sub(3480u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rnr(offset, &_buf[start..end])?;
                }
                if _start < 3488 && _end > 3484 {
                    let offset = 3484u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3484u64) as usize;
                    let end =
                        (_end.saturating_sub(3484u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rbar(offset, &_buf[start..end])?;
                }
                if _start < 3492 && _end > 3488 {
                    let offset = 3488u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3488u64) as usize;
                    let end =
                        (_end.saturating_sub(3488u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rasr(offset, &_buf[start..end])?;
                }
                if _start < 3496 && _end > 3492 {
                    let offset = 3492u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3492u64) as usize;
                    let end =
                        (_end.saturating_sub(3492u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rbar_a1(offset, &_buf[start..end])?;
                }
                if _start < 3500 && _end > 3496 {
                    let offset = 3496u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3496u64) as usize;
                    let end =
                        (_end.saturating_sub(3496u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rasr_a1(offset, &_buf[start..end])?;
                }
                if _start < 3504 && _end > 3500 {
                    let offset = 3500u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3500u64) as usize;
                    let end =
                        (_end.saturating_sub(3500u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rbar_a2(offset, &_buf[start..end])?;
                }
                if _start < 3508 && _end > 3504 {
                    let offset = 3504u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3504u64) as usize;
                    let end =
                        (_end.saturating_sub(3504u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rasr_a2(offset, &_buf[start..end])?;
                }
                if _start < 3512 && _end > 3508 {
                    let offset = 3508u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3508u64) as usize;
                    let end =
                        (_end.saturating_sub(3508u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rbar_a3(offset, &_buf[start..end])?;
                }
                if _start < 3516 && _end > 3512 {
                    let offset = 3512u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3512u64) as usize;
                    let end =
                        (_end.saturating_sub(3512u64) as usize).min(start + 4);
                    self.write_mpu_mpu_rasr_a3(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (3580..=3583, 3581..=3584) => return Err(MemError::WriteViolation),
            (3840..=3843, 3841..=3844) => {
                if _start < 3844 && _end > 3840 {
                    let offset = 3840u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3840u64) as usize;
                    let end =
                        (_end.saturating_sub(3840u64) as usize).min(start + 4);
                    self.write_control_stir(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (3892..=3911, 3893..=3912) => {
                if _start < 3896 && _end > 3892 {
                    let offset = 3892u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3892u64) as usize;
                    let end =
                        (_end.saturating_sub(3892u64) as usize).min(start + 4);
                    self.write_fpe_fpccr(offset, &_buf[start..end])?;
                }
                if _start < 3900 && _end > 3896 {
                    assert!(
                        _start <= 3896u64 && _end >= 3900u64,
                        "partial write for FPE FPCAR not implemented",
                    );
                    let start = _start.saturating_sub(3896u64) as usize;
                    let end =
                        (_end.saturating_sub(3896u64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_fpe_fpcar(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 3904 && _end > 3900 {
                    let offset = 3900u64.saturating_sub(_start);
                    let start = _start.saturating_sub(3900u64) as usize;
                    let end =
                        (_end.saturating_sub(3900u64) as usize).min(start + 4);
                    self.write_fpe_fpdscr(offset, &_buf[start..end])?;
                }
                if _start < 3908 && _end > 3904 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3912 && _end > 3908 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0xE000E000 {
    fn read_control_actlr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_disoofp()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_disfpca()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_disfold()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_disdefwbuf()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_dismcycint()?)
                << 0u32;
        Ok(_value)
    }
    fn write_control_actlr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_disoofp((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_disfpca((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_disfold((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_disdefwbuf((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_dismcycint((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_icsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_nmipendset()?)
                << 31u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_pendsvset()?)
                << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_pendsvclr()?)
                << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_pendstset()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_pendstclr()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_isrpreempt()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_isrpending()?)
                << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_vectpending()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_rettobase()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_vectactive()?)
                << 0u32;
        Ok(_value)
    }
    fn write_control_icsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_nmipendset((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_pendsvset((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_pendsvclr((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_pendstset((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_pendstclr((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_isrpreempt((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_isrpending((_value[_i] >> 6) & 1 != 0)?;
        }
        if _start <= 1 && _end >= 3 {
            let mut _extracted: u16 = 0;
            _extracted |= ((_value[(1 - _start) as usize] >> 4) & 15u8) as u16;
            _extracted |= ((_value[((1 + 0 + 1) - _start) as usize] & 31u8)
                as u16)
                << (4 + (0 * 8));
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_vectpending(_extracted)?;
        } else if (_start > 1 && _start < 3) || (_end > 1 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_rettobase((_value[_i] >> 3) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 1u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_vectactive(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_control_vtor(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_control_vtor_tbloff()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_vtor_tblbase()?)
                << 29u32;
        Ok(_value)
    }
    fn write_control_vtor(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 7) & 1u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (7 + (byte_i * 8));
            }
            self.0
                .lock()
                .unwrap()
                .write_control_vtor_tbloff(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_vtor_tblbase((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_demcr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_demcr_mon_en()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_demcr_mon_pend()?)
                << 17u32;
        Ok(_value)
    }
    fn read_control_aircr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_aircr_vectkey()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_aircr_endianness()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_aircr_prigroup()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_aircr_sysresetreq()?)
                << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_aircr_vectclractive()?,
        ) << 1u32;
        Ok(_value)
    }
    fn write_control_aircr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 2 && _end >= 4 {
            let _offset_start = (2 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_control_aircr_vectkey(_value)?;
        } else if (_start > 2 && _start < 4) || (_end > 2 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_aircr_endianness((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_aircr_prigroup((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_aircr_sysresetreq((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0.lock().unwrap().write_control_aircr_vectclractive(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_control_scr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_scr_sevonpend()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_scr_sleepdeep()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_scr_sleeponexit()?)
                << 1u32;
        Ok(_value)
    }
    fn write_control_scr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_scr_sevonpend((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_scr_sleepdeep((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_scr_sleeponexit((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_ccr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_stkalign()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_bfhfnmign()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_div_0_trp()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_unalign_trp()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_usersetmpend()?)
                << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_ccr_nonbasethrdena()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_control_ccr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_stkalign((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_bfhfnmign((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_div_0_trp((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_unalign_trp((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_usersetmpend((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_nonbasethrdena((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_shpr1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr1_pri_7()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr1_pri_6()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr1_pri_5()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr1_pri_4()?)
            << 0u32;
        Ok(_value)
    }
    fn write_control_shpr1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr1_pri_7((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr1_pri_6((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr1_pri_5((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr1_pri_4((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_control_shpr2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr2_pri_11()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr2_pri_10()?)
                << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr2_pri_9()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr2_pri_8()?)
            << 0u32;
        Ok(_value)
    }
    fn write_control_shpr2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr2_pri_11((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr2_pri_10((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr2_pri_9((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr2_pri_8((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_control_shpr3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr3_pri_15()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr3_pri_14()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr3_pri_13()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr3_pri_12()?)
                << 0u32;
        Ok(_value)
    }
    fn write_control_shpr3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr3_pri_15((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr3_pri_14((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr3_pri_13((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr3_pri_12((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_control_shcsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_usgfaultena()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_busfaultena()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_memfaultena()?)
                << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_shcsr_svcallpended()?,
        ) << 15u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_shcsr_busfaultpended()?,
        ) << 14u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_shcsr_memfaultpended()?,
        ) << 13u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_shcsr_usgfaultpended()?,
        ) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_systickact()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_pendsvact()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_monitoract()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_svcallact()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_usgfaultact()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_busfaultact()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_memfaultact()?)
                << 0u32;
        Ok(_value)
    }
    fn write_control_shcsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_usgfaultena((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_busfaultena((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_memfaultena((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_svcallpended((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0.lock().unwrap().write_control_shcsr_busfaultpended(
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0.lock().unwrap().write_control_shcsr_memfaultpended(
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0.lock().unwrap().write_control_shcsr_usgfaultpended(
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_systickact((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_pendsvact((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_monitoract((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_svcallact((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_usgfaultact((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_busfaultact((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_memfaultact((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_cfsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_divbyzero()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_unaligned()?)
                << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cfsr_nocp()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cfsr_invpc()?)
            << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_invstate()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_undefinstr()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_bfarvalid()?)
                << 15u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cfsr_lsperr()?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cfsr_stkerr()?)
            << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_unstkerr()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_impreciserr()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_preciserr()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_ibuserr()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_mmarvalid()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_mlsperr()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_mstkerr()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_munstkerr()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_daccviol()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_iaccviol()?)
                << 0u32;
        Ok(_value)
    }
    fn write_control_cfsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_divbyzero((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_unaligned((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_nocp((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_invpc((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_invstate((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_undefinstr((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_bfarvalid((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_lsperr((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_stkerr((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_unstkerr((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_impreciserr((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_preciserr((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_ibuserr((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_mmarvalid((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_mlsperr((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_mstkerr((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_munstkerr((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_daccviol((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_iaccviol((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_hfsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_hfsr_debugevt()?)
                << 31u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_hfsr_forced()?)
            << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_hfsr_vecttbl()?)
                << 1u32;
        Ok(_value)
    }
    fn write_control_hfsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_hfsr_debugevt((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_hfsr_forced((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_hfsr_vecttbl((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_dfsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_dfsr_external()?)
                << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_dfsr_vcatch()?)
            << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_dfsr_dwttrap()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_dfsr_bkpt()?) << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_dfsr_halted()?)
            << 0u32;
        Ok(_value)
    }
    fn write_control_dfsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_external((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_vcatch((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_dwttrap((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_bkpt((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_halted((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_cpacr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp11()?)
            << 22u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp10()?)
            << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp7()?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp6()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp5()?)
            << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp4()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp3()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp2()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp1()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp0()?) << 0u32;
        Ok(_value)
    }
    fn write_control_cpacr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp11((_value[_i] >> 6) & 3u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp10((_value[_i] >> 4) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp7((_value[_i] >> 6) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp6((_value[_i] >> 4) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp5((_value[_i] >> 2) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp4((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp3((_value[_i] >> 6) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp2((_value[_i] >> 4) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp1((_value[_i] >> 2) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp0((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn write_control_stir(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 1u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_control_stir_intid(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_id_cpuid(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_cpuid_implementer()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_cpuid_variant()?) << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_id_cpuid_constant()?)
            << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_cpuid_partno()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_cpuid_revision()?) << 0u32;
        Ok(_value)
    }
    fn read_id_id_pfr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_pfr0_state1()?) << 4u32;
        Ok(_value)
    }
    fn read_id_id_pfr1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_pfr1_m_profile()?)
                << 8u32;
        Ok(_value)
    }
    fn read_id_id_dfr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_dfr0_m_profile()?)
                << 20u32;
        Ok(_value)
    }
    fn read_id_id_mmfr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_mmfr0_auxiliary_registers()?,
        ) << 20u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_mmfr0_shareability_levels()?,
        ) << 12u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_mmfr0_outermost_shareability()?,
        ) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_mmfr0_pmsa()?) << 4u32;
        Ok(_value)
    }
    fn read_id_id_mmfr2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_mmfr2_wfi()?) << 24u32;
        Ok(_value)
    }
    fn read_id_id_isar0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar0_divide_instrs()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar0_debug_instrs()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar0_coproc_instrs()?)
                << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar0_cmpbranch_instrs()?,
        ) << 12u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar0_bitfield_instrs()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar0_bitcount_instrs()?,
        ) << 4u32;
        Ok(_value)
    }
    fn read_id_id_isar1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar1_interwork_instrs()?,
        ) << 24u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar1_immediate_instrs()?,
        ) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar1_ifthen_instrs()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar1_extend_instrs()?)
                << 12u32;
        Ok(_value)
    }
    fn read_id_id_isar2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar2_reversal_instrs()?,
        ) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar2_multu_instrs()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar2_mults_instrs()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar2_mult_instrs()?)
                << 12u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_isar2_multiaccessint_instrs()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar2_memhint_instrs()?,
        ) << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar2_loadstore_instrs()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_id_id_isar3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_truenop_instrs()?,
        ) << 24u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_thumbcopy_instrs()?,
        ) << 20u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_tabbranch_instrs()?,
        ) << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_synchprim_instrs()?,
        ) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar3_svc_instrs()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar3_simd_instrs()?)
                << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_saturate_instrs()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_id_id_isar4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar4_psr_m_instrs()?)
                << 24u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_isar4_synchprim_instrs_frac()?,
        ) << 20u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar4_barrier_instrs()?,
        ) << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar4_writeback_instrs()?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_isar4_withshifts_instrs()?,
        ) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar4_unpriv_instrs()?)
                << 0u32;
        Ok(_value)
    }
    fn read_fpe_fpccr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_aspen()?) << 31u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_lspen()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_monrdy()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_bfrdy()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_mmrdy()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_hfrdy()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_thread()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_user()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_lspact()?) << 0u32;
        Ok(_value)
    }
    fn write_fpe_fpccr(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_aspen((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_lspen((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_monrdy((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_bfrdy((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_mmrdy((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_hfrdy((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_thread((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_user((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_lspact((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_fpe_fpdscr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpdscr_ahp()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpdscr_dn()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpdscr_fz()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpdscr_rmode()?) << 22u32;
        Ok(_value)
    }
    fn write_fpe_fpdscr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpdscr_ahp((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpdscr_dn((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpdscr_fz((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpdscr_rmode((_value[_i] >> 6) & 3u8)?;
        }
        Ok(())
    }
    fn read_fpe_mvfr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_fpe_mvfr0_fp_rounding_modes()?,
        ) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr0_short_vectors()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr0_square_root()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr0_divide()?) << 16u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_fpe_mvfr0_fp_exception_trapping()?,
        ) << 12u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_fpe_mvfr0_double_precision()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_fpe_mvfr0_single_precision()?,
        ) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr0_a_simd()?) << 0u32;
        Ok(_value)
    }
    fn read_fpe_mvfr1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr1_fp_fused_mac()?)
                << 28u32;
        _value |= u32::from(self.0.lock().unwrap().read_fpe_mvfr1_fp_hpfp()?)
            << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr1_d_nan()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr1_ftz()?) << 0u32;
        Ok(_value)
    }
    fn read_systick_stcsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcsr_countflag()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcsr_clksource()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcsr_tickint()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcsr_enable()?)
                << 0u32;
        Ok(_value)
    }
    fn write_systick_stcsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_systick_stcsr_countflag((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_systick_stcsr_clksource((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_systick_stcsr_tickint((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_systick_stcsr_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_systick_strvr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_strvr_reload()?)
                << 0u32;
        Ok(_value)
    }
    fn write_systick_strvr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_systick_strvr_reload(_value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_systick_stcvr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcvr_current()?)
                << 0u32;
        Ok(_value)
    }
    fn write_systick_stcvr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_systick_stcvr_current(_value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_systick_stcr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_systick_stcr_noref()?)
            << 31u32;
        _value |= u32::from(self.0.lock().unwrap().read_systick_stcr_skew()?)
            << 30u32;
        _value |= u32::from(self.0.lock().unwrap().read_systick_stcr_tenms()?)
            << 0u32;
        Ok(_value)
    }
    fn read_nvic_ictr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_ictr_intlinesnum()?)
                << 0u32;
        Ok(_value)
    }
    fn read_nvic_nvic_ipr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr0_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr0_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr0_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr0_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr0_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr0_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr0_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr0_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr1_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr1_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr1_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr1_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr1_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr1_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr1_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr1_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr2_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr2_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr2_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr2_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr2_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr2_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr2_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr2_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr3_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr3_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr3_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr3_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr3_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr3_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr3_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr3_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr4_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr4_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr4_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr4_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr4(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr4_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr4_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr4_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr4_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr5(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr5_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr5_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr5_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr5_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr5(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr5_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr5_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr5_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr5_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr6(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr6_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr6_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr6_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr6_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr6(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr6_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr6_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr6_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr6_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr7(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr7_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr7_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr7_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr7_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr7(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr7_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr7_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr7_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr7_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr8(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr8_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr8_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr8_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr8_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr8(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr8_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr8_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr8_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr8_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr9(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr9_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr9_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr9_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr9_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr9(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr9_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr9_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr9_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr9_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr10(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr10_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr10_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr10_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr10_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr10(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr10_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr10_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr10_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr10_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr11(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr11_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr11_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr11_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr11_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr11(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr11_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr11_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr11_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr11_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr12(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr12_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr12_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr12_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr12_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr12(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr12_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr12_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr12_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr12_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr13(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr13_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr13_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr13_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr13_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr13(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr13_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr13_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr13_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr13_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr14(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr14_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr14_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr14_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr14_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr14(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr14_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr14_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr14_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr14_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr15(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr15_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr15_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr15_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr15_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr15(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr15_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr15_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr15_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr15_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr16(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr16_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr16_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr16_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr16_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr16(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr16_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr16_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr16_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr16_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr17(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr17_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr17_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr17_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr17_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr17(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr17_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr17_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr17_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr17_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr18(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr18_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr18_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr18_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr18_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr18(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr18_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr18_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr18_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr18_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr19(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr19_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr19_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr19_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr19_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr19(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr19_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr19_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr19_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr19_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr20(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr20_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr20_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr20_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr20_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr20(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr20_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr20_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr20_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr20_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr21(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr21_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr21_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr21_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr21_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr21(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr21_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr21_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr21_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr21_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr22(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr22_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr22_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr22_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr22_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr22(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr22_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr22_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr22_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr22_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr23(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr23_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr23_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr23_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr23_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr23(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr23_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr23_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr23_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr23_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr24(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr24_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr24_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr24_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr24_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr24(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr24_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr24_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr24_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr24_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr25(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr25_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr25_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr25_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr25_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr25(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr25_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr25_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr25_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr25_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr26(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr26_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr26_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr26_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr26_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr26(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr26_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr26_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr26_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr26_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr27(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr27_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr27_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr27_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr27_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr27(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr27_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr27_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr27_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr27_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr28(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr28_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr28_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr28_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr28_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr28(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr28_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr28_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr28_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr28_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr29(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr29_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr29_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr29_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr29_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr29(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr29_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr29_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr29_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr29_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr30(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr30_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr30_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr30_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr30_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr30(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr30_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr30_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr30_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr30_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr31(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr31_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr31_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr31_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr31_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr31(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr31_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr31_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr31_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr31_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr32(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr32_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr32_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr32_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr32_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr32(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr32_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr32_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr32_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr32_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr33(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr33_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr33_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr33_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr33_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr33(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr33_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr33_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr33_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr33_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr34(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr34_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr34_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr34_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr34_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr34(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr34_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr34_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr34_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr34_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr35(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr35_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr35_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr35_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr35_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr35(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr35_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr35_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr35_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr35_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr36(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr36_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr36_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr36_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr36_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr36(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr36_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr36_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr36_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr36_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr37(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr37_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr37_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr37_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr37_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr37(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr37_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr37_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr37_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr37_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr38(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr38_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr38_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr38_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr38_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr38(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr38_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr38_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr38_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr38_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr39(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr39_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr39_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr39_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr39_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr39(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr39_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr39_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr39_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr39_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr40(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr40_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr40_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr40_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr40_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr40(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr40_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr40_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr40_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr40_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr41(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr41_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr41_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr41_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr41_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr41(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr41_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr41_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr41_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr41_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr42(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr42_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr42_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr42_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr42_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr42(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr42_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr42_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr42_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr42_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr43(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr43_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr43_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr43_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr43_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr43(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr43_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr43_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr43_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr43_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr44(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr44_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr44_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr44_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr44_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr44(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr44_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr44_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr44_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr44_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr45(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr45_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr45_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr45_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr45_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr45(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr45_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr45_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr45_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr45_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr46(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr46_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr46_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr46_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr46_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr46(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr46_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr46_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr46_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr46_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr47(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr47_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr47_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr47_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr47_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr47(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr47_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr47_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr47_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr47_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr48(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr48_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr48_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr48_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr48_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr48(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr48_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr48_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr48_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr48_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr49(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr49_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr49_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr49_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr49_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr49(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr49_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr49_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr49_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr49_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr50(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr50_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr50_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr50_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr50_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr50(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr50_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr50_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr50_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr50_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr51(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr51_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr51_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr51_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr51_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr51(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr51_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr51_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr51_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr51_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr52(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr52_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr52_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr52_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr52_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr52(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr52_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr52_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr52_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr52_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr53(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr53_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr53_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr53_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr53_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr53(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr53_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr53_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr53_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr53_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr54(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr54_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr54_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr54_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr54_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr54(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr54_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr54_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr54_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr54_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr55(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr55_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr55_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr55_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr55_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr55(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr55_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr55_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr55_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr55_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr56(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr56_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr56_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr56_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr56_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr56(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr56_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr56_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr56_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr56_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr57(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr57_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr57_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr57_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr57_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr57(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr57_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr57_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr57_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr57_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr58(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr58_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr58_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr58_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr58_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr58(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr58_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr58_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr58_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr58_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr59(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr59_pri_n3()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr59_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr59_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr59_pri_n0()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr59(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr59_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr59_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr59_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr59_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_type(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_type_separate()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_type_dregion()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_type_iregion()?)
                << 16u32;
        Ok(_value)
    }
    fn read_mpu_mpu_ctrl(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_ctrl_enable()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_ctrl_hfnmiena()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_ctrl_privdefena()?)
                << 2u32;
        Ok(_value)
    }
    fn write_mpu_mpu_ctrl(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_ctrl_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_ctrl_hfnmiena((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_ctrl_privdefena((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rnr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rnr_region()?)
            << 0u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rnr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rnr_region((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rbar(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_region()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_valid()?)
            << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_addr()?) << 5u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rbar(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_region((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_valid((_value[_i] >> 4) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 5) & 7u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (5 + (byte_i * 8));
            }
            self.0.lock().unwrap().write_mpu_mpu_rbar_addr(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_mpu_mpu_rasr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_enable()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_size()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_srd()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_b()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_c()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_s()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_tex()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_ap()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_xn()?) << 28u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rasr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_size((_value[_i] >> 1) & 31u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_srd((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_b((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_c((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_s((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_tex((_value[_i] >> 3) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_ap((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_xn((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rbar_a1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a1_region()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a1_valid()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a1_addr()?)
                << 5u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rbar_a1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a1_region((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a1_valid((_value[_i] >> 4) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 5) & 7u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (5 + (byte_i * 8));
            }
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a1_addr(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_mpu_mpu_rasr_a1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_enable()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_size()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_srd()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_b()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_c()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_s()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_tex()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_ap()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_xn()?)
            << 28u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rasr_a1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_size((_value[_i] >> 1) & 31u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_srd((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_b((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_c((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_s((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_tex((_value[_i] >> 3) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_ap((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_xn((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rbar_a2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a2_region()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a2_valid()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a2_addr()?)
                << 5u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rbar_a2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a2_region((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a2_valid((_value[_i] >> 4) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 5) & 7u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (5 + (byte_i * 8));
            }
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a2_addr(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_mpu_mpu_rasr_a2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_enable()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_size()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_srd()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_b()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_c()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_s()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_tex()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_ap()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_xn()?)
            << 28u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rasr_a2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_size((_value[_i] >> 1) & 31u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_srd((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_b((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_c((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_s((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_tex((_value[_i] >> 3) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_ap((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_xn((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rbar_a3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a3_region()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a3_valid()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a3_addr()?)
                << 5u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rbar_a3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a3_region((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a3_valid((_value[_i] >> 4) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 5) & 7u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (5 + (byte_i * 8));
            }
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a3_addr(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_mpu_mpu_rasr_a3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_enable()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_size()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_srd()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_b()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_c()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_s()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_tex()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_ap()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_xn()?)
            << 28u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rasr_a3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (_start - 0) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_size((_value[_i] >> 1) & 31u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (_start - 1) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_srd((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_b((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_c((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_s((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (_start - 2) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_tex((_value[_i] >> 3) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_ap((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (_start - 3) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_xn((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
}
