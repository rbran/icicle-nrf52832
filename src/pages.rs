use icicle_vm::cpu::mem::{MemError, MemResult};
pub(crate) struct PeripheralPage0x10000000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x10000000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 268435456;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (16..=23, 17..=24) => {
                if _start < 20 && _end > 16 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_codepagesize()?
                        .to_ne_bytes();
                    if _start <= 16 && _end > 16 {
                        _buf[(16 - _start) as usize] = _value[0];
                    }
                    if _start <= 17 && _end > 17 {
                        _buf[(17 - _start) as usize] = _value[1];
                    }
                    if _start <= 18 && _end > 18 {
                        _buf[(18 - _start) as usize] = _value[2];
                    }
                    if _start <= 19 && _end > 19 {
                        _buf[(19 - _start) as usize] = _value[3];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_codesize()?
                        .to_ne_bytes();
                    if _start <= 20 && _end > 20 {
                        _buf[(20 - _start) as usize] = _value[0];
                    }
                    if _start <= 21 && _end > 21 {
                        _buf[(21 - _start) as usize] = _value[1];
                    }
                    if _start <= 22 && _end > 22 {
                        _buf[(22 - _start) as usize] = _value[2];
                    }
                    if _start <= 23 && _end > 23 {
                        _buf[(23 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (96..=103, 97..=104) => {
                if _start < 100 && _end > 96 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_deviceidn(0)?
                        .to_ne_bytes();
                    if _start <= 96 && _end > 96 {
                        _buf[(96 - _start) as usize] = _value[0];
                    }
                    if _start <= 97 && _end > 97 {
                        _buf[(97 - _start) as usize] = _value[1];
                    }
                    if _start <= 98 && _end > 98 {
                        _buf[(98 - _start) as usize] = _value[2];
                    }
                    if _start <= 99 && _end > 99 {
                        _buf[(99 - _start) as usize] = _value[3];
                    }
                }
                if _start < 104 && _end > 100 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_deviceidn(1)?
                        .to_ne_bytes();
                    if _start <= 100 && _end > 100 {
                        _buf[(100 - _start) as usize] = _value[0];
                    }
                    if _start <= 101 && _end > 101 {
                        _buf[(101 - _start) as usize] = _value[1];
                    }
                    if _start <= 102 && _end > 102 {
                        _buf[(102 - _start) as usize] = _value[2];
                    }
                    if _start <= 103 && _end > 103 {
                        _buf[(103 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (128..=171, 129..=172) => {
                if _start < 132 && _end > 128 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_ern(0)?.to_ne_bytes();
                    if _start <= 128 && _end > 128 {
                        _buf[(128 - _start) as usize] = _value[0];
                    }
                    if _start <= 129 && _end > 129 {
                        _buf[(129 - _start) as usize] = _value[1];
                    }
                    if _start <= 130 && _end > 130 {
                        _buf[(130 - _start) as usize] = _value[2];
                    }
                    if _start <= 131 && _end > 131 {
                        _buf[(131 - _start) as usize] = _value[3];
                    }
                }
                if _start < 136 && _end > 132 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_ern(1)?.to_ne_bytes();
                    if _start <= 132 && _end > 132 {
                        _buf[(132 - _start) as usize] = _value[0];
                    }
                    if _start <= 133 && _end > 133 {
                        _buf[(133 - _start) as usize] = _value[1];
                    }
                    if _start <= 134 && _end > 134 {
                        _buf[(134 - _start) as usize] = _value[2];
                    }
                    if _start <= 135 && _end > 135 {
                        _buf[(135 - _start) as usize] = _value[3];
                    }
                }
                if _start < 140 && _end > 136 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_ern(2)?.to_ne_bytes();
                    if _start <= 136 && _end > 136 {
                        _buf[(136 - _start) as usize] = _value[0];
                    }
                    if _start <= 137 && _end > 137 {
                        _buf[(137 - _start) as usize] = _value[1];
                    }
                    if _start <= 138 && _end > 138 {
                        _buf[(138 - _start) as usize] = _value[2];
                    }
                    if _start <= 139 && _end > 139 {
                        _buf[(139 - _start) as usize] = _value[3];
                    }
                }
                if _start < 144 && _end > 140 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_ern(3)?.to_ne_bytes();
                    if _start <= 140 && _end > 140 {
                        _buf[(140 - _start) as usize] = _value[0];
                    }
                    if _start <= 141 && _end > 141 {
                        _buf[(141 - _start) as usize] = _value[1];
                    }
                    if _start <= 142 && _end > 142 {
                        _buf[(142 - _start) as usize] = _value[2];
                    }
                    if _start <= 143 && _end > 143 {
                        _buf[(143 - _start) as usize] = _value[3];
                    }
                }
                if _start < 148 && _end > 144 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_irn(0)?.to_ne_bytes();
                    if _start <= 144 && _end > 144 {
                        _buf[(144 - _start) as usize] = _value[0];
                    }
                    if _start <= 145 && _end > 145 {
                        _buf[(145 - _start) as usize] = _value[1];
                    }
                    if _start <= 146 && _end > 146 {
                        _buf[(146 - _start) as usize] = _value[2];
                    }
                    if _start <= 147 && _end > 147 {
                        _buf[(147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 152 && _end > 148 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_irn(1)?.to_ne_bytes();
                    if _start <= 148 && _end > 148 {
                        _buf[(148 - _start) as usize] = _value[0];
                    }
                    if _start <= 149 && _end > 149 {
                        _buf[(149 - _start) as usize] = _value[1];
                    }
                    if _start <= 150 && _end > 150 {
                        _buf[(150 - _start) as usize] = _value[2];
                    }
                    if _start <= 151 && _end > 151 {
                        _buf[(151 - _start) as usize] = _value[3];
                    }
                }
                if _start < 156 && _end > 152 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_irn(2)?.to_ne_bytes();
                    if _start <= 152 && _end > 152 {
                        _buf[(152 - _start) as usize] = _value[0];
                    }
                    if _start <= 153 && _end > 153 {
                        _buf[(153 - _start) as usize] = _value[1];
                    }
                    if _start <= 154 && _end > 154 {
                        _buf[(154 - _start) as usize] = _value[2];
                    }
                    if _start <= 155 && _end > 155 {
                        _buf[(155 - _start) as usize] = _value[3];
                    }
                }
                if _start < 160 && _end > 156 {
                    let _value =
                        self.0.lock().unwrap().read_ficr_irn(3)?.to_ne_bytes();
                    if _start <= 156 && _end > 156 {
                        _buf[(156 - _start) as usize] = _value[0];
                    }
                    if _start <= 157 && _end > 157 {
                        _buf[(157 - _start) as usize] = _value[1];
                    }
                    if _start <= 158 && _end > 158 {
                        _buf[(158 - _start) as usize] = _value[2];
                    }
                    if _start <= 159 && _end > 159 {
                        _buf[(159 - _start) as usize] = _value[3];
                    }
                }
                if _start < 164 && _end > 160 {
                    let _value = self.read_ficr_deviceaddrtype()?.to_ne_bytes();
                    if _start <= 160 && _end > 160 {
                        _buf[(160 - _start) as usize] = _value[0];
                    }
                    if _start <= 161 && _end > 161 {
                        _buf[(161 - _start) as usize] = _value[1];
                    }
                    if _start <= 162 && _end > 162 {
                        _buf[(162 - _start) as usize] = _value[2];
                    }
                    if _start <= 163 && _end > 163 {
                        _buf[(163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 168 && _end > 164 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_deviceaddrn(0)?
                        .to_ne_bytes();
                    if _start <= 164 && _end > 164 {
                        _buf[(164 - _start) as usize] = _value[0];
                    }
                    if _start <= 165 && _end > 165 {
                        _buf[(165 - _start) as usize] = _value[1];
                    }
                    if _start <= 166 && _end > 166 {
                        _buf[(166 - _start) as usize] = _value[2];
                    }
                    if _start <= 167 && _end > 167 {
                        _buf[(167 - _start) as usize] = _value[3];
                    }
                }
                if _start < 172 && _end > 168 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_deviceaddrn(1)?
                        .to_ne_bytes();
                    if _start <= 168 && _end > 168 {
                        _buf[(168 - _start) as usize] = _value[0];
                    }
                    if _start <= 169 && _end > 169 {
                        _buf[(169 - _start) as usize] = _value[1];
                    }
                    if _start <= 170 && _end > 170 {
                        _buf[(170 - _start) as usize] = _value[2];
                    }
                    if _start <= 171 && _end > 171 {
                        _buf[(171 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_info_part()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_info_variant()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_info_package()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_info_ram()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_info_flash()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_info_unused0n(0)?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_info_unused0n(1)?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ficr_info_unused0n(2)?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1028..=1095, 1029..=1096) => {
                if _start < 1032 && _end > 1028 {
                    let _value = self.read_ficr_temp_a0()?.to_ne_bytes();
                    if _start <= 1028 && _end > 1028 {
                        _buf[(1028 - _start) as usize] = _value[0];
                    }
                    if _start <= 1029 && _end > 1029 {
                        _buf[(1029 - _start) as usize] = _value[1];
                    }
                    if _start <= 1030 && _end > 1030 {
                        _buf[(1030 - _start) as usize] = _value[2];
                    }
                    if _start <= 1031 && _end > 1031 {
                        _buf[(1031 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1036 && _end > 1032 {
                    let _value = self.read_ficr_temp_a1()?.to_ne_bytes();
                    if _start <= 1032 && _end > 1032 {
                        _buf[(1032 - _start) as usize] = _value[0];
                    }
                    if _start <= 1033 && _end > 1033 {
                        _buf[(1033 - _start) as usize] = _value[1];
                    }
                    if _start <= 1034 && _end > 1034 {
                        _buf[(1034 - _start) as usize] = _value[2];
                    }
                    if _start <= 1035 && _end > 1035 {
                        _buf[(1035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _value = self.read_ficr_temp_a2()?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1044 && _end > 1040 {
                    let _value = self.read_ficr_temp_a3()?.to_ne_bytes();
                    if _start <= 1040 && _end > 1040 {
                        _buf[(1040 - _start) as usize] = _value[0];
                    }
                    if _start <= 1041 && _end > 1041 {
                        _buf[(1041 - _start) as usize] = _value[1];
                    }
                    if _start <= 1042 && _end > 1042 {
                        _buf[(1042 - _start) as usize] = _value[2];
                    }
                    if _start <= 1043 && _end > 1043 {
                        _buf[(1043 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1048 && _end > 1044 {
                    let _value = self.read_ficr_temp_a4()?.to_ne_bytes();
                    if _start <= 1044 && _end > 1044 {
                        _buf[(1044 - _start) as usize] = _value[0];
                    }
                    if _start <= 1045 && _end > 1045 {
                        _buf[(1045 - _start) as usize] = _value[1];
                    }
                    if _start <= 1046 && _end > 1046 {
                        _buf[(1046 - _start) as usize] = _value[2];
                    }
                    if _start <= 1047 && _end > 1047 {
                        _buf[(1047 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1052 && _end > 1048 {
                    let _value = self.read_ficr_temp_a5()?.to_ne_bytes();
                    if _start <= 1048 && _end > 1048 {
                        _buf[(1048 - _start) as usize] = _value[0];
                    }
                    if _start <= 1049 && _end > 1049 {
                        _buf[(1049 - _start) as usize] = _value[1];
                    }
                    if _start <= 1050 && _end > 1050 {
                        _buf[(1050 - _start) as usize] = _value[2];
                    }
                    if _start <= 1051 && _end > 1051 {
                        _buf[(1051 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1056 && _end > 1052 {
                    let _value = self.read_ficr_temp_b0()?.to_ne_bytes();
                    if _start <= 1052 && _end > 1052 {
                        _buf[(1052 - _start) as usize] = _value[0];
                    }
                    if _start <= 1053 && _end > 1053 {
                        _buf[(1053 - _start) as usize] = _value[1];
                    }
                    if _start <= 1054 && _end > 1054 {
                        _buf[(1054 - _start) as usize] = _value[2];
                    }
                    if _start <= 1055 && _end > 1055 {
                        _buf[(1055 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1060 && _end > 1056 {
                    let _value = self.read_ficr_temp_b1()?.to_ne_bytes();
                    if _start <= 1056 && _end > 1056 {
                        _buf[(1056 - _start) as usize] = _value[0];
                    }
                    if _start <= 1057 && _end > 1057 {
                        _buf[(1057 - _start) as usize] = _value[1];
                    }
                    if _start <= 1058 && _end > 1058 {
                        _buf[(1058 - _start) as usize] = _value[2];
                    }
                    if _start <= 1059 && _end > 1059 {
                        _buf[(1059 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1064 && _end > 1060 {
                    let _value = self.read_ficr_temp_b2()?.to_ne_bytes();
                    if _start <= 1060 && _end > 1060 {
                        _buf[(1060 - _start) as usize] = _value[0];
                    }
                    if _start <= 1061 && _end > 1061 {
                        _buf[(1061 - _start) as usize] = _value[1];
                    }
                    if _start <= 1062 && _end > 1062 {
                        _buf[(1062 - _start) as usize] = _value[2];
                    }
                    if _start <= 1063 && _end > 1063 {
                        _buf[(1063 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1068 && _end > 1064 {
                    let _value = self.read_ficr_temp_b3()?.to_ne_bytes();
                    if _start <= 1064 && _end > 1064 {
                        _buf[(1064 - _start) as usize] = _value[0];
                    }
                    if _start <= 1065 && _end > 1065 {
                        _buf[(1065 - _start) as usize] = _value[1];
                    }
                    if _start <= 1066 && _end > 1066 {
                        _buf[(1066 - _start) as usize] = _value[2];
                    }
                    if _start <= 1067 && _end > 1067 {
                        _buf[(1067 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1072 && _end > 1068 {
                    let _value = self.read_ficr_temp_b4()?.to_ne_bytes();
                    if _start <= 1068 && _end > 1068 {
                        _buf[(1068 - _start) as usize] = _value[0];
                    }
                    if _start <= 1069 && _end > 1069 {
                        _buf[(1069 - _start) as usize] = _value[1];
                    }
                    if _start <= 1070 && _end > 1070 {
                        _buf[(1070 - _start) as usize] = _value[2];
                    }
                    if _start <= 1071 && _end > 1071 {
                        _buf[(1071 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1076 && _end > 1072 {
                    let _value = self.read_ficr_temp_b5()?.to_ne_bytes();
                    if _start <= 1072 && _end > 1072 {
                        _buf[(1072 - _start) as usize] = _value[0];
                    }
                    if _start <= 1073 && _end > 1073 {
                        _buf[(1073 - _start) as usize] = _value[1];
                    }
                    if _start <= 1074 && _end > 1074 {
                        _buf[(1074 - _start) as usize] = _value[2];
                    }
                    if _start <= 1075 && _end > 1075 {
                        _buf[(1075 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1080 && _end > 1076 {
                    let _value = self.read_ficr_temp_t0()?.to_ne_bytes();
                    if _start <= 1076 && _end > 1076 {
                        _buf[(1076 - _start) as usize] = _value[0];
                    }
                    if _start <= 1077 && _end > 1077 {
                        _buf[(1077 - _start) as usize] = _value[1];
                    }
                    if _start <= 1078 && _end > 1078 {
                        _buf[(1078 - _start) as usize] = _value[2];
                    }
                    if _start <= 1079 && _end > 1079 {
                        _buf[(1079 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1084 && _end > 1080 {
                    let _value = self.read_ficr_temp_t1()?.to_ne_bytes();
                    if _start <= 1080 && _end > 1080 {
                        _buf[(1080 - _start) as usize] = _value[0];
                    }
                    if _start <= 1081 && _end > 1081 {
                        _buf[(1081 - _start) as usize] = _value[1];
                    }
                    if _start <= 1082 && _end > 1082 {
                        _buf[(1082 - _start) as usize] = _value[2];
                    }
                    if _start <= 1083 && _end > 1083 {
                        _buf[(1083 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1088 && _end > 1084 {
                    let _value = self.read_ficr_temp_t2()?.to_ne_bytes();
                    if _start <= 1084 && _end > 1084 {
                        _buf[(1084 - _start) as usize] = _value[0];
                    }
                    if _start <= 1085 && _end > 1085 {
                        _buf[(1085 - _start) as usize] = _value[1];
                    }
                    if _start <= 1086 && _end > 1086 {
                        _buf[(1086 - _start) as usize] = _value[2];
                    }
                    if _start <= 1087 && _end > 1087 {
                        _buf[(1087 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1092 && _end > 1088 {
                    let _value = self.read_ficr_temp_t3()?.to_ne_bytes();
                    if _start <= 1088 && _end > 1088 {
                        _buf[(1088 - _start) as usize] = _value[0];
                    }
                    if _start <= 1089 && _end > 1089 {
                        _buf[(1089 - _start) as usize] = _value[1];
                    }
                    if _start <= 1090 && _end > 1090 {
                        _buf[(1090 - _start) as usize] = _value[2];
                    }
                    if _start <= 1091 && _end > 1091 {
                        _buf[(1091 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1096 && _end > 1092 {
                    let _value = self.read_ficr_temp_t4()?.to_ne_bytes();
                    if _start <= 1092 && _end > 1092 {
                        _buf[(1092 - _start) as usize] = _value[0];
                    }
                    if _start <= 1093 && _end > 1093 {
                        _buf[(1093 - _start) as usize] = _value[1];
                    }
                    if _start <= 1094 && _end > 1094 {
                        _buf[(1094 - _start) as usize] = _value[2];
                    }
                    if _start <= 1095 && _end > 1095 {
                        _buf[(1095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1104..=1119, 1105..=1120) => {
                if _start < 1108 && _end > 1104 {
                    let _value = self.read_ficr_nfc_tagheader0()?.to_ne_bytes();
                    if _start <= 1104 && _end > 1104 {
                        _buf[(1104 - _start) as usize] = _value[0];
                    }
                    if _start <= 1105 && _end > 1105 {
                        _buf[(1105 - _start) as usize] = _value[1];
                    }
                    if _start <= 1106 && _end > 1106 {
                        _buf[(1106 - _start) as usize] = _value[2];
                    }
                    if _start <= 1107 && _end > 1107 {
                        _buf[(1107 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1112 && _end > 1108 {
                    let _value = self.read_ficr_nfc_tagheader1()?.to_ne_bytes();
                    if _start <= 1108 && _end > 1108 {
                        _buf[(1108 - _start) as usize] = _value[0];
                    }
                    if _start <= 1109 && _end > 1109 {
                        _buf[(1109 - _start) as usize] = _value[1];
                    }
                    if _start <= 1110 && _end > 1110 {
                        _buf[(1110 - _start) as usize] = _value[2];
                    }
                    if _start <= 1111 && _end > 1111 {
                        _buf[(1111 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1116 && _end > 1112 {
                    let _value = self.read_ficr_nfc_tagheader2()?.to_ne_bytes();
                    if _start <= 1112 && _end > 1112 {
                        _buf[(1112 - _start) as usize] = _value[0];
                    }
                    if _start <= 1113 && _end > 1113 {
                        _buf[(1113 - _start) as usize] = _value[1];
                    }
                    if _start <= 1114 && _end > 1114 {
                        _buf[(1114 - _start) as usize] = _value[2];
                    }
                    if _start <= 1115 && _end > 1115 {
                        _buf[(1115 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1120 && _end > 1116 {
                    let _value = self.read_ficr_nfc_tagheader3()?.to_ne_bytes();
                    if _start <= 1116 && _end > 1116 {
                        _buf[(1116 - _start) as usize] = _value[0];
                    }
                    if _start <= 1117 && _end > 1117 {
                        _buf[(1117 - _start) as usize] = _value[1];
                    }
                    if _start <= 1118 && _end > 1118 {
                        _buf[(1118 - _start) as usize] = _value[2];
                    }
                    if _start <= 1119 && _end > 1119 {
                        _buf[(1119 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 268435456;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (16..=23, 17..=24) => {
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 24 && _end > 20 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (96..=103, 97..=104) => {
                if _start < 100 && _end > 96 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 104 && _end > 100 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (128..=171, 129..=172) => {
                if _start < 132 && _end > 128 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 136 && _end > 132 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 140 && _end > 136 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 144 && _end > 140 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 148 && _end > 144 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 152 && _end > 148 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 156 && _end > 152 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 160 && _end > 156 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 164 && _end > 160 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 168 && _end > 164 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 172 && _end > 168 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 264 && _end > 260 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 268 && _end > 264 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 272 && _end > 268 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 276 && _end > 272 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 280 && _end > 276 {
                    assert!(
                        _start <= 276 && _end >= 280u64,
                        "partial write for FICR UNUSED0[%s] not implemented",
                    );
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ficr_info_unused0n(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert!(
                        _start <= 280 && _end >= 284u64,
                        "partial write for FICR UNUSED0[%s] not implemented",
                    );
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ficr_info_unused0n(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284 && _end >= 288u64,
                        "partial write for FICR UNUSED0[%s] not implemented",
                    );
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ficr_info_unused0n(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1028..=1095, 1029..=1096) => {
                if _start < 1032 && _end > 1028 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1036 && _end > 1032 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1040 && _end > 1036 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1044 && _end > 1040 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1048 && _end > 1044 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1052 && _end > 1048 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1056 && _end > 1052 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1060 && _end > 1056 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1064 && _end > 1060 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1068 && _end > 1064 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1072 && _end > 1068 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1076 && _end > 1072 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1080 && _end > 1076 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1084 && _end > 1080 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1088 && _end > 1084 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1092 && _end > 1088 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1096 && _end > 1092 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1104..=1119, 1105..=1120) => {
                if _start < 1108 && _end > 1104 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1112 && _end > 1108 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1116 && _end > 1112 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1120 && _end > 1116 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x10000000 {
    fn read_ficr_deviceaddrtype(&self) -> MemResult<u32> {
        let mut _value = 4294967294;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_ficr_deviceaddrtype_deviceaddrtype()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_a0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_a0_a()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_a1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_a1_a()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_a2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_a2_a()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_a3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_a3_a()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_a4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_a4_a()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_a5(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_a5_a()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_b0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_b0_b()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_b1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_b1_b()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_b2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_b2_b()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_b3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_b3_b()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_b4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_b4_b()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_b5(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_b5_b()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_t0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_t0_t()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_t1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_t1_t()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_t2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_t2_t()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_t3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_t3_t()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_temp_t4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_temp_t4_t()?) << 0u32;
        Ok(_value)
    }
    fn read_ficr_nfc_tagheader0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader0_mfgid()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader0_ud1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader0_ud2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader0_ud3()?)
                << 24u32;
        Ok(_value)
    }
    fn read_ficr_nfc_tagheader1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader1_ud4()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader1_ud5()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader1_ud6()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader1_ud7()?)
                << 24u32;
        Ok(_value)
    }
    fn read_ficr_nfc_tagheader2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader2_ud8()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader2_ud9()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader2_ud10()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader2_ud11()?)
                << 24u32;
        Ok(_value)
    }
    fn read_ficr_nfc_tagheader3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader3_ud12()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader3_ud13()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader3_ud14()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ficr_nfc_tagheader3_ud15()?)
                << 24u32;
        Ok(_value)
    }
}
pub(crate) struct PeripheralPage0x10001000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x10001000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 268439552;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_unused0()?
                        .to_ne_bytes();
                    if _start <= 0 && _end > 0 {
                        _buf[(0 - _start) as usize] = _value[0];
                    }
                    if _start <= 1 && _end > 1 {
                        _buf[(1 - _start) as usize] = _value[1];
                    }
                    if _start <= 2 && _end > 2 {
                        _buf[(2 - _start) as usize] = _value[2];
                    }
                    if _start <= 3 && _end > 3 {
                        _buf[(3 - _start) as usize] = _value[3];
                    }
                }
                if _start < 8 && _end > 4 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_unused1()?
                        .to_ne_bytes();
                    if _start <= 4 && _end > 4 {
                        _buf[(4 - _start) as usize] = _value[0];
                    }
                    if _start <= 5 && _end > 5 {
                        _buf[(5 - _start) as usize] = _value[1];
                    }
                    if _start <= 6 && _end > 6 {
                        _buf[(6 - _start) as usize] = _value[2];
                    }
                    if _start <= 7 && _end > 7 {
                        _buf[(7 - _start) as usize] = _value[3];
                    }
                }
                if _start < 12 && _end > 8 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_unused2()?
                        .to_ne_bytes();
                    if _start <= 8 && _end > 8 {
                        _buf[(8 - _start) as usize] = _value[0];
                    }
                    if _start <= 9 && _end > 9 {
                        _buf[(9 - _start) as usize] = _value[1];
                    }
                    if _start <= 10 && _end > 10 {
                        _buf[(10 - _start) as usize] = _value[2];
                    }
                    if _start <= 11 && _end > 11 {
                        _buf[(11 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (16..=255, 17..=256) => {
                if _start < 20 && _end > 16 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_unused3()?
                        .to_ne_bytes();
                    if _start <= 16 && _end > 16 {
                        _buf[(16 - _start) as usize] = _value[0];
                    }
                    if _start <= 17 && _end > 17 {
                        _buf[(17 - _start) as usize] = _value[1];
                    }
                    if _start <= 18 && _end > 18 {
                        _buf[(18 - _start) as usize] = _value[2];
                    }
                    if _start <= 19 && _end > 19 {
                        _buf[(19 - _start) as usize] = _value[3];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(0)?
                        .to_ne_bytes();
                    if _start <= 20 && _end > 20 {
                        _buf[(20 - _start) as usize] = _value[0];
                    }
                    if _start <= 21 && _end > 21 {
                        _buf[(21 - _start) as usize] = _value[1];
                    }
                    if _start <= 22 && _end > 22 {
                        _buf[(22 - _start) as usize] = _value[2];
                    }
                    if _start <= 23 && _end > 23 {
                        _buf[(23 - _start) as usize] = _value[3];
                    }
                }
                if _start < 28 && _end > 24 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(1)?
                        .to_ne_bytes();
                    if _start <= 24 && _end > 24 {
                        _buf[(24 - _start) as usize] = _value[0];
                    }
                    if _start <= 25 && _end > 25 {
                        _buf[(25 - _start) as usize] = _value[1];
                    }
                    if _start <= 26 && _end > 26 {
                        _buf[(26 - _start) as usize] = _value[2];
                    }
                    if _start <= 27 && _end > 27 {
                        _buf[(27 - _start) as usize] = _value[3];
                    }
                }
                if _start < 32 && _end > 28 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(2)?
                        .to_ne_bytes();
                    if _start <= 28 && _end > 28 {
                        _buf[(28 - _start) as usize] = _value[0];
                    }
                    if _start <= 29 && _end > 29 {
                        _buf[(29 - _start) as usize] = _value[1];
                    }
                    if _start <= 30 && _end > 30 {
                        _buf[(30 - _start) as usize] = _value[2];
                    }
                    if _start <= 31 && _end > 31 {
                        _buf[(31 - _start) as usize] = _value[3];
                    }
                }
                if _start < 36 && _end > 32 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(3)?
                        .to_ne_bytes();
                    if _start <= 32 && _end > 32 {
                        _buf[(32 - _start) as usize] = _value[0];
                    }
                    if _start <= 33 && _end > 33 {
                        _buf[(33 - _start) as usize] = _value[1];
                    }
                    if _start <= 34 && _end > 34 {
                        _buf[(34 - _start) as usize] = _value[2];
                    }
                    if _start <= 35 && _end > 35 {
                        _buf[(35 - _start) as usize] = _value[3];
                    }
                }
                if _start < 40 && _end > 36 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(4)?
                        .to_ne_bytes();
                    if _start <= 36 && _end > 36 {
                        _buf[(36 - _start) as usize] = _value[0];
                    }
                    if _start <= 37 && _end > 37 {
                        _buf[(37 - _start) as usize] = _value[1];
                    }
                    if _start <= 38 && _end > 38 {
                        _buf[(38 - _start) as usize] = _value[2];
                    }
                    if _start <= 39 && _end > 39 {
                        _buf[(39 - _start) as usize] = _value[3];
                    }
                }
                if _start < 44 && _end > 40 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(5)?
                        .to_ne_bytes();
                    if _start <= 40 && _end > 40 {
                        _buf[(40 - _start) as usize] = _value[0];
                    }
                    if _start <= 41 && _end > 41 {
                        _buf[(41 - _start) as usize] = _value[1];
                    }
                    if _start <= 42 && _end > 42 {
                        _buf[(42 - _start) as usize] = _value[2];
                    }
                    if _start <= 43 && _end > 43 {
                        _buf[(43 - _start) as usize] = _value[3];
                    }
                }
                if _start < 48 && _end > 44 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(6)?
                        .to_ne_bytes();
                    if _start <= 44 && _end > 44 {
                        _buf[(44 - _start) as usize] = _value[0];
                    }
                    if _start <= 45 && _end > 45 {
                        _buf[(45 - _start) as usize] = _value[1];
                    }
                    if _start <= 46 && _end > 46 {
                        _buf[(46 - _start) as usize] = _value[2];
                    }
                    if _start <= 47 && _end > 47 {
                        _buf[(47 - _start) as usize] = _value[3];
                    }
                }
                if _start < 52 && _end > 48 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(7)?
                        .to_ne_bytes();
                    if _start <= 48 && _end > 48 {
                        _buf[(48 - _start) as usize] = _value[0];
                    }
                    if _start <= 49 && _end > 49 {
                        _buf[(49 - _start) as usize] = _value[1];
                    }
                    if _start <= 50 && _end > 50 {
                        _buf[(50 - _start) as usize] = _value[2];
                    }
                    if _start <= 51 && _end > 51 {
                        _buf[(51 - _start) as usize] = _value[3];
                    }
                }
                if _start < 56 && _end > 52 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(8)?
                        .to_ne_bytes();
                    if _start <= 52 && _end > 52 {
                        _buf[(52 - _start) as usize] = _value[0];
                    }
                    if _start <= 53 && _end > 53 {
                        _buf[(53 - _start) as usize] = _value[1];
                    }
                    if _start <= 54 && _end > 54 {
                        _buf[(54 - _start) as usize] = _value[2];
                    }
                    if _start <= 55 && _end > 55 {
                        _buf[(55 - _start) as usize] = _value[3];
                    }
                }
                if _start < 60 && _end > 56 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(9)?
                        .to_ne_bytes();
                    if _start <= 56 && _end > 56 {
                        _buf[(56 - _start) as usize] = _value[0];
                    }
                    if _start <= 57 && _end > 57 {
                        _buf[(57 - _start) as usize] = _value[1];
                    }
                    if _start <= 58 && _end > 58 {
                        _buf[(58 - _start) as usize] = _value[2];
                    }
                    if _start <= 59 && _end > 59 {
                        _buf[(59 - _start) as usize] = _value[3];
                    }
                }
                if _start < 64 && _end > 60 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(10)?
                        .to_ne_bytes();
                    if _start <= 60 && _end > 60 {
                        _buf[(60 - _start) as usize] = _value[0];
                    }
                    if _start <= 61 && _end > 61 {
                        _buf[(61 - _start) as usize] = _value[1];
                    }
                    if _start <= 62 && _end > 62 {
                        _buf[(62 - _start) as usize] = _value[2];
                    }
                    if _start <= 63 && _end > 63 {
                        _buf[(63 - _start) as usize] = _value[3];
                    }
                }
                if _start < 68 && _end > 64 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(11)?
                        .to_ne_bytes();
                    if _start <= 64 && _end > 64 {
                        _buf[(64 - _start) as usize] = _value[0];
                    }
                    if _start <= 65 && _end > 65 {
                        _buf[(65 - _start) as usize] = _value[1];
                    }
                    if _start <= 66 && _end > 66 {
                        _buf[(66 - _start) as usize] = _value[2];
                    }
                    if _start <= 67 && _end > 67 {
                        _buf[(67 - _start) as usize] = _value[3];
                    }
                }
                if _start < 72 && _end > 68 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(12)?
                        .to_ne_bytes();
                    if _start <= 68 && _end > 68 {
                        _buf[(68 - _start) as usize] = _value[0];
                    }
                    if _start <= 69 && _end > 69 {
                        _buf[(69 - _start) as usize] = _value[1];
                    }
                    if _start <= 70 && _end > 70 {
                        _buf[(70 - _start) as usize] = _value[2];
                    }
                    if _start <= 71 && _end > 71 {
                        _buf[(71 - _start) as usize] = _value[3];
                    }
                }
                if _start < 76 && _end > 72 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(13)?
                        .to_ne_bytes();
                    if _start <= 72 && _end > 72 {
                        _buf[(72 - _start) as usize] = _value[0];
                    }
                    if _start <= 73 && _end > 73 {
                        _buf[(73 - _start) as usize] = _value[1];
                    }
                    if _start <= 74 && _end > 74 {
                        _buf[(74 - _start) as usize] = _value[2];
                    }
                    if _start <= 75 && _end > 75 {
                        _buf[(75 - _start) as usize] = _value[3];
                    }
                }
                if _start < 80 && _end > 76 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrffwn(14)?
                        .to_ne_bytes();
                    if _start <= 76 && _end > 76 {
                        _buf[(76 - _start) as usize] = _value[0];
                    }
                    if _start <= 77 && _end > 77 {
                        _buf[(77 - _start) as usize] = _value[1];
                    }
                    if _start <= 78 && _end > 78 {
                        _buf[(78 - _start) as usize] = _value[2];
                    }
                    if _start <= 79 && _end > 79 {
                        _buf[(79 - _start) as usize] = _value[3];
                    }
                }
                if _start < 84 && _end > 80 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(0)?
                        .to_ne_bytes();
                    if _start <= 80 && _end > 80 {
                        _buf[(80 - _start) as usize] = _value[0];
                    }
                    if _start <= 81 && _end > 81 {
                        _buf[(81 - _start) as usize] = _value[1];
                    }
                    if _start <= 82 && _end > 82 {
                        _buf[(82 - _start) as usize] = _value[2];
                    }
                    if _start <= 83 && _end > 83 {
                        _buf[(83 - _start) as usize] = _value[3];
                    }
                }
                if _start < 88 && _end > 84 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(1)?
                        .to_ne_bytes();
                    if _start <= 84 && _end > 84 {
                        _buf[(84 - _start) as usize] = _value[0];
                    }
                    if _start <= 85 && _end > 85 {
                        _buf[(85 - _start) as usize] = _value[1];
                    }
                    if _start <= 86 && _end > 86 {
                        _buf[(86 - _start) as usize] = _value[2];
                    }
                    if _start <= 87 && _end > 87 {
                        _buf[(87 - _start) as usize] = _value[3];
                    }
                }
                if _start < 92 && _end > 88 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(2)?
                        .to_ne_bytes();
                    if _start <= 88 && _end > 88 {
                        _buf[(88 - _start) as usize] = _value[0];
                    }
                    if _start <= 89 && _end > 89 {
                        _buf[(89 - _start) as usize] = _value[1];
                    }
                    if _start <= 90 && _end > 90 {
                        _buf[(90 - _start) as usize] = _value[2];
                    }
                    if _start <= 91 && _end > 91 {
                        _buf[(91 - _start) as usize] = _value[3];
                    }
                }
                if _start < 96 && _end > 92 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(3)?
                        .to_ne_bytes();
                    if _start <= 92 && _end > 92 {
                        _buf[(92 - _start) as usize] = _value[0];
                    }
                    if _start <= 93 && _end > 93 {
                        _buf[(93 - _start) as usize] = _value[1];
                    }
                    if _start <= 94 && _end > 94 {
                        _buf[(94 - _start) as usize] = _value[2];
                    }
                    if _start <= 95 && _end > 95 {
                        _buf[(95 - _start) as usize] = _value[3];
                    }
                }
                if _start < 100 && _end > 96 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(4)?
                        .to_ne_bytes();
                    if _start <= 96 && _end > 96 {
                        _buf[(96 - _start) as usize] = _value[0];
                    }
                    if _start <= 97 && _end > 97 {
                        _buf[(97 - _start) as usize] = _value[1];
                    }
                    if _start <= 98 && _end > 98 {
                        _buf[(98 - _start) as usize] = _value[2];
                    }
                    if _start <= 99 && _end > 99 {
                        _buf[(99 - _start) as usize] = _value[3];
                    }
                }
                if _start < 104 && _end > 100 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(5)?
                        .to_ne_bytes();
                    if _start <= 100 && _end > 100 {
                        _buf[(100 - _start) as usize] = _value[0];
                    }
                    if _start <= 101 && _end > 101 {
                        _buf[(101 - _start) as usize] = _value[1];
                    }
                    if _start <= 102 && _end > 102 {
                        _buf[(102 - _start) as usize] = _value[2];
                    }
                    if _start <= 103 && _end > 103 {
                        _buf[(103 - _start) as usize] = _value[3];
                    }
                }
                if _start < 108 && _end > 104 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(6)?
                        .to_ne_bytes();
                    if _start <= 104 && _end > 104 {
                        _buf[(104 - _start) as usize] = _value[0];
                    }
                    if _start <= 105 && _end > 105 {
                        _buf[(105 - _start) as usize] = _value[1];
                    }
                    if _start <= 106 && _end > 106 {
                        _buf[(106 - _start) as usize] = _value[2];
                    }
                    if _start <= 107 && _end > 107 {
                        _buf[(107 - _start) as usize] = _value[3];
                    }
                }
                if _start < 112 && _end > 108 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(7)?
                        .to_ne_bytes();
                    if _start <= 108 && _end > 108 {
                        _buf[(108 - _start) as usize] = _value[0];
                    }
                    if _start <= 109 && _end > 109 {
                        _buf[(109 - _start) as usize] = _value[1];
                    }
                    if _start <= 110 && _end > 110 {
                        _buf[(110 - _start) as usize] = _value[2];
                    }
                    if _start <= 111 && _end > 111 {
                        _buf[(111 - _start) as usize] = _value[3];
                    }
                }
                if _start < 116 && _end > 112 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(8)?
                        .to_ne_bytes();
                    if _start <= 112 && _end > 112 {
                        _buf[(112 - _start) as usize] = _value[0];
                    }
                    if _start <= 113 && _end > 113 {
                        _buf[(113 - _start) as usize] = _value[1];
                    }
                    if _start <= 114 && _end > 114 {
                        _buf[(114 - _start) as usize] = _value[2];
                    }
                    if _start <= 115 && _end > 115 {
                        _buf[(115 - _start) as usize] = _value[3];
                    }
                }
                if _start < 120 && _end > 116 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(9)?
                        .to_ne_bytes();
                    if _start <= 116 && _end > 116 {
                        _buf[(116 - _start) as usize] = _value[0];
                    }
                    if _start <= 117 && _end > 117 {
                        _buf[(117 - _start) as usize] = _value[1];
                    }
                    if _start <= 118 && _end > 118 {
                        _buf[(118 - _start) as usize] = _value[2];
                    }
                    if _start <= 119 && _end > 119 {
                        _buf[(119 - _start) as usize] = _value[3];
                    }
                }
                if _start < 124 && _end > 120 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(10)?
                        .to_ne_bytes();
                    if _start <= 120 && _end > 120 {
                        _buf[(120 - _start) as usize] = _value[0];
                    }
                    if _start <= 121 && _end > 121 {
                        _buf[(121 - _start) as usize] = _value[1];
                    }
                    if _start <= 122 && _end > 122 {
                        _buf[(122 - _start) as usize] = _value[2];
                    }
                    if _start <= 123 && _end > 123 {
                        _buf[(123 - _start) as usize] = _value[3];
                    }
                }
                if _start < 128 && _end > 124 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_nrfhwn(11)?
                        .to_ne_bytes();
                    if _start <= 124 && _end > 124 {
                        _buf[(124 - _start) as usize] = _value[0];
                    }
                    if _start <= 125 && _end > 125 {
                        _buf[(125 - _start) as usize] = _value[1];
                    }
                    if _start <= 126 && _end > 126 {
                        _buf[(126 - _start) as usize] = _value[2];
                    }
                    if _start <= 127 && _end > 127 {
                        _buf[(127 - _start) as usize] = _value[3];
                    }
                }
                if _start < 132 && _end > 128 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(0)?
                        .to_ne_bytes();
                    if _start <= 128 && _end > 128 {
                        _buf[(128 - _start) as usize] = _value[0];
                    }
                    if _start <= 129 && _end > 129 {
                        _buf[(129 - _start) as usize] = _value[1];
                    }
                    if _start <= 130 && _end > 130 {
                        _buf[(130 - _start) as usize] = _value[2];
                    }
                    if _start <= 131 && _end > 131 {
                        _buf[(131 - _start) as usize] = _value[3];
                    }
                }
                if _start < 136 && _end > 132 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(1)?
                        .to_ne_bytes();
                    if _start <= 132 && _end > 132 {
                        _buf[(132 - _start) as usize] = _value[0];
                    }
                    if _start <= 133 && _end > 133 {
                        _buf[(133 - _start) as usize] = _value[1];
                    }
                    if _start <= 134 && _end > 134 {
                        _buf[(134 - _start) as usize] = _value[2];
                    }
                    if _start <= 135 && _end > 135 {
                        _buf[(135 - _start) as usize] = _value[3];
                    }
                }
                if _start < 140 && _end > 136 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(2)?
                        .to_ne_bytes();
                    if _start <= 136 && _end > 136 {
                        _buf[(136 - _start) as usize] = _value[0];
                    }
                    if _start <= 137 && _end > 137 {
                        _buf[(137 - _start) as usize] = _value[1];
                    }
                    if _start <= 138 && _end > 138 {
                        _buf[(138 - _start) as usize] = _value[2];
                    }
                    if _start <= 139 && _end > 139 {
                        _buf[(139 - _start) as usize] = _value[3];
                    }
                }
                if _start < 144 && _end > 140 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(3)?
                        .to_ne_bytes();
                    if _start <= 140 && _end > 140 {
                        _buf[(140 - _start) as usize] = _value[0];
                    }
                    if _start <= 141 && _end > 141 {
                        _buf[(141 - _start) as usize] = _value[1];
                    }
                    if _start <= 142 && _end > 142 {
                        _buf[(142 - _start) as usize] = _value[2];
                    }
                    if _start <= 143 && _end > 143 {
                        _buf[(143 - _start) as usize] = _value[3];
                    }
                }
                if _start < 148 && _end > 144 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(4)?
                        .to_ne_bytes();
                    if _start <= 144 && _end > 144 {
                        _buf[(144 - _start) as usize] = _value[0];
                    }
                    if _start <= 145 && _end > 145 {
                        _buf[(145 - _start) as usize] = _value[1];
                    }
                    if _start <= 146 && _end > 146 {
                        _buf[(146 - _start) as usize] = _value[2];
                    }
                    if _start <= 147 && _end > 147 {
                        _buf[(147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 152 && _end > 148 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(5)?
                        .to_ne_bytes();
                    if _start <= 148 && _end > 148 {
                        _buf[(148 - _start) as usize] = _value[0];
                    }
                    if _start <= 149 && _end > 149 {
                        _buf[(149 - _start) as usize] = _value[1];
                    }
                    if _start <= 150 && _end > 150 {
                        _buf[(150 - _start) as usize] = _value[2];
                    }
                    if _start <= 151 && _end > 151 {
                        _buf[(151 - _start) as usize] = _value[3];
                    }
                }
                if _start < 156 && _end > 152 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(6)?
                        .to_ne_bytes();
                    if _start <= 152 && _end > 152 {
                        _buf[(152 - _start) as usize] = _value[0];
                    }
                    if _start <= 153 && _end > 153 {
                        _buf[(153 - _start) as usize] = _value[1];
                    }
                    if _start <= 154 && _end > 154 {
                        _buf[(154 - _start) as usize] = _value[2];
                    }
                    if _start <= 155 && _end > 155 {
                        _buf[(155 - _start) as usize] = _value[3];
                    }
                }
                if _start < 160 && _end > 156 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(7)?
                        .to_ne_bytes();
                    if _start <= 156 && _end > 156 {
                        _buf[(156 - _start) as usize] = _value[0];
                    }
                    if _start <= 157 && _end > 157 {
                        _buf[(157 - _start) as usize] = _value[1];
                    }
                    if _start <= 158 && _end > 158 {
                        _buf[(158 - _start) as usize] = _value[2];
                    }
                    if _start <= 159 && _end > 159 {
                        _buf[(159 - _start) as usize] = _value[3];
                    }
                }
                if _start < 164 && _end > 160 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(8)?
                        .to_ne_bytes();
                    if _start <= 160 && _end > 160 {
                        _buf[(160 - _start) as usize] = _value[0];
                    }
                    if _start <= 161 && _end > 161 {
                        _buf[(161 - _start) as usize] = _value[1];
                    }
                    if _start <= 162 && _end > 162 {
                        _buf[(162 - _start) as usize] = _value[2];
                    }
                    if _start <= 163 && _end > 163 {
                        _buf[(163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 168 && _end > 164 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(9)?
                        .to_ne_bytes();
                    if _start <= 164 && _end > 164 {
                        _buf[(164 - _start) as usize] = _value[0];
                    }
                    if _start <= 165 && _end > 165 {
                        _buf[(165 - _start) as usize] = _value[1];
                    }
                    if _start <= 166 && _end > 166 {
                        _buf[(166 - _start) as usize] = _value[2];
                    }
                    if _start <= 167 && _end > 167 {
                        _buf[(167 - _start) as usize] = _value[3];
                    }
                }
                if _start < 172 && _end > 168 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(10)?
                        .to_ne_bytes();
                    if _start <= 168 && _end > 168 {
                        _buf[(168 - _start) as usize] = _value[0];
                    }
                    if _start <= 169 && _end > 169 {
                        _buf[(169 - _start) as usize] = _value[1];
                    }
                    if _start <= 170 && _end > 170 {
                        _buf[(170 - _start) as usize] = _value[2];
                    }
                    if _start <= 171 && _end > 171 {
                        _buf[(171 - _start) as usize] = _value[3];
                    }
                }
                if _start < 176 && _end > 172 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(11)?
                        .to_ne_bytes();
                    if _start <= 172 && _end > 172 {
                        _buf[(172 - _start) as usize] = _value[0];
                    }
                    if _start <= 173 && _end > 173 {
                        _buf[(173 - _start) as usize] = _value[1];
                    }
                    if _start <= 174 && _end > 174 {
                        _buf[(174 - _start) as usize] = _value[2];
                    }
                    if _start <= 175 && _end > 175 {
                        _buf[(175 - _start) as usize] = _value[3];
                    }
                }
                if _start < 180 && _end > 176 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(12)?
                        .to_ne_bytes();
                    if _start <= 176 && _end > 176 {
                        _buf[(176 - _start) as usize] = _value[0];
                    }
                    if _start <= 177 && _end > 177 {
                        _buf[(177 - _start) as usize] = _value[1];
                    }
                    if _start <= 178 && _end > 178 {
                        _buf[(178 - _start) as usize] = _value[2];
                    }
                    if _start <= 179 && _end > 179 {
                        _buf[(179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 184 && _end > 180 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(13)?
                        .to_ne_bytes();
                    if _start <= 180 && _end > 180 {
                        _buf[(180 - _start) as usize] = _value[0];
                    }
                    if _start <= 181 && _end > 181 {
                        _buf[(181 - _start) as usize] = _value[1];
                    }
                    if _start <= 182 && _end > 182 {
                        _buf[(182 - _start) as usize] = _value[2];
                    }
                    if _start <= 183 && _end > 183 {
                        _buf[(183 - _start) as usize] = _value[3];
                    }
                }
                if _start < 188 && _end > 184 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(14)?
                        .to_ne_bytes();
                    if _start <= 184 && _end > 184 {
                        _buf[(184 - _start) as usize] = _value[0];
                    }
                    if _start <= 185 && _end > 185 {
                        _buf[(185 - _start) as usize] = _value[1];
                    }
                    if _start <= 186 && _end > 186 {
                        _buf[(186 - _start) as usize] = _value[2];
                    }
                    if _start <= 187 && _end > 187 {
                        _buf[(187 - _start) as usize] = _value[3];
                    }
                }
                if _start < 192 && _end > 188 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(15)?
                        .to_ne_bytes();
                    if _start <= 188 && _end > 188 {
                        _buf[(188 - _start) as usize] = _value[0];
                    }
                    if _start <= 189 && _end > 189 {
                        _buf[(189 - _start) as usize] = _value[1];
                    }
                    if _start <= 190 && _end > 190 {
                        _buf[(190 - _start) as usize] = _value[2];
                    }
                    if _start <= 191 && _end > 191 {
                        _buf[(191 - _start) as usize] = _value[3];
                    }
                }
                if _start < 196 && _end > 192 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(16)?
                        .to_ne_bytes();
                    if _start <= 192 && _end > 192 {
                        _buf[(192 - _start) as usize] = _value[0];
                    }
                    if _start <= 193 && _end > 193 {
                        _buf[(193 - _start) as usize] = _value[1];
                    }
                    if _start <= 194 && _end > 194 {
                        _buf[(194 - _start) as usize] = _value[2];
                    }
                    if _start <= 195 && _end > 195 {
                        _buf[(195 - _start) as usize] = _value[3];
                    }
                }
                if _start < 200 && _end > 196 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(17)?
                        .to_ne_bytes();
                    if _start <= 196 && _end > 196 {
                        _buf[(196 - _start) as usize] = _value[0];
                    }
                    if _start <= 197 && _end > 197 {
                        _buf[(197 - _start) as usize] = _value[1];
                    }
                    if _start <= 198 && _end > 198 {
                        _buf[(198 - _start) as usize] = _value[2];
                    }
                    if _start <= 199 && _end > 199 {
                        _buf[(199 - _start) as usize] = _value[3];
                    }
                }
                if _start < 204 && _end > 200 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(18)?
                        .to_ne_bytes();
                    if _start <= 200 && _end > 200 {
                        _buf[(200 - _start) as usize] = _value[0];
                    }
                    if _start <= 201 && _end > 201 {
                        _buf[(201 - _start) as usize] = _value[1];
                    }
                    if _start <= 202 && _end > 202 {
                        _buf[(202 - _start) as usize] = _value[2];
                    }
                    if _start <= 203 && _end > 203 {
                        _buf[(203 - _start) as usize] = _value[3];
                    }
                }
                if _start < 208 && _end > 204 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(19)?
                        .to_ne_bytes();
                    if _start <= 204 && _end > 204 {
                        _buf[(204 - _start) as usize] = _value[0];
                    }
                    if _start <= 205 && _end > 205 {
                        _buf[(205 - _start) as usize] = _value[1];
                    }
                    if _start <= 206 && _end > 206 {
                        _buf[(206 - _start) as usize] = _value[2];
                    }
                    if _start <= 207 && _end > 207 {
                        _buf[(207 - _start) as usize] = _value[3];
                    }
                }
                if _start < 212 && _end > 208 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(20)?
                        .to_ne_bytes();
                    if _start <= 208 && _end > 208 {
                        _buf[(208 - _start) as usize] = _value[0];
                    }
                    if _start <= 209 && _end > 209 {
                        _buf[(209 - _start) as usize] = _value[1];
                    }
                    if _start <= 210 && _end > 210 {
                        _buf[(210 - _start) as usize] = _value[2];
                    }
                    if _start <= 211 && _end > 211 {
                        _buf[(211 - _start) as usize] = _value[3];
                    }
                }
                if _start < 216 && _end > 212 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(21)?
                        .to_ne_bytes();
                    if _start <= 212 && _end > 212 {
                        _buf[(212 - _start) as usize] = _value[0];
                    }
                    if _start <= 213 && _end > 213 {
                        _buf[(213 - _start) as usize] = _value[1];
                    }
                    if _start <= 214 && _end > 214 {
                        _buf[(214 - _start) as usize] = _value[2];
                    }
                    if _start <= 215 && _end > 215 {
                        _buf[(215 - _start) as usize] = _value[3];
                    }
                }
                if _start < 220 && _end > 216 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(22)?
                        .to_ne_bytes();
                    if _start <= 216 && _end > 216 {
                        _buf[(216 - _start) as usize] = _value[0];
                    }
                    if _start <= 217 && _end > 217 {
                        _buf[(217 - _start) as usize] = _value[1];
                    }
                    if _start <= 218 && _end > 218 {
                        _buf[(218 - _start) as usize] = _value[2];
                    }
                    if _start <= 219 && _end > 219 {
                        _buf[(219 - _start) as usize] = _value[3];
                    }
                }
                if _start < 224 && _end > 220 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(23)?
                        .to_ne_bytes();
                    if _start <= 220 && _end > 220 {
                        _buf[(220 - _start) as usize] = _value[0];
                    }
                    if _start <= 221 && _end > 221 {
                        _buf[(221 - _start) as usize] = _value[1];
                    }
                    if _start <= 222 && _end > 222 {
                        _buf[(222 - _start) as usize] = _value[2];
                    }
                    if _start <= 223 && _end > 223 {
                        _buf[(223 - _start) as usize] = _value[3];
                    }
                }
                if _start < 228 && _end > 224 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(24)?
                        .to_ne_bytes();
                    if _start <= 224 && _end > 224 {
                        _buf[(224 - _start) as usize] = _value[0];
                    }
                    if _start <= 225 && _end > 225 {
                        _buf[(225 - _start) as usize] = _value[1];
                    }
                    if _start <= 226 && _end > 226 {
                        _buf[(226 - _start) as usize] = _value[2];
                    }
                    if _start <= 227 && _end > 227 {
                        _buf[(227 - _start) as usize] = _value[3];
                    }
                }
                if _start < 232 && _end > 228 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(25)?
                        .to_ne_bytes();
                    if _start <= 228 && _end > 228 {
                        _buf[(228 - _start) as usize] = _value[0];
                    }
                    if _start <= 229 && _end > 229 {
                        _buf[(229 - _start) as usize] = _value[1];
                    }
                    if _start <= 230 && _end > 230 {
                        _buf[(230 - _start) as usize] = _value[2];
                    }
                    if _start <= 231 && _end > 231 {
                        _buf[(231 - _start) as usize] = _value[3];
                    }
                }
                if _start < 236 && _end > 232 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(26)?
                        .to_ne_bytes();
                    if _start <= 232 && _end > 232 {
                        _buf[(232 - _start) as usize] = _value[0];
                    }
                    if _start <= 233 && _end > 233 {
                        _buf[(233 - _start) as usize] = _value[1];
                    }
                    if _start <= 234 && _end > 234 {
                        _buf[(234 - _start) as usize] = _value[2];
                    }
                    if _start <= 235 && _end > 235 {
                        _buf[(235 - _start) as usize] = _value[3];
                    }
                }
                if _start < 240 && _end > 236 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(27)?
                        .to_ne_bytes();
                    if _start <= 236 && _end > 236 {
                        _buf[(236 - _start) as usize] = _value[0];
                    }
                    if _start <= 237 && _end > 237 {
                        _buf[(237 - _start) as usize] = _value[1];
                    }
                    if _start <= 238 && _end > 238 {
                        _buf[(238 - _start) as usize] = _value[2];
                    }
                    if _start <= 239 && _end > 239 {
                        _buf[(239 - _start) as usize] = _value[3];
                    }
                }
                if _start < 244 && _end > 240 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(28)?
                        .to_ne_bytes();
                    if _start <= 240 && _end > 240 {
                        _buf[(240 - _start) as usize] = _value[0];
                    }
                    if _start <= 241 && _end > 241 {
                        _buf[(241 - _start) as usize] = _value[1];
                    }
                    if _start <= 242 && _end > 242 {
                        _buf[(242 - _start) as usize] = _value[2];
                    }
                    if _start <= 243 && _end > 243 {
                        _buf[(243 - _start) as usize] = _value[3];
                    }
                }
                if _start < 248 && _end > 244 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(29)?
                        .to_ne_bytes();
                    if _start <= 244 && _end > 244 {
                        _buf[(244 - _start) as usize] = _value[0];
                    }
                    if _start <= 245 && _end > 245 {
                        _buf[(245 - _start) as usize] = _value[1];
                    }
                    if _start <= 246 && _end > 246 {
                        _buf[(246 - _start) as usize] = _value[2];
                    }
                    if _start <= 247 && _end > 247 {
                        _buf[(247 - _start) as usize] = _value[3];
                    }
                }
                if _start < 252 && _end > 248 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(30)?
                        .to_ne_bytes();
                    if _start <= 248 && _end > 248 {
                        _buf[(248 - _start) as usize] = _value[0];
                    }
                    if _start <= 249 && _end > 249 {
                        _buf[(249 - _start) as usize] = _value[1];
                    }
                    if _start <= 250 && _end > 250 {
                        _buf[(250 - _start) as usize] = _value[2];
                    }
                    if _start <= 251 && _end > 251 {
                        _buf[(251 - _start) as usize] = _value[3];
                    }
                }
                if _start < 256 && _end > 252 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uicr_customern(31)?
                        .to_ne_bytes();
                    if _start <= 252 && _end > 252 {
                        _buf[(252 - _start) as usize] = _value[0];
                    }
                    if _start <= 253 && _end > 253 {
                        _buf[(253 - _start) as usize] = _value[1];
                    }
                    if _start <= 254 && _end > 254 {
                        _buf[(254 - _start) as usize] = _value[2];
                    }
                    if _start <= 255 && _end > 255 {
                        _buf[(255 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=527, 513..=528) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_uicr_pselresetn(0)?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                if _start < 520 && _end > 516 {
                    let _value = self.read_uicr_pselresetn(1)?.to_ne_bytes();
                    if _start <= 516 && _end > 516 {
                        _buf[(516 - _start) as usize] = _value[0];
                    }
                    if _start <= 517 && _end > 517 {
                        _buf[(517 - _start) as usize] = _value[1];
                    }
                    if _start <= 518 && _end > 518 {
                        _buf[(518 - _start) as usize] = _value[2];
                    }
                    if _start <= 519 && _end > 519 {
                        _buf[(519 - _start) as usize] = _value[3];
                    }
                }
                if _start < 524 && _end > 520 {
                    let _value = self.read_uicr_approtect()?.to_ne_bytes();
                    if _start <= 520 && _end > 520 {
                        _buf[(520 - _start) as usize] = _value[0];
                    }
                    if _start <= 521 && _end > 521 {
                        _buf[(521 - _start) as usize] = _value[1];
                    }
                    if _start <= 522 && _end > 522 {
                        _buf[(522 - _start) as usize] = _value[2];
                    }
                    if _start <= 523 && _end > 523 {
                        _buf[(523 - _start) as usize] = _value[3];
                    }
                }
                if _start < 528 && _end > 524 {
                    let _value = self.read_uicr_nfcpins()?.to_ne_bytes();
                    if _start <= 524 && _end > 524 {
                        _buf[(524 - _start) as usize] = _value[0];
                    }
                    if _start <= 525 && _end > 525 {
                        _buf[(525 - _start) as usize] = _value[1];
                    }
                    if _start <= 526 && _end > 526 {
                        _buf[(526 - _start) as usize] = _value[2];
                    }
                    if _start <= 527 && _end > 527 {
                        _buf[(527 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 268439552;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for UICR UNUSED0 not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_unused0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for UICR UNUSED1 not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_unused1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for UICR UNUSED2 not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_unused2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (16..=255, 17..=256) => {
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16 && _end >= 20u64,
                        "partial write for UICR UNUSED3 not implemented",
                    );
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_unused3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert!(
                        _start <= 20 && _end >= 24u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(20) as usize;
                    let end = (_end.saturating_sub(20) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 28 && _end > 24 {
                    assert!(
                        _start <= 24 && _end >= 28u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(24) as usize;
                    let end = (_end.saturating_sub(24) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28 && _end >= 32u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(28) as usize;
                    let end = (_end.saturating_sub(28) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 36 && _end > 32 {
                    assert!(
                        _start <= 32 && _end >= 36u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(32) as usize;
                    let end = (_end.saturating_sub(32) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 40 && _end > 36 {
                    assert!(
                        _start <= 36 && _end >= 40u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(36) as usize;
                    let end = (_end.saturating_sub(36) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 44 && _end > 40 {
                    assert!(
                        _start <= 40 && _end >= 44u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(40) as usize;
                    let end = (_end.saturating_sub(40) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 48 && _end > 44 {
                    assert!(
                        _start <= 44 && _end >= 48u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(44) as usize;
                    let end = (_end.saturating_sub(44) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 52 && _end > 48 {
                    assert!(
                        _start <= 48 && _end >= 52u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(48) as usize;
                    let end = (_end.saturating_sub(48) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 56 && _end > 52 {
                    assert!(
                        _start <= 52 && _end >= 56u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(52) as usize;
                    let end = (_end.saturating_sub(52) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 60 && _end > 56 {
                    assert!(
                        _start <= 56 && _end >= 60u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(56) as usize;
                    let end = (_end.saturating_sub(56) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 64 && _end > 60 {
                    assert!(
                        _start <= 60 && _end >= 64u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(60) as usize;
                    let end = (_end.saturating_sub(60) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 68 && _end > 64 {
                    assert!(
                        _start <= 64 && _end >= 68u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(64) as usize;
                    let end = (_end.saturating_sub(64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 72 && _end > 68 {
                    assert!(
                        _start <= 68 && _end >= 72u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(68) as usize;
                    let end = (_end.saturating_sub(68) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 76 && _end > 72 {
                    assert!(
                        _start <= 72 && _end >= 76u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(72) as usize;
                    let end = (_end.saturating_sub(72) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 80 && _end > 76 {
                    assert!(
                        _start <= 76 && _end >= 80u64,
                        "partial write for UICR NRFFW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(76) as usize;
                    let end = (_end.saturating_sub(76) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrffwn(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 84 && _end > 80 {
                    assert!(
                        _start <= 80 && _end >= 84u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(80) as usize;
                    let end = (_end.saturating_sub(80) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 88 && _end > 84 {
                    assert!(
                        _start <= 84 && _end >= 88u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(84) as usize;
                    let end = (_end.saturating_sub(84) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 92 && _end > 88 {
                    assert!(
                        _start <= 88 && _end >= 92u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(88) as usize;
                    let end = (_end.saturating_sub(88) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 96 && _end > 92 {
                    assert!(
                        _start <= 92 && _end >= 96u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(92) as usize;
                    let end = (_end.saturating_sub(92) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 100 && _end > 96 {
                    assert!(
                        _start <= 96 && _end >= 100u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(96) as usize;
                    let end = (_end.saturating_sub(96) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 104 && _end > 100 {
                    assert!(
                        _start <= 100 && _end >= 104u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(100) as usize;
                    let end =
                        (_end.saturating_sub(100) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 108 && _end > 104 {
                    assert!(
                        _start <= 104 && _end >= 108u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(104) as usize;
                    let end =
                        (_end.saturating_sub(104) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 112 && _end > 108 {
                    assert!(
                        _start <= 108 && _end >= 112u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(108) as usize;
                    let end =
                        (_end.saturating_sub(108) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 116 && _end > 112 {
                    assert!(
                        _start <= 112 && _end >= 116u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(112) as usize;
                    let end =
                        (_end.saturating_sub(112) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 120 && _end > 116 {
                    assert!(
                        _start <= 116 && _end >= 120u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(116) as usize;
                    let end =
                        (_end.saturating_sub(116) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 124 && _end > 120 {
                    assert!(
                        _start <= 120 && _end >= 124u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(120) as usize;
                    let end =
                        (_end.saturating_sub(120) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 128 && _end > 124 {
                    assert!(
                        _start <= 124 && _end >= 128u64,
                        "partial write for UICR NRFHW[%s] not implemented",
                    );
                    let start = _start.saturating_sub(124) as usize;
                    let end =
                        (_end.saturating_sub(124) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_nrfhwn(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 132 && _end > 128 {
                    assert!(
                        _start <= 128 && _end >= 132u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(128) as usize;
                    let end =
                        (_end.saturating_sub(128) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 136 && _end > 132 {
                    assert!(
                        _start <= 132 && _end >= 136u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(132) as usize;
                    let end =
                        (_end.saturating_sub(132) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 140 && _end > 136 {
                    assert!(
                        _start <= 136 && _end >= 140u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(136) as usize;
                    let end =
                        (_end.saturating_sub(136) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 144 && _end > 140 {
                    assert!(
                        _start <= 140 && _end >= 144u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(140) as usize;
                    let end =
                        (_end.saturating_sub(140) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 148 && _end > 144 {
                    assert!(
                        _start <= 144 && _end >= 148u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(144) as usize;
                    let end =
                        (_end.saturating_sub(144) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 152 && _end > 148 {
                    assert!(
                        _start <= 148 && _end >= 152u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(148) as usize;
                    let end =
                        (_end.saturating_sub(148) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 156 && _end > 152 {
                    assert!(
                        _start <= 152 && _end >= 156u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(152) as usize;
                    let end =
                        (_end.saturating_sub(152) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 160 && _end > 156 {
                    assert!(
                        _start <= 156 && _end >= 160u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(156) as usize;
                    let end =
                        (_end.saturating_sub(156) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 164 && _end > 160 {
                    assert!(
                        _start <= 160 && _end >= 164u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(160) as usize;
                    let end =
                        (_end.saturating_sub(160) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 168 && _end > 164 {
                    assert!(
                        _start <= 164 && _end >= 168u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(164) as usize;
                    let end =
                        (_end.saturating_sub(164) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 172 && _end > 168 {
                    assert!(
                        _start <= 168 && _end >= 172u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(168) as usize;
                    let end =
                        (_end.saturating_sub(168) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 176 && _end > 172 {
                    assert!(
                        _start <= 172 && _end >= 176u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(172) as usize;
                    let end =
                        (_end.saturating_sub(172) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 180 && _end > 176 {
                    assert!(
                        _start <= 176 && _end >= 180u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(176) as usize;
                    let end =
                        (_end.saturating_sub(176) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 184 && _end > 180 {
                    assert!(
                        _start <= 180 && _end >= 184u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(180) as usize;
                    let end =
                        (_end.saturating_sub(180) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 188 && _end > 184 {
                    assert!(
                        _start <= 184 && _end >= 188u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(184) as usize;
                    let end =
                        (_end.saturating_sub(184) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 192 && _end > 188 {
                    assert!(
                        _start <= 188 && _end >= 192u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(188) as usize;
                    let end =
                        (_end.saturating_sub(188) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 196 && _end > 192 {
                    assert!(
                        _start <= 192 && _end >= 196u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(192) as usize;
                    let end =
                        (_end.saturating_sub(192) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        16,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 200 && _end > 196 {
                    assert!(
                        _start <= 196 && _end >= 200u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(196) as usize;
                    let end =
                        (_end.saturating_sub(196) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        17,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 204 && _end > 200 {
                    assert!(
                        _start <= 200 && _end >= 204u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(200) as usize;
                    let end =
                        (_end.saturating_sub(200) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        18,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 208 && _end > 204 {
                    assert!(
                        _start <= 204 && _end >= 208u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(204) as usize;
                    let end =
                        (_end.saturating_sub(204) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        19,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 212 && _end > 208 {
                    assert!(
                        _start <= 208 && _end >= 212u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(208) as usize;
                    let end =
                        (_end.saturating_sub(208) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        20,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 216 && _end > 212 {
                    assert!(
                        _start <= 212 && _end >= 216u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(212) as usize;
                    let end =
                        (_end.saturating_sub(212) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        21,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 220 && _end > 216 {
                    assert!(
                        _start <= 216 && _end >= 220u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(216) as usize;
                    let end =
                        (_end.saturating_sub(216) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        22,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 224 && _end > 220 {
                    assert!(
                        _start <= 220 && _end >= 224u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(220) as usize;
                    let end =
                        (_end.saturating_sub(220) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        23,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 228 && _end > 224 {
                    assert!(
                        _start <= 224 && _end >= 228u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(224) as usize;
                    let end =
                        (_end.saturating_sub(224) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        24,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 232 && _end > 228 {
                    assert!(
                        _start <= 228 && _end >= 232u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(228) as usize;
                    let end =
                        (_end.saturating_sub(228) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        25,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 236 && _end > 232 {
                    assert!(
                        _start <= 232 && _end >= 236u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(232) as usize;
                    let end =
                        (_end.saturating_sub(232) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        26,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 240 && _end > 236 {
                    assert!(
                        _start <= 236 && _end >= 240u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(236) as usize;
                    let end =
                        (_end.saturating_sub(236) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        27,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 244 && _end > 240 {
                    assert!(
                        _start <= 240 && _end >= 244u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(240) as usize;
                    let end =
                        (_end.saturating_sub(240) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        28,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 248 && _end > 244 {
                    assert!(
                        _start <= 244 && _end >= 248u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(244) as usize;
                    let end =
                        (_end.saturating_sub(244) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        29,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 252 && _end > 248 {
                    assert!(
                        _start <= 248 && _end >= 252u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(248) as usize;
                    let end =
                        (_end.saturating_sub(248) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        30,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 256 && _end > 252 {
                    assert!(
                        _start <= 252 && _end >= 256u64,
                        "partial write for UICR CUSTOMER[%s] not implemented",
                    );
                    let start = _start.saturating_sub(252) as usize;
                    let end =
                        (_end.saturating_sub(252) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uicr_customern(
                        31,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=527, 513..=528) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_uicr_pselresetn(0, offset, &_buf[start..end])?;
                }
                if _start < 520 && _end > 516 {
                    let offset = _start.saturating_sub(516);
                    let start = 516u64.saturating_sub(_start) as usize;
                    let end = ((_end - 516) - offset) as usize;
                    self.write_uicr_pselresetn(1, offset, &_buf[start..end])?;
                }
                if _start < 524 && _end > 520 {
                    let offset = _start.saturating_sub(520);
                    let start = 520u64.saturating_sub(_start) as usize;
                    let end = ((_end - 520) - offset) as usize;
                    self.write_uicr_approtect(offset, &_buf[start..end])?;
                }
                if _start < 528 && _end > 524 {
                    let offset = _start.saturating_sub(524);
                    let start = 524u64.saturating_sub(_start) as usize;
                    let end = ((_end - 524) - offset) as usize;
                    self.write_uicr_nfcpins(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x10001000 {
    fn read_uicr_pselresetn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 2147483584;
        _value |=
            u32::from(self.0.lock().unwrap().read_uicr_pselresetn_pin(_dim)?)
                << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uicr_pselresetn_connect(_dim)?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_uicr_pselresetn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uicr_pselresetn_pin(_dim, (_value[_i] >> 0) & 63u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_uicr_pselresetn_connect(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_uicr_approtect(&self) -> MemResult<u32> {
        let mut _value = 4294967040;
        _value |= u32::from(self.0.lock().unwrap().read_uicr_approtect_pall()?)
            << 0u32;
        Ok(_value)
    }
    fn write_uicr_approtect(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uicr_approtect_pall((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_uicr_nfcpins(&self) -> MemResult<u32> {
        let mut _value = 4294967294;
        _value |=
            u32::from(self.0.lock().unwrap().read_uicr_nfcpins_protect()?)
                << 0u32;
        Ok(_value)
    }
    fn write_uicr_nfcpins(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uicr_nfcpins_protect((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40000000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40000000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073741824;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=27, 1..=28) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 24 && _end > 20 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 28 && _end > 24 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (120..=127, 121..=128) => {
                if _start < 124 && _end > 120 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 128 && _end > 124 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=283, 257..=284) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_clock_events_hfclkstarted()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_clock_events_lfclkstarted()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_power_events_pofwarn()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_clock_events_done()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_clock_events_ctto()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_power_events_sleepenter()?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_power_events_sleepexit()?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_powerclock_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_powerclock_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_power_resetreas()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1032..=1039, 1033..=1040) => {
                if _start < 1036 && _end > 1032 {
                    let _value = self.read_clock_hfclkrun()?.to_ne_bytes();
                    if _start <= 1032 && _end > 1032 {
                        _buf[(1032 - _start) as usize] = _value[0];
                    }
                    if _start <= 1033 && _end > 1033 {
                        _buf[(1033 - _start) as usize] = _value[1];
                    }
                    if _start <= 1034 && _end > 1034 {
                        _buf[(1034 - _start) as usize] = _value[2];
                    }
                    if _start <= 1035 && _end > 1035 {
                        _buf[(1035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _value = self.read_clock_hfclkstat()?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1044..=1055, 1045..=1056) => {
                if _start < 1048 && _end > 1044 {
                    let _value = self.read_clock_lfclkrun()?.to_ne_bytes();
                    if _start <= 1044 && _end > 1044 {
                        _buf[(1044 - _start) as usize] = _value[0];
                    }
                    if _start <= 1045 && _end > 1045 {
                        _buf[(1045 - _start) as usize] = _value[1];
                    }
                    if _start <= 1046 && _end > 1046 {
                        _buf[(1046 - _start) as usize] = _value[2];
                    }
                    if _start <= 1047 && _end > 1047 {
                        _buf[(1047 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1052 && _end > 1048 {
                    let _value = self.read_clock_lfclkstat()?.to_ne_bytes();
                    if _start <= 1048 && _end > 1048 {
                        _buf[(1048 - _start) as usize] = _value[0];
                    }
                    if _start <= 1049 && _end > 1049 {
                        _buf[(1049 - _start) as usize] = _value[1];
                    }
                    if _start <= 1050 && _end > 1050 {
                        _buf[(1050 - _start) as usize] = _value[2];
                    }
                    if _start <= 1051 && _end > 1051 {
                        _buf[(1051 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1056 && _end > 1052 {
                    let _value = self.read_clock_lfclksrccopy()?.to_ne_bytes();
                    if _start <= 1052 && _end > 1052 {
                        _buf[(1052 - _start) as usize] = _value[0];
                    }
                    if _start <= 1053 && _end > 1053 {
                        _buf[(1053 - _start) as usize] = _value[1];
                    }
                    if _start <= 1054 && _end > 1054 {
                        _buf[(1054 - _start) as usize] = _value[2];
                    }
                    if _start <= 1055 && _end > 1055 {
                        _buf[(1055 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1064..=1067, 1065..=1068) => {
                if _start < 1068 && _end > 1064 {
                    let _value = self.read_power_ramstatus()?.to_ne_bytes();
                    if _start <= 1064 && _end > 1064 {
                        _buf[(1064 - _start) as usize] = _value[0];
                    }
                    if _start <= 1065 && _end > 1065 {
                        _buf[(1065 - _start) as usize] = _value[1];
                    }
                    if _start <= 1066 && _end > 1066 {
                        _buf[(1066 - _start) as usize] = _value[2];
                    }
                    if _start <= 1067 && _end > 1067 {
                        _buf[(1067 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_power_pofcon()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1304..=1319, 1305..=1320) => {
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_clock_lfclksrc()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_power_gpregret()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_power_gpregret2()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_power_ramon()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let _value = self.read_clock_ctiv()?.to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1364..=1367, 1365..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let _value = self.read_power_ramonb()?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _value = self.read_clock_traceconfig()?.to_ne_bytes();
                    if _start <= 1372 && _end > 1372 {
                        _buf[(1372 - _start) as usize] = _value[0];
                    }
                    if _start <= 1373 && _end > 1373 {
                        _buf[(1373 - _start) as usize] = _value[1];
                    }
                    if _start <= 1374 && _end > 1374 {
                        _buf[(1374 - _start) as usize] = _value[2];
                    }
                    if _start <= 1375 && _end > 1375 {
                        _buf[(1375 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1400..=1403, 1401..=1404) => {
                if _start < 1404 && _end > 1400 {
                    let _value = self.read_power_dcdcen()?.to_ne_bytes();
                    if _start <= 1400 && _end > 1400 {
                        _buf[(1400 - _start) as usize] = _value[0];
                    }
                    if _start <= 1401 && _end > 1401 {
                        _buf[(1401 - _start) as usize] = _value[1];
                    }
                    if _start <= 1402 && _end > 1402 {
                        _buf[(1402 - _start) as usize] = _value[2];
                    }
                    if _start <= 1403 && _end > 1403 {
                        _buf[(1403 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1536..=1559, 1537..=1560) => {
                if _start < 1540 && _end > 1536 {
                    let _value = self.read_bprot_config0()?.to_ne_bytes();
                    if _start <= 1536 && _end > 1536 {
                        _buf[(1536 - _start) as usize] = _value[0];
                    }
                    if _start <= 1537 && _end > 1537 {
                        _buf[(1537 - _start) as usize] = _value[1];
                    }
                    if _start <= 1538 && _end > 1538 {
                        _buf[(1538 - _start) as usize] = _value[2];
                    }
                    if _start <= 1539 && _end > 1539 {
                        _buf[(1539 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1544 && _end > 1540 {
                    let _value = self.read_bprot_config1()?.to_ne_bytes();
                    if _start <= 1540 && _end > 1540 {
                        _buf[(1540 - _start) as usize] = _value[0];
                    }
                    if _start <= 1541 && _end > 1541 {
                        _buf[(1541 - _start) as usize] = _value[1];
                    }
                    if _start <= 1542 && _end > 1542 {
                        _buf[(1542 - _start) as usize] = _value[2];
                    }
                    if _start <= 1543 && _end > 1543 {
                        _buf[(1543 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1548 && _end > 1544 {
                    let _value =
                        self.read_bprot_disableindebug()?.to_ne_bytes();
                    if _start <= 1544 && _end > 1544 {
                        _buf[(1544 - _start) as usize] = _value[0];
                    }
                    if _start <= 1545 && _end > 1545 {
                        _buf[(1545 - _start) as usize] = _value[1];
                    }
                    if _start <= 1546 && _end > 1546 {
                        _buf[(1546 - _start) as usize] = _value[2];
                    }
                    if _start <= 1547 && _end > 1547 {
                        _buf[(1547 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1552 && _end > 1548 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_bprot_unused0()?
                        .to_ne_bytes();
                    if _start <= 1548 && _end > 1548 {
                        _buf[(1548 - _start) as usize] = _value[0];
                    }
                    if _start <= 1549 && _end > 1549 {
                        _buf[(1549 - _start) as usize] = _value[1];
                    }
                    if _start <= 1550 && _end > 1550 {
                        _buf[(1550 - _start) as usize] = _value[2];
                    }
                    if _start <= 1551 && _end > 1551 {
                        _buf[(1551 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1556 && _end > 1552 {
                    let _value = self.read_bprot_config2()?.to_ne_bytes();
                    if _start <= 1552 && _end > 1552 {
                        _buf[(1552 - _start) as usize] = _value[0];
                    }
                    if _start <= 1553 && _end > 1553 {
                        _buf[(1553 - _start) as usize] = _value[1];
                    }
                    if _start <= 1554 && _end > 1554 {
                        _buf[(1554 - _start) as usize] = _value[2];
                    }
                    if _start <= 1555 && _end > 1555 {
                        _buf[(1555 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1560 && _end > 1556 {
                    let _value = self.read_bprot_config3()?.to_ne_bytes();
                    if _start <= 1556 && _end > 1556 {
                        _buf[(1556 - _start) as usize] = _value[0];
                    }
                    if _start <= 1557 && _end > 1557 {
                        _buf[(1557 - _start) as usize] = _value[1];
                    }
                    if _start <= 1558 && _end > 1558 {
                        _buf[(1558 - _start) as usize] = _value[2];
                    }
                    if _start <= 1559 && _end > 1559 {
                        _buf[(1559 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (2304..=2315, 2305..=2316) => {
                if _start < 2308 && _end > 2304 {
                    let _value = self.read_power_ramn_power(0)?.to_ne_bytes();
                    if _start <= 2304 && _end > 2304 {
                        _buf[(2304 - _start) as usize] = _value[0];
                    }
                    if _start <= 2305 && _end > 2305 {
                        _buf[(2305 - _start) as usize] = _value[1];
                    }
                    if _start <= 2306 && _end > 2306 {
                        _buf[(2306 - _start) as usize] = _value[2];
                    }
                    if _start <= 2307 && _end > 2307 {
                        _buf[(2307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2312 && _end > 2308 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 2316 && _end > 2312 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (2320..=2331, 2321..=2332) => {
                if _start < 2324 && _end > 2320 {
                    let _value = self.read_power_ramn_power(1)?.to_ne_bytes();
                    if _start <= 2320 && _end > 2320 {
                        _buf[(2320 - _start) as usize] = _value[0];
                    }
                    if _start <= 2321 && _end > 2321 {
                        _buf[(2321 - _start) as usize] = _value[1];
                    }
                    if _start <= 2322 && _end > 2322 {
                        _buf[(2322 - _start) as usize] = _value[2];
                    }
                    if _start <= 2323 && _end > 2323 {
                        _buf[(2323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2328 && _end > 2324 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 2332 && _end > 2328 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (2336..=2347, 2337..=2348) => {
                if _start < 2340 && _end > 2336 {
                    let _value = self.read_power_ramn_power(2)?.to_ne_bytes();
                    if _start <= 2336 && _end > 2336 {
                        _buf[(2336 - _start) as usize] = _value[0];
                    }
                    if _start <= 2337 && _end > 2337 {
                        _buf[(2337 - _start) as usize] = _value[1];
                    }
                    if _start <= 2338 && _end > 2338 {
                        _buf[(2338 - _start) as usize] = _value[2];
                    }
                    if _start <= 2339 && _end > 2339 {
                        _buf[(2339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2344 && _end > 2340 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 2348 && _end > 2344 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (2352..=2363, 2353..=2364) => {
                if _start < 2356 && _end > 2352 {
                    let _value = self.read_power_ramn_power(3)?.to_ne_bytes();
                    if _start <= 2352 && _end > 2352 {
                        _buf[(2352 - _start) as usize] = _value[0];
                    }
                    if _start <= 2353 && _end > 2353 {
                        _buf[(2353 - _start) as usize] = _value[1];
                    }
                    if _start <= 2354 && _end > 2354 {
                        _buf[(2354 - _start) as usize] = _value[2];
                    }
                    if _start <= 2355 && _end > 2355 {
                        _buf[(2355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2360 && _end > 2356 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 2364 && _end > 2360 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (2368..=2379, 2369..=2380) => {
                if _start < 2372 && _end > 2368 {
                    let _value = self.read_power_ramn_power(4)?.to_ne_bytes();
                    if _start <= 2368 && _end > 2368 {
                        _buf[(2368 - _start) as usize] = _value[0];
                    }
                    if _start <= 2369 && _end > 2369 {
                        _buf[(2369 - _start) as usize] = _value[1];
                    }
                    if _start <= 2370 && _end > 2370 {
                        _buf[(2370 - _start) as usize] = _value[2];
                    }
                    if _start <= 2371 && _end > 2371 {
                        _buf[(2371 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2376 && _end > 2372 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 2380 && _end > 2376 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (2384..=2395, 2385..=2396) => {
                if _start < 2388 && _end > 2384 {
                    let _value = self.read_power_ramn_power(5)?.to_ne_bytes();
                    if _start <= 2384 && _end > 2384 {
                        _buf[(2384 - _start) as usize] = _value[0];
                    }
                    if _start <= 2385 && _end > 2385 {
                        _buf[(2385 - _start) as usize] = _value[1];
                    }
                    if _start <= 2386 && _end > 2386 {
                        _buf[(2386 - _start) as usize] = _value[2];
                    }
                    if _start <= 2387 && _end > 2387 {
                        _buf[(2387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2392 && _end > 2388 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 2396 && _end > 2392 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (2400..=2411, 2401..=2412) => {
                if _start < 2404 && _end > 2400 {
                    let _value = self.read_power_ramn_power(6)?.to_ne_bytes();
                    if _start <= 2400 && _end > 2400 {
                        _buf[(2400 - _start) as usize] = _value[0];
                    }
                    if _start <= 2401 && _end > 2401 {
                        _buf[(2401 - _start) as usize] = _value[1];
                    }
                    if _start <= 2402 && _end > 2402 {
                        _buf[(2402 - _start) as usize] = _value[2];
                    }
                    if _start <= 2403 && _end > 2403 {
                        _buf[(2403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2408 && _end > 2404 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 2412 && _end > 2408 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (2416..=2427, 2417..=2428) => {
                if _start < 2420 && _end > 2416 {
                    let _value = self.read_power_ramn_power(7)?.to_ne_bytes();
                    if _start <= 2416 && _end > 2416 {
                        _buf[(2416 - _start) as usize] = _value[0];
                    }
                    if _start <= 2417 && _end > 2417 {
                        _buf[(2417 - _start) as usize] = _value[1];
                    }
                    if _start <= 2418 && _end > 2418 {
                        _buf[(2418 - _start) as usize] = _value[2];
                    }
                    if _start <= 2419 && _end > 2419 {
                        _buf[(2419 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2424 && _end > 2420 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 2428 && _end > 2424 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073741824;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=27, 1..=28) => {
                if _start < 4 && _end > 0 {
                    assert ! (_start <= 0 && _end >= 4u64 , "partial write for CLOCK TASKS_HFCLKSTART not implemented" ,);
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_hfclkstart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert ! (_start <= 4 && _end >= 8u64 , "partial write for CLOCK TASKS_HFCLKSTOP not implemented" ,);
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_hfclkstop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert ! (_start <= 8 && _end >= 12u64 , "partial write for CLOCK TASKS_LFCLKSTART not implemented" ,);
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_lfclkstart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert ! (_start <= 12 && _end >= 16u64 , "partial write for CLOCK TASKS_LFCLKSTOP not implemented" ,);
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_lfclkstop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16 && _end >= 20u64,
                        "partial write for CLOCK TASKS_CAL not implemented",
                    );
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_cal(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert!(
                        _start <= 20 && _end >= 24u64,
                        "partial write for CLOCK TASKS_CTSTART not implemented",
                    );
                    let start = _start.saturating_sub(20) as usize;
                    let end = (_end.saturating_sub(20) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_ctstart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 28 && _end > 24 {
                    assert!(
                        _start <= 24 && _end >= 28u64,
                        "partial write for CLOCK TASKS_CTSTOP not implemented",
                    );
                    let start = _start.saturating_sub(24) as usize;
                    let end = (_end.saturating_sub(24) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_tasks_ctstop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (120..=127, 121..=128) => {
                if _start < 124 && _end > 120 {
                    assert ! (_start <= 120 && _end >= 124u64 , "partial write for POWER TASKS_CONSTLAT not implemented" ,);
                    let start = _start.saturating_sub(120) as usize;
                    let end =
                        (_end.saturating_sub(120) as usize).min(start + 4);
                    self.0.lock().unwrap().write_power_tasks_constlat(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 128 && _end > 124 {
                    assert!(
                        _start <= 124 && _end >= 128u64,
                        "partial write for POWER TASKS_LOWPWR not implemented",
                    );
                    let start = _start.saturating_sub(124) as usize;
                    let end =
                        (_end.saturating_sub(124) as usize).min(start + 4);
                    self.0.lock().unwrap().write_power_tasks_lowpwr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=283, 257..=284) => {
                if _start < 260 && _end > 256 {
                    assert ! (_start <= 256 && _end >= 260u64 , "partial write for CLOCK EVENTS_HFCLKSTARTED not implemented" ,);
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_events_hfclkstarted(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260 && _end >= 264u64 , "partial write for CLOCK EVENTS_LFCLKSTARTED not implemented" ,);
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_events_lfclkstarted(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264 && _end >= 268u64 , "partial write for POWER EVENTS_POFWARN not implemented" ,);
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_power_events_pofwarn(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268 && _end >= 272u64,
                        "partial write for CLOCK EVENTS_DONE not implemented",
                    );
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_events_done(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272 && _end >= 276u64,
                        "partial write for CLOCK EVENTS_CTTO not implemented",
                    );
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_clock_events_ctto(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert ! (_start <= 276 && _end >= 280u64 , "partial write for POWER EVENTS_SLEEPENTER not implemented" ,);
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_power_events_sleepenter(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert ! (_start <= 280 && _end >= 284u64 , "partial write for POWER EVENTS_SLEEPEXIT not implemented" ,);
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_power_events_sleepexit(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_powerclock_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_powerclock_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let offset = _start.saturating_sub(1024);
                    let start = 1024u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1024) - offset) as usize;
                    self.write_power_resetreas(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1032..=1039, 1033..=1040) => {
                if _start < 1036 && _end > 1032 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1040 && _end > 1036 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1044..=1055, 1045..=1056) => {
                if _start < 1048 && _end > 1044 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1052 && _end > 1048 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1056 && _end > 1052 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1064..=1067, 1065..=1068) => {
                if _start < 1068 && _end > 1064 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_power_systemoff(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_power_pofcon(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1304..=1319, 1305..=1320) => {
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_clock_lfclksrc(offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_power_gpregret(offset, &_buf[start..end])?;
                }
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_power_gpregret2(offset, &_buf[start..end])?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_power_ramon(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let offset = _start.saturating_sub(1336);
                    let start = 1336u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1336) - offset) as usize;
                    self.write_clock_ctiv(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1364..=1367, 1365..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let offset = _start.saturating_sub(1364);
                    let start = 1364u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1364) - offset) as usize;
                    self.write_power_ramonb(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let offset = _start.saturating_sub(1372);
                    let start = 1372u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1372) - offset) as usize;
                    self.write_clock_traceconfig(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1400..=1403, 1401..=1404) => {
                if _start < 1404 && _end > 1400 {
                    let offset = _start.saturating_sub(1400);
                    let start = 1400u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1400) - offset) as usize;
                    self.write_power_dcdcen(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1536..=1559, 1537..=1560) => {
                if _start < 1540 && _end > 1536 {
                    let offset = _start.saturating_sub(1536);
                    let start = 1536u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1536) - offset) as usize;
                    self.write_bprot_config0(offset, &_buf[start..end])?;
                }
                if _start < 1544 && _end > 1540 {
                    let offset = _start.saturating_sub(1540);
                    let start = 1540u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1540) - offset) as usize;
                    self.write_bprot_config1(offset, &_buf[start..end])?;
                }
                if _start < 1548 && _end > 1544 {
                    let offset = _start.saturating_sub(1544);
                    let start = 1544u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1544) - offset) as usize;
                    self.write_bprot_disableindebug(offset, &_buf[start..end])?;
                }
                if _start < 1552 && _end > 1548 {
                    assert!(
                        _start <= 1548 && _end >= 1552u64,
                        "partial write for BPROT UNUSED0 not implemented",
                    );
                    let start = _start.saturating_sub(1548) as usize;
                    let end =
                        (_end.saturating_sub(1548) as usize).min(start + 4);
                    self.0.lock().unwrap().write_bprot_unused0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1556 && _end > 1552 {
                    let offset = _start.saturating_sub(1552);
                    let start = 1552u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1552) - offset) as usize;
                    self.write_bprot_config2(offset, &_buf[start..end])?;
                }
                if _start < 1560 && _end > 1556 {
                    let offset = _start.saturating_sub(1556);
                    let start = 1556u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1556) - offset) as usize;
                    self.write_bprot_config3(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (2304..=2315, 2305..=2316) => {
                if _start < 2308 && _end > 2304 {
                    let offset = _start.saturating_sub(2304);
                    let start = 2304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2304) - offset) as usize;
                    self.write_power_ramn_power(0, offset, &_buf[start..end])?;
                }
                if _start < 2312 && _end > 2308 {
                    let offset = _start.saturating_sub(2308);
                    let start = 2308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2308) - offset) as usize;
                    self.write_power_ramn_powerset(
                        0,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 2316 && _end > 2312 {
                    let offset = _start.saturating_sub(2312);
                    let start = 2312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2312) - offset) as usize;
                    self.write_power_ramn_powerclr(
                        0,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (2320..=2331, 2321..=2332) => {
                if _start < 2324 && _end > 2320 {
                    let offset = _start.saturating_sub(2320);
                    let start = 2320u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2320) - offset) as usize;
                    self.write_power_ramn_power(1, offset, &_buf[start..end])?;
                }
                if _start < 2328 && _end > 2324 {
                    let offset = _start.saturating_sub(2324);
                    let start = 2324u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2324) - offset) as usize;
                    self.write_power_ramn_powerset(
                        1,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 2332 && _end > 2328 {
                    let offset = _start.saturating_sub(2328);
                    let start = 2328u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2328) - offset) as usize;
                    self.write_power_ramn_powerclr(
                        1,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (2336..=2347, 2337..=2348) => {
                if _start < 2340 && _end > 2336 {
                    let offset = _start.saturating_sub(2336);
                    let start = 2336u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2336) - offset) as usize;
                    self.write_power_ramn_power(2, offset, &_buf[start..end])?;
                }
                if _start < 2344 && _end > 2340 {
                    let offset = _start.saturating_sub(2340);
                    let start = 2340u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2340) - offset) as usize;
                    self.write_power_ramn_powerset(
                        2,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 2348 && _end > 2344 {
                    let offset = _start.saturating_sub(2344);
                    let start = 2344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2344) - offset) as usize;
                    self.write_power_ramn_powerclr(
                        2,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (2352..=2363, 2353..=2364) => {
                if _start < 2356 && _end > 2352 {
                    let offset = _start.saturating_sub(2352);
                    let start = 2352u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2352) - offset) as usize;
                    self.write_power_ramn_power(3, offset, &_buf[start..end])?;
                }
                if _start < 2360 && _end > 2356 {
                    let offset = _start.saturating_sub(2356);
                    let start = 2356u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2356) - offset) as usize;
                    self.write_power_ramn_powerset(
                        3,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 2364 && _end > 2360 {
                    let offset = _start.saturating_sub(2360);
                    let start = 2360u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2360) - offset) as usize;
                    self.write_power_ramn_powerclr(
                        3,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (2368..=2379, 2369..=2380) => {
                if _start < 2372 && _end > 2368 {
                    let offset = _start.saturating_sub(2368);
                    let start = 2368u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2368) - offset) as usize;
                    self.write_power_ramn_power(4, offset, &_buf[start..end])?;
                }
                if _start < 2376 && _end > 2372 {
                    let offset = _start.saturating_sub(2372);
                    let start = 2372u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2372) - offset) as usize;
                    self.write_power_ramn_powerset(
                        4,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 2380 && _end > 2376 {
                    let offset = _start.saturating_sub(2376);
                    let start = 2376u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2376) - offset) as usize;
                    self.write_power_ramn_powerclr(
                        4,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (2384..=2395, 2385..=2396) => {
                if _start < 2388 && _end > 2384 {
                    let offset = _start.saturating_sub(2384);
                    let start = 2384u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2384) - offset) as usize;
                    self.write_power_ramn_power(5, offset, &_buf[start..end])?;
                }
                if _start < 2392 && _end > 2388 {
                    let offset = _start.saturating_sub(2388);
                    let start = 2388u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2388) - offset) as usize;
                    self.write_power_ramn_powerset(
                        5,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 2396 && _end > 2392 {
                    let offset = _start.saturating_sub(2392);
                    let start = 2392u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2392) - offset) as usize;
                    self.write_power_ramn_powerclr(
                        5,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (2400..=2411, 2401..=2412) => {
                if _start < 2404 && _end > 2400 {
                    let offset = _start.saturating_sub(2400);
                    let start = 2400u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2400) - offset) as usize;
                    self.write_power_ramn_power(6, offset, &_buf[start..end])?;
                }
                if _start < 2408 && _end > 2404 {
                    let offset = _start.saturating_sub(2404);
                    let start = 2404u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2404) - offset) as usize;
                    self.write_power_ramn_powerset(
                        6,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 2412 && _end > 2408 {
                    let offset = _start.saturating_sub(2408);
                    let start = 2408u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2408) - offset) as usize;
                    self.write_power_ramn_powerclr(
                        6,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (2416..=2427, 2417..=2428) => {
                if _start < 2420 && _end > 2416 {
                    let offset = _start.saturating_sub(2416);
                    let start = 2416u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2416) - offset) as usize;
                    self.write_power_ramn_power(7, offset, &_buf[start..end])?;
                }
                if _start < 2424 && _end > 2420 {
                    let offset = _start.saturating_sub(2420);
                    let start = 2420u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2420) - offset) as usize;
                    self.write_power_ramn_powerset(
                        7,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 2428 && _end > 2424 {
                    let offset = _start.saturating_sub(2424);
                    let start = 2424u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2424) - offset) as usize;
                    self.write_power_ramn_powerclr(
                        7,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40000000 {
    fn read_powerclock_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenset_hfclkstarted()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenset_lfclkstarted()?,
        ) << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_powerclock_intenset_pofwarn()?,
        ) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_powerclock_intenset_done()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_powerclock_intenset_ctto()?)
                << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenset_sleepenter()?,
        ) << 5u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenset_sleepexit()?,
        ) << 6u32;
        Ok(_value)
    }
    fn write_powerclock_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_hfclkstarted(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_lfclkstarted(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_powerclock_intenset_pofwarn(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_done((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_ctto((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenset_sleepenter(
                    (_value[_i] >> 5) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_powerclock_intenset_sleepexit(
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_powerclock_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenclr_hfclkstarted()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenclr_lfclkstarted()?,
        ) << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_powerclock_intenclr_pofwarn()?,
        ) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_powerclock_intenclr_done()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_powerclock_intenclr_ctto()?)
                << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenclr_sleepenter()?,
        ) << 5u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_powerclock_intenclr_sleepexit()?,
        ) << 6u32;
        Ok(_value)
    }
    fn write_powerclock_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_hfclkstarted(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_lfclkstarted(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_powerclock_intenclr_pofwarn(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_done((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_ctto((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_powerclock_intenclr_sleepenter(
                    (_value[_i] >> 5) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_powerclock_intenclr_sleepexit(
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_power_resetreas(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_resetreas_resetpin()?)
                << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_resetreas_dog()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_resetreas_sreq()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_resetreas_lockup()?)
                << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_resetreas_off()?)
            << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_resetreas_lpcomp()?)
                << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_resetreas_dif()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_resetreas_nfc()?)
            << 19u32;
        Ok(_value)
    }
    fn write_power_resetreas(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_resetpin((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_dog((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_sreq((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_lockup((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_off((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_lpcomp((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_dif((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_resetreas_nfc((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_clock_hfclkrun(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_hfclkrun_status()?)
                << 0u32;
        Ok(_value)
    }
    fn read_clock_hfclkstat(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_clock_hfclkstat_src()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_hfclkstat_state()?)
                << 16u32;
        Ok(_value)
    }
    fn read_clock_lfclkrun(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_lfclkrun_status()?)
                << 0u32;
        Ok(_value)
    }
    fn read_clock_lfclkstat(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_clock_lfclkstat_src()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_lfclkstat_state()?)
                << 16u32;
        Ok(_value)
    }
    fn read_clock_lfclksrccopy(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_lfclksrccopy_src()?)
                << 0u32;
        Ok(_value)
    }
    fn read_power_ramstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramstatus_ramblock0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramstatus_ramblock1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramstatus_ramblock2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramstatus_ramblock3()?)
                << 3u32;
        Ok(_value)
    }
    fn write_power_systemoff(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_systemoff_systemoff((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_pofcon(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_pofcon_pof()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_pofcon_threshold()?)
                << 1u32;
        Ok(_value)
    }
    fn write_power_pofcon(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_pofcon_pof((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_pofcon_threshold((_value[_i] >> 1) & 15u8)?;
        }
        Ok(())
    }
    fn read_clock_lfclksrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_clock_lfclksrc_src()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_lfclksrc_bypass()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_lfclksrc_external()?)
                << 17u32;
        Ok(_value)
    }
    fn write_clock_lfclksrc(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_lfclksrc_src((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_lfclksrc_bypass((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_lfclksrc_external((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_gpregret(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_gpregret_gpregret()?)
                << 0u32;
        Ok(_value)
    }
    fn write_power_gpregret(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_gpregret_gpregret((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_power_gpregret2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_gpregret2_gpregret()?)
                << 0u32;
        Ok(_value)
    }
    fn write_power_gpregret2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_gpregret2_gpregret((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_power_ramon(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramon_onram0()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramon_onram1()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramon_offram0()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramon_offram1()?)
            << 17u32;
        Ok(_value)
    }
    fn write_power_ramon(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramon_onram0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramon_onram1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramon_offram0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramon_offram1((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_clock_ctiv(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_clock_ctiv_ctiv()?) << 0u32;
        Ok(_value)
    }
    fn write_clock_ctiv(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_ctiv_ctiv((_value[_i] >> 0) & 127u8)?;
        }
        Ok(())
    }
    fn read_power_ramonb(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramonb_onram2()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_power_ramonb_onram3()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramonb_offram2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_power_ramonb_offram3()?)
                << 17u32;
        Ok(_value)
    }
    fn write_power_ramonb(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramonb_onram2((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramonb_onram3((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramonb_offram2((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramonb_offram3((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_clock_traceconfig(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_clock_traceconfig_traceportspeed()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_clock_traceconfig_tracemux()?,
        ) << 16u32;
        Ok(_value)
    }
    fn write_clock_traceconfig(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_traceconfig_traceportspeed(
                    (_value[_i] >> 0) & 3u8,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_clock_traceconfig_tracemux((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_power_dcdcen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_power_dcdcen_dcdcen()?)
            << 0u32;
        Ok(_value)
    }
    fn write_power_dcdcen(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_dcdcen_dcdcen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_bprot_config0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region3()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region4()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region5()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region6()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region7()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region8()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region9()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region10()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region11()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region12()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region13()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region14()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region15()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region16()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region17()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region18()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region19()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region20()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region21()?)
                << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region22()?)
                << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region23()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region24()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region25()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region26()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region27()?)
                << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region28()?)
                << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region29()?)
                << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region30()?)
                << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config0_region31()?)
                << 31u32;
        Ok(_value)
    }
    fn write_bprot_config0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config0_region31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_bprot_config1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region32()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region33()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region34()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region35()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region36()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region37()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region38()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region39()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region40()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region41()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region42()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region43()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region44()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region45()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region46()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region47()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region48()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region49()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region50()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region51()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region52()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region53()?)
                << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region54()?)
                << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region55()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region56()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region57()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region58()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region59()?)
                << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region60()?)
                << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region61()?)
                << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region62()?)
                << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config1_region63()?)
                << 31u32;
        Ok(_value)
    }
    fn write_bprot_config1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region32((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region33((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region34((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region35((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region36((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region37((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region38((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region39((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region40((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region41((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region42((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region43((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region44((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region45((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region46((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region47((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region48((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region49((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region50((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region51((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region52((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region53((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region54((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region55((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region56((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region57((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region58((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region59((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region60((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region61((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region62((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config1_region63((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_bprot_disableindebug(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_bprot_disableindebug_disableindebug()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_bprot_disableindebug(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_disableindebug_disableindebug(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_bprot_config2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region64()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region65()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region66()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region67()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region68()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region69()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region70()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region71()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region72()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region73()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region74()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region75()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region76()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region77()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region78()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region79()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region80()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region81()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region82()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region83()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region84()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region85()?)
                << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region86()?)
                << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region87()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region88()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region89()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region90()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region91()?)
                << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region92()?)
                << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region93()?)
                << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region94()?)
                << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config2_region95()?)
                << 31u32;
        Ok(_value)
    }
    fn write_bprot_config2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region64((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region65((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region66((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region67((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region68((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region69((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region70((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region71((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region72((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region73((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region74((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region75((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region76((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region77((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region78((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region79((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region80((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region81((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region82((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region83((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region84((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region85((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region86((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region87((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region88((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region89((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region90((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region91((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region92((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region93((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region94((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config2_region95((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_bprot_config3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region96()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region97()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region98()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region99()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region100()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region101()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region102()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region103()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region104()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region105()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region106()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region107()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region108()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region109()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region110()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region111()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region112()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region113()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region114()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region115()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region116()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region117()?)
                << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region118()?)
                << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region119()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region120()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region121()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region122()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region123()?)
                << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region124()?)
                << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region125()?)
                << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region126()?)
                << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_bprot_config3_region127()?)
                << 31u32;
        Ok(_value)
    }
    fn write_bprot_config3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region96((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region97((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region98((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region99((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region100((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region101((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region102((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region103((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region104((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region105((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region106((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region107((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region108((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region109((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region110((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region111((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region112((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region113((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region114((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region115((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region116((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region117((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region118((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region119((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region120((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region121((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region122((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region123((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region124((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region125((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region126((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_bprot_config3_region127((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_power_ramn_power(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 65532;
        _value |= u32::from(
            self.0.lock().unwrap().read_power_ramn_power_s0power(_dim)?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_power_ramn_power_s1power(_dim)?,
        ) << 1u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_power_ramn_power_s0retention(_dim)?,
        ) << 16u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_power_ramn_power_s1retention(_dim)?,
        ) << 17u32;
        Ok(_value)
    }
    fn write_power_ramn_power(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_power_ramn_power_s0power(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_power_ramn_power_s1power(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_power_ramn_power_s0retention(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_power_ramn_power_s1retention(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn write_power_ramn_powerset(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_power_ramn_powerset_s0power(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_power_ramn_powerset_s1power(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramn_powerset_s0retention(
                    _dim,
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramn_powerset_s1retention(
                    _dim,
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn write_power_ramn_powerclr(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_power_ramn_powerclr_s0power(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_power_ramn_powerclr_s1power(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramn_powerclr_s0retention(
                    _dim,
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_power_ramn_powerclr_s1retention(
                    _dim,
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40001000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40001000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073745920;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=35, 1..=36) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 24 && _end > 20 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 28 && _end > 24 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 32 && _end > 28 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 36 && _end > 32 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_ready()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_address()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_payload()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_end()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_disabled()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_devmatch()?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_devmiss()?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_rssiend()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_bcmatch()?
                        .to_ne_bytes();
                    if _start <= 296 && _end > 296 {
                        _buf[(296 - _start) as usize] = _value[0];
                    }
                    if _start <= 297 && _end > 297 {
                        _buf[(297 - _start) as usize] = _value[1];
                    }
                    if _start <= 298 && _end > 298 {
                        _buf[(298 - _start) as usize] = _value[2];
                    }
                    if _start <= 299 && _end > 299 {
                        _buf[(299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (304..=311, 305..=312) => {
                if _start < 308 && _end > 304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_crcok()?
                        .to_ne_bytes();
                    if _start <= 304 && _end > 304 {
                        _buf[(304 - _start) as usize] = _value[0];
                    }
                    if _start <= 305 && _end > 305 {
                        _buf[(305 - _start) as usize] = _value[1];
                    }
                    if _start <= 306 && _end > 306 {
                        _buf[(306 - _start) as usize] = _value[2];
                    }
                    if _start <= 307 && _end > 307 {
                        _buf[(307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 312 && _end > 308 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_events_crcerror()?
                        .to_ne_bytes();
                    if _start <= 308 && _end > 308 {
                        _buf[(308 - _start) as usize] = _value[0];
                    }
                    if _start <= 309 && _end > 309 {
                        _buf[(309 - _start) as usize] = _value[1];
                    }
                    if _start <= 310 && _end > 310 {
                        _buf[(310 - _start) as usize] = _value[2];
                    }
                    if _start <= 311 && _end > 311 {
                        _buf[(311 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_radio_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_radio_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_radio_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_radio_crcstatus()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1032..=1043, 1033..=1044) => {
                if _start < 1036 && _end > 1032 {
                    let _value = self.read_radio_rxmatch()?.to_ne_bytes();
                    if _start <= 1032 && _end > 1032 {
                        _buf[(1032 - _start) as usize] = _value[0];
                    }
                    if _start <= 1033 && _end > 1033 {
                        _buf[(1033 - _start) as usize] = _value[1];
                    }
                    if _start <= 1034 && _end > 1034 {
                        _buf[(1034 - _start) as usize] = _value[2];
                    }
                    if _start <= 1035 && _end > 1035 {
                        _buf[(1035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _value = self.read_radio_rxcrc()?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1044 && _end > 1040 {
                    let _value = self.read_radio_dai()?.to_ne_bytes();
                    if _start <= 1040 && _end > 1040 {
                        _buf[(1040 - _start) as usize] = _value[0];
                    }
                    if _start <= 1041 && _end > 1041 {
                        _buf[(1041 - _start) as usize] = _value[1];
                    }
                    if _start <= 1042 && _end > 1042 {
                        _buf[(1042 - _start) as usize] = _value[2];
                    }
                    if _start <= 1043 && _end > 1043 {
                        _buf[(1043 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1355, 1285..=1356) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_packetptr()?
                        .to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_radio_frequency()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_radio_txpower()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_radio_mode()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_radio_pcnf0()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_radio_pcnf1()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_base0()?
                        .to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_base1()?
                        .to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_radio_prefix0()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_radio_prefix1()?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _value = self.read_radio_txaddress()?.to_ne_bytes();
                    if _start <= 1324 && _end > 1324 {
                        _buf[(1324 - _start) as usize] = _value[0];
                    }
                    if _start <= 1325 && _end > 1325 {
                        _buf[(1325 - _start) as usize] = _value[1];
                    }
                    if _start <= 1326 && _end > 1326 {
                        _buf[(1326 - _start) as usize] = _value[2];
                    }
                    if _start <= 1327 && _end > 1327 {
                        _buf[(1327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _value = self.read_radio_rxaddresses()?.to_ne_bytes();
                    if _start <= 1328 && _end > 1328 {
                        _buf[(1328 - _start) as usize] = _value[0];
                    }
                    if _start <= 1329 && _end > 1329 {
                        _buf[(1329 - _start) as usize] = _value[1];
                    }
                    if _start <= 1330 && _end > 1330 {
                        _buf[(1330 - _start) as usize] = _value[2];
                    }
                    if _start <= 1331 && _end > 1331 {
                        _buf[(1331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _value = self.read_radio_crccnf()?.to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _value = self.read_radio_crcpoly()?.to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _value = self.read_radio_crcinit()?.to_ne_bytes();
                    if _start <= 1340 && _end > 1340 {
                        _buf[(1340 - _start) as usize] = _value[0];
                    }
                    if _start <= 1341 && _end > 1341 {
                        _buf[(1341 - _start) as usize] = _value[1];
                    }
                    if _start <= 1342 && _end > 1342 {
                        _buf[(1342 - _start) as usize] = _value[2];
                    }
                    if _start <= 1343 && _end > 1343 {
                        _buf[(1343 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1348 && _end > 1344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_unused0()?
                        .to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_radio_tifs()?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_radio_rssisample()?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1360..=1367, 1361..=1368) => {
                if _start < 1364 && _end > 1360 {
                    let _value = self.read_radio_state()?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _value = self.read_radio_datawhiteiv()?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1376..=1379, 1377..=1380) => {
                if _start < 1380 && _end > 1376 {
                    let _value =
                        self.0.lock().unwrap().read_radio_bcc()?.to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1536..=1603, 1537..=1604) => {
                if _start < 1540 && _end > 1536 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(0)?
                        .to_ne_bytes();
                    if _start <= 1536 && _end > 1536 {
                        _buf[(1536 - _start) as usize] = _value[0];
                    }
                    if _start <= 1537 && _end > 1537 {
                        _buf[(1537 - _start) as usize] = _value[1];
                    }
                    if _start <= 1538 && _end > 1538 {
                        _buf[(1538 - _start) as usize] = _value[2];
                    }
                    if _start <= 1539 && _end > 1539 {
                        _buf[(1539 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1544 && _end > 1540 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(1)?
                        .to_ne_bytes();
                    if _start <= 1540 && _end > 1540 {
                        _buf[(1540 - _start) as usize] = _value[0];
                    }
                    if _start <= 1541 && _end > 1541 {
                        _buf[(1541 - _start) as usize] = _value[1];
                    }
                    if _start <= 1542 && _end > 1542 {
                        _buf[(1542 - _start) as usize] = _value[2];
                    }
                    if _start <= 1543 && _end > 1543 {
                        _buf[(1543 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1548 && _end > 1544 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(2)?
                        .to_ne_bytes();
                    if _start <= 1544 && _end > 1544 {
                        _buf[(1544 - _start) as usize] = _value[0];
                    }
                    if _start <= 1545 && _end > 1545 {
                        _buf[(1545 - _start) as usize] = _value[1];
                    }
                    if _start <= 1546 && _end > 1546 {
                        _buf[(1546 - _start) as usize] = _value[2];
                    }
                    if _start <= 1547 && _end > 1547 {
                        _buf[(1547 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1552 && _end > 1548 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(3)?
                        .to_ne_bytes();
                    if _start <= 1548 && _end > 1548 {
                        _buf[(1548 - _start) as usize] = _value[0];
                    }
                    if _start <= 1549 && _end > 1549 {
                        _buf[(1549 - _start) as usize] = _value[1];
                    }
                    if _start <= 1550 && _end > 1550 {
                        _buf[(1550 - _start) as usize] = _value[2];
                    }
                    if _start <= 1551 && _end > 1551 {
                        _buf[(1551 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1556 && _end > 1552 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(4)?
                        .to_ne_bytes();
                    if _start <= 1552 && _end > 1552 {
                        _buf[(1552 - _start) as usize] = _value[0];
                    }
                    if _start <= 1553 && _end > 1553 {
                        _buf[(1553 - _start) as usize] = _value[1];
                    }
                    if _start <= 1554 && _end > 1554 {
                        _buf[(1554 - _start) as usize] = _value[2];
                    }
                    if _start <= 1555 && _end > 1555 {
                        _buf[(1555 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1560 && _end > 1556 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(5)?
                        .to_ne_bytes();
                    if _start <= 1556 && _end > 1556 {
                        _buf[(1556 - _start) as usize] = _value[0];
                    }
                    if _start <= 1557 && _end > 1557 {
                        _buf[(1557 - _start) as usize] = _value[1];
                    }
                    if _start <= 1558 && _end > 1558 {
                        _buf[(1558 - _start) as usize] = _value[2];
                    }
                    if _start <= 1559 && _end > 1559 {
                        _buf[(1559 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1564 && _end > 1560 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(6)?
                        .to_ne_bytes();
                    if _start <= 1560 && _end > 1560 {
                        _buf[(1560 - _start) as usize] = _value[0];
                    }
                    if _start <= 1561 && _end > 1561 {
                        _buf[(1561 - _start) as usize] = _value[1];
                    }
                    if _start <= 1562 && _end > 1562 {
                        _buf[(1562 - _start) as usize] = _value[2];
                    }
                    if _start <= 1563 && _end > 1563 {
                        _buf[(1563 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1568 && _end > 1564 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_radio_dabn(7)?
                        .to_ne_bytes();
                    if _start <= 1564 && _end > 1564 {
                        _buf[(1564 - _start) as usize] = _value[0];
                    }
                    if _start <= 1565 && _end > 1565 {
                        _buf[(1565 - _start) as usize] = _value[1];
                    }
                    if _start <= 1566 && _end > 1566 {
                        _buf[(1566 - _start) as usize] = _value[2];
                    }
                    if _start <= 1567 && _end > 1567 {
                        _buf[(1567 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1572 && _end > 1568 {
                    let _value = self.read_radio_dapn(0)?.to_ne_bytes();
                    if _start <= 1568 && _end > 1568 {
                        _buf[(1568 - _start) as usize] = _value[0];
                    }
                    if _start <= 1569 && _end > 1569 {
                        _buf[(1569 - _start) as usize] = _value[1];
                    }
                    if _start <= 1570 && _end > 1570 {
                        _buf[(1570 - _start) as usize] = _value[2];
                    }
                    if _start <= 1571 && _end > 1571 {
                        _buf[(1571 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1576 && _end > 1572 {
                    let _value = self.read_radio_dapn(1)?.to_ne_bytes();
                    if _start <= 1572 && _end > 1572 {
                        _buf[(1572 - _start) as usize] = _value[0];
                    }
                    if _start <= 1573 && _end > 1573 {
                        _buf[(1573 - _start) as usize] = _value[1];
                    }
                    if _start <= 1574 && _end > 1574 {
                        _buf[(1574 - _start) as usize] = _value[2];
                    }
                    if _start <= 1575 && _end > 1575 {
                        _buf[(1575 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1580 && _end > 1576 {
                    let _value = self.read_radio_dapn(2)?.to_ne_bytes();
                    if _start <= 1576 && _end > 1576 {
                        _buf[(1576 - _start) as usize] = _value[0];
                    }
                    if _start <= 1577 && _end > 1577 {
                        _buf[(1577 - _start) as usize] = _value[1];
                    }
                    if _start <= 1578 && _end > 1578 {
                        _buf[(1578 - _start) as usize] = _value[2];
                    }
                    if _start <= 1579 && _end > 1579 {
                        _buf[(1579 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1584 && _end > 1580 {
                    let _value = self.read_radio_dapn(3)?.to_ne_bytes();
                    if _start <= 1580 && _end > 1580 {
                        _buf[(1580 - _start) as usize] = _value[0];
                    }
                    if _start <= 1581 && _end > 1581 {
                        _buf[(1581 - _start) as usize] = _value[1];
                    }
                    if _start <= 1582 && _end > 1582 {
                        _buf[(1582 - _start) as usize] = _value[2];
                    }
                    if _start <= 1583 && _end > 1583 {
                        _buf[(1583 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1588 && _end > 1584 {
                    let _value = self.read_radio_dapn(4)?.to_ne_bytes();
                    if _start <= 1584 && _end > 1584 {
                        _buf[(1584 - _start) as usize] = _value[0];
                    }
                    if _start <= 1585 && _end > 1585 {
                        _buf[(1585 - _start) as usize] = _value[1];
                    }
                    if _start <= 1586 && _end > 1586 {
                        _buf[(1586 - _start) as usize] = _value[2];
                    }
                    if _start <= 1587 && _end > 1587 {
                        _buf[(1587 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1592 && _end > 1588 {
                    let _value = self.read_radio_dapn(5)?.to_ne_bytes();
                    if _start <= 1588 && _end > 1588 {
                        _buf[(1588 - _start) as usize] = _value[0];
                    }
                    if _start <= 1589 && _end > 1589 {
                        _buf[(1589 - _start) as usize] = _value[1];
                    }
                    if _start <= 1590 && _end > 1590 {
                        _buf[(1590 - _start) as usize] = _value[2];
                    }
                    if _start <= 1591 && _end > 1591 {
                        _buf[(1591 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1596 && _end > 1592 {
                    let _value = self.read_radio_dapn(6)?.to_ne_bytes();
                    if _start <= 1592 && _end > 1592 {
                        _buf[(1592 - _start) as usize] = _value[0];
                    }
                    if _start <= 1593 && _end > 1593 {
                        _buf[(1593 - _start) as usize] = _value[1];
                    }
                    if _start <= 1594 && _end > 1594 {
                        _buf[(1594 - _start) as usize] = _value[2];
                    }
                    if _start <= 1595 && _end > 1595 {
                        _buf[(1595 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1600 && _end > 1596 {
                    let _value = self.read_radio_dapn(7)?.to_ne_bytes();
                    if _start <= 1596 && _end > 1596 {
                        _buf[(1596 - _start) as usize] = _value[0];
                    }
                    if _start <= 1597 && _end > 1597 {
                        _buf[(1597 - _start) as usize] = _value[1];
                    }
                    if _start <= 1598 && _end > 1598 {
                        _buf[(1598 - _start) as usize] = _value[2];
                    }
                    if _start <= 1599 && _end > 1599 {
                        _buf[(1599 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1604 && _end > 1600 {
                    let _value = self.read_radio_dacnf()?.to_ne_bytes();
                    if _start <= 1600 && _end > 1600 {
                        _buf[(1600 - _start) as usize] = _value[0];
                    }
                    if _start <= 1601 && _end > 1601 {
                        _buf[(1601 - _start) as usize] = _value[1];
                    }
                    if _start <= 1602 && _end > 1602 {
                        _buf[(1602 - _start) as usize] = _value[2];
                    }
                    if _start <= 1603 && _end > 1603 {
                        _buf[(1603 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1616..=1619, 1617..=1620) => {
                if _start < 1620 && _end > 1616 {
                    let _value = self.read_radio_modecnf0()?.to_ne_bytes();
                    if _start <= 1616 && _end > 1616 {
                        _buf[(1616 - _start) as usize] = _value[0];
                    }
                    if _start <= 1617 && _end > 1617 {
                        _buf[(1617 - _start) as usize] = _value[1];
                    }
                    if _start <= 1618 && _end > 1618 {
                        _buf[(1618 - _start) as usize] = _value[2];
                    }
                    if _start <= 1619 && _end > 1619 {
                        _buf[(1619 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _value = self.read_radio_power()?.to_ne_bytes();
                    if _start <= 4092 && _end > 4092 {
                        _buf[(4092 - _start) as usize] = _value[0];
                    }
                    if _start <= 4093 && _end > 4093 {
                        _buf[(4093 - _start) as usize] = _value[1];
                    }
                    if _start <= 4094 && _end > 4094 {
                        _buf[(4094 - _start) as usize] = _value[2];
                    }
                    if _start <= 4095 && _end > 4095 {
                        _buf[(4095 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073745920;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=35, 1..=36) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for RADIO TASKS_TXEN not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_txen(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for RADIO TASKS_RXEN not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_rxen(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for RADIO TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12 && _end >= 16u64,
                        "partial write for RADIO TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16 && _end >= 20u64,
                        "partial write for RADIO TASKS_DISABLE not implemented",
                    );
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_disable(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert ! (_start <= 20 && _end >= 24u64 , "partial write for RADIO TASKS_RSSISTART not implemented" ,);
                    let start = _start.saturating_sub(20) as usize;
                    let end = (_end.saturating_sub(20) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_rssistart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 28 && _end > 24 {
                    assert ! (_start <= 24 && _end >= 28u64 , "partial write for RADIO TASKS_RSSISTOP not implemented" ,);
                    let start = _start.saturating_sub(24) as usize;
                    let end = (_end.saturating_sub(24) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_rssistop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28 && _end >= 32u64,
                        "partial write for RADIO TASKS_BCSTART not implemented",
                    );
                    let start = _start.saturating_sub(28) as usize;
                    let end = (_end.saturating_sub(28) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_bcstart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 36 && _end > 32 {
                    assert!(
                        _start <= 32 && _end >= 36u64,
                        "partial write for RADIO TASKS_BCSTOP not implemented",
                    );
                    let start = _start.saturating_sub(32) as usize;
                    let end = (_end.saturating_sub(32) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_tasks_bcstop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for RADIO EVENTS_READY not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_ready(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260 && _end >= 264u64 , "partial write for RADIO EVENTS_ADDRESS not implemented" ,);
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_address(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264 && _end >= 268u64 , "partial write for RADIO EVENTS_PAYLOAD not implemented" ,);
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_payload(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268 && _end >= 272u64,
                        "partial write for RADIO EVENTS_END not implemented",
                    );
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_end(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert ! (_start <= 272 && _end >= 276u64 , "partial write for RADIO EVENTS_DISABLED not implemented" ,);
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_disabled(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert ! (_start <= 276 && _end >= 280u64 , "partial write for RADIO EVENTS_DEVMATCH not implemented" ,);
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_devmatch(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert ! (_start <= 280 && _end >= 284u64 , "partial write for RADIO EVENTS_DEVMISS not implemented" ,);
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_devmiss(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert ! (_start <= 284 && _end >= 288u64 , "partial write for RADIO EVENTS_RSSIEND not implemented" ,);
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_rssiend(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    assert ! (_start <= 296 && _end >= 300u64 , "partial write for RADIO EVENTS_BCMATCH not implemented" ,);
                    let start = _start.saturating_sub(296) as usize;
                    let end =
                        (_end.saturating_sub(296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_bcmatch(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (304..=311, 305..=312) => {
                if _start < 308 && _end > 304 {
                    assert!(
                        _start <= 304 && _end >= 308u64,
                        "partial write for RADIO EVENTS_CRCOK not implemented",
                    );
                    let start = _start.saturating_sub(304) as usize;
                    let end =
                        (_end.saturating_sub(304) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_crcok(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 312 && _end > 308 {
                    assert ! (_start <= 308 && _end >= 312u64 , "partial write for RADIO EVENTS_CRCERROR not implemented" ,);
                    let start = _start.saturating_sub(308) as usize;
                    let end =
                        (_end.saturating_sub(308) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_events_crcerror(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_radio_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_radio_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_radio_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1032..=1043, 1033..=1044) => {
                if _start < 1036 && _end > 1032 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1040 && _end > 1036 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1044 && _end > 1040 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1284..=1355, 1285..=1356) => {
                if _start < 1288 && _end > 1284 {
                    assert!(
                        _start <= 1284 && _end >= 1288u64,
                        "partial write for RADIO PACKETPTR not implemented",
                    );
                    let start = _start.saturating_sub(1284) as usize;
                    let end =
                        (_end.saturating_sub(1284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_packetptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_radio_frequency(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_radio_txpower(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_radio_mode(offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_radio_pcnf0(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_radio_pcnf1(offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    assert!(
                        _start <= 1308 && _end >= 1312u64,
                        "partial write for RADIO BASE0 not implemented",
                    );
                    let start = _start.saturating_sub(1308) as usize;
                    let end =
                        (_end.saturating_sub(1308) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_base0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1316 && _end > 1312 {
                    assert!(
                        _start <= 1312 && _end >= 1316u64,
                        "partial write for RADIO BASE1 not implemented",
                    );
                    let start = _start.saturating_sub(1312) as usize;
                    let end =
                        (_end.saturating_sub(1312) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_base1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_radio_prefix0(offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = _start.saturating_sub(1320);
                    let start = 1320u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1320) - offset) as usize;
                    self.write_radio_prefix1(offset, &_buf[start..end])?;
                }
                if _start < 1328 && _end > 1324 {
                    let offset = _start.saturating_sub(1324);
                    let start = 1324u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1324) - offset) as usize;
                    self.write_radio_txaddress(offset, &_buf[start..end])?;
                }
                if _start < 1332 && _end > 1328 {
                    let offset = _start.saturating_sub(1328);
                    let start = 1328u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1328) - offset) as usize;
                    self.write_radio_rxaddresses(offset, &_buf[start..end])?;
                }
                if _start < 1336 && _end > 1332 {
                    let offset = _start.saturating_sub(1332);
                    let start = 1332u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1332) - offset) as usize;
                    self.write_radio_crccnf(offset, &_buf[start..end])?;
                }
                if _start < 1340 && _end > 1336 {
                    let offset = _start.saturating_sub(1336);
                    let start = 1336u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1336) - offset) as usize;
                    self.write_radio_crcpoly(offset, &_buf[start..end])?;
                }
                if _start < 1344 && _end > 1340 {
                    let offset = _start.saturating_sub(1340);
                    let start = 1340u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1340) - offset) as usize;
                    self.write_radio_crcinit(offset, &_buf[start..end])?;
                }
                if _start < 1348 && _end > 1344 {
                    assert!(
                        _start <= 1344 && _end >= 1348u64,
                        "partial write for RADIO UNUSED0 not implemented",
                    );
                    let start = _start.saturating_sub(1344) as usize;
                    let end =
                        (_end.saturating_sub(1344) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_unused0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1352 && _end > 1348 {
                    let offset = _start.saturating_sub(1348);
                    let start = 1348u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1348) - offset) as usize;
                    self.write_radio_tifs(offset, &_buf[start..end])?;
                }
                if _start < 1356 && _end > 1352 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1360..=1367, 1361..=1368) => {
                if _start < 1364 && _end > 1360 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1368 && _end > 1364 {
                    let offset = _start.saturating_sub(1364);
                    let start = 1364u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1364) - offset) as usize;
                    self.write_radio_datawhiteiv(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1376..=1379, 1377..=1380) => {
                if _start < 1380 && _end > 1376 {
                    assert!(
                        _start <= 1376 && _end >= 1380u64,
                        "partial write for RADIO BCC not implemented",
                    );
                    let start = _start.saturating_sub(1376) as usize;
                    let end =
                        (_end.saturating_sub(1376) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_bcc(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1536..=1603, 1537..=1604) => {
                if _start < 1540 && _end > 1536 {
                    assert!(
                        _start <= 1536 && _end >= 1540u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1536) as usize;
                    let end =
                        (_end.saturating_sub(1536) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1544 && _end > 1540 {
                    assert!(
                        _start <= 1540 && _end >= 1544u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1540) as usize;
                    let end =
                        (_end.saturating_sub(1540) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1548 && _end > 1544 {
                    assert!(
                        _start <= 1544 && _end >= 1548u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1544) as usize;
                    let end =
                        (_end.saturating_sub(1544) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1552 && _end > 1548 {
                    assert!(
                        _start <= 1548 && _end >= 1552u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1548) as usize;
                    let end =
                        (_end.saturating_sub(1548) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1556 && _end > 1552 {
                    assert!(
                        _start <= 1552 && _end >= 1556u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1552) as usize;
                    let end =
                        (_end.saturating_sub(1552) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1560 && _end > 1556 {
                    assert!(
                        _start <= 1556 && _end >= 1560u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1556) as usize;
                    let end =
                        (_end.saturating_sub(1556) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1564 && _end > 1560 {
                    assert!(
                        _start <= 1560 && _end >= 1564u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1560) as usize;
                    let end =
                        (_end.saturating_sub(1560) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1568 && _end > 1564 {
                    assert!(
                        _start <= 1564 && _end >= 1568u64,
                        "partial write for RADIO DAB[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1564) as usize;
                    let end =
                        (_end.saturating_sub(1564) as usize).min(start + 4);
                    self.0.lock().unwrap().write_radio_dabn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1572 && _end > 1568 {
                    let offset = _start.saturating_sub(1568);
                    let start = 1568u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1568) - offset) as usize;
                    self.write_radio_dapn(0, offset, &_buf[start..end])?;
                }
                if _start < 1576 && _end > 1572 {
                    let offset = _start.saturating_sub(1572);
                    let start = 1572u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1572) - offset) as usize;
                    self.write_radio_dapn(1, offset, &_buf[start..end])?;
                }
                if _start < 1580 && _end > 1576 {
                    let offset = _start.saturating_sub(1576);
                    let start = 1576u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1576) - offset) as usize;
                    self.write_radio_dapn(2, offset, &_buf[start..end])?;
                }
                if _start < 1584 && _end > 1580 {
                    let offset = _start.saturating_sub(1580);
                    let start = 1580u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1580) - offset) as usize;
                    self.write_radio_dapn(3, offset, &_buf[start..end])?;
                }
                if _start < 1588 && _end > 1584 {
                    let offset = _start.saturating_sub(1584);
                    let start = 1584u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1584) - offset) as usize;
                    self.write_radio_dapn(4, offset, &_buf[start..end])?;
                }
                if _start < 1592 && _end > 1588 {
                    let offset = _start.saturating_sub(1588);
                    let start = 1588u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1588) - offset) as usize;
                    self.write_radio_dapn(5, offset, &_buf[start..end])?;
                }
                if _start < 1596 && _end > 1592 {
                    let offset = _start.saturating_sub(1592);
                    let start = 1592u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1592) - offset) as usize;
                    self.write_radio_dapn(6, offset, &_buf[start..end])?;
                }
                if _start < 1600 && _end > 1596 {
                    let offset = _start.saturating_sub(1596);
                    let start = 1596u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1596) - offset) as usize;
                    self.write_radio_dapn(7, offset, &_buf[start..end])?;
                }
                if _start < 1604 && _end > 1600 {
                    let offset = _start.saturating_sub(1600);
                    let start = 1600u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1600) - offset) as usize;
                    self.write_radio_dacnf(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1616..=1619, 1617..=1620) => {
                if _start < 1620 && _end > 1616 {
                    let offset = _start.saturating_sub(1616);
                    let start = 1616u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1616) - offset) as usize;
                    self.write_radio_modecnf0(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let offset = _start.saturating_sub(4092);
                    let start = 4092u64.saturating_sub(_start) as usize;
                    let end = ((_end - 4092) - offset) as usize;
                    self.write_radio_power(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40001000 {
    fn read_radio_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_shorts_ready_start()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_shorts_end_disable()?)
                << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_radio_shorts_disabled_txen()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_radio_shorts_disabled_rxen()?,
        ) << 3u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_radio_shorts_address_rssistart()?,
        ) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_shorts_end_start()?)
                << 5u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_radio_shorts_address_bcstart()?,
        ) << 6u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_radio_shorts_disabled_rssistop()?,
        ) << 8u32;
        Ok(_value)
    }
    fn write_radio_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_ready_start((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_end_disable((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_disabled_txen((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_disabled_rxen((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_address_rssistart(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_end_start((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_radio_shorts_address_bcstart(
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_shorts_disabled_rssistop(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_radio_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_ready()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_address()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_payload()?)
                << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_intenset_end()?)
            << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_disabled()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_devmatch()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_devmiss()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_rssiend()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_bcmatch()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_crcok()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenset_crcerror()?)
                << 13u32;
        Ok(_value)
    }
    fn write_radio_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_address((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_payload((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_end((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_disabled((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_devmatch((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_devmiss((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_rssiend((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_bcmatch((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_crcok((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenset_crcerror((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_ready()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_address()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_payload()?)
                << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_intenclr_end()?)
            << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_disabled()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_devmatch()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_devmiss()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_rssiend()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_bcmatch()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_crcok()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_intenclr_crcerror()?)
                << 13u32;
        Ok(_value)
    }
    fn write_radio_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_address((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_payload((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_end((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_disabled((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_devmatch((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_devmiss((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_rssiend((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_bcmatch((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_crcok((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_intenclr_crcerror((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_crcstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crcstatus_crcstatus()?)
                << 0u32;
        Ok(_value)
    }
    fn read_radio_rxmatch(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxmatch_rxmatch()?)
                << 0u32;
        Ok(_value)
    }
    fn read_radio_rxcrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxcrc_rxcrc()?) << 0u32;
        Ok(_value)
    }
    fn read_radio_dai(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dai_dai()?) << 0u32;
        Ok(_value)
    }
    fn read_radio_frequency(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_frequency_frequency()?)
                << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_frequency_map()?)
            << 8u32;
        Ok(_value)
    }
    fn write_radio_frequency(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_frequency_frequency((_value[_i] >> 0) & 127u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_frequency_map((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_txpower(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_txpower_txpower()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_txpower(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_txpower_txpower((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_radio_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_mode_mode()?) << 0u32;
        Ok(_value)
    }
    fn write_radio_mode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_mode_mode((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
    fn read_radio_pcnf0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_pcnf0_lflen()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_pcnf0_s0len()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf0_s1len()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf0_s1incl()?)
            << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_pcnf0_plen()?) << 24u32;
        Ok(_value)
    }
    fn write_radio_pcnf0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf0_lflen((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf0_s0len((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf0_s1len((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf0_s1incl((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf0_plen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_pcnf1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_maxlen()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_statlen()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_balen()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_endian()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_pcnf1_whiteen()?)
            << 25u32;
        Ok(_value)
    }
    fn write_radio_pcnf1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_maxlen((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_statlen((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_balen((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_endian((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_pcnf1_whiteen((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_prefix0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_prefix0_ap0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_prefix0_ap1()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_prefix0_ap2()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_prefix0_ap3()?)
            << 24u32;
        Ok(_value)
    }
    fn write_radio_prefix0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix0_ap0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix0_ap1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix0_ap2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix0_ap3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_radio_prefix1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_prefix1_ap4()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_prefix1_ap5()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_prefix1_ap6()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_prefix1_ap7()?)
            << 24u32;
        Ok(_value)
    }
    fn write_radio_prefix1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix1_ap4((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix1_ap5((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix1_ap6((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_prefix1_ap7((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_radio_txaddress(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_txaddress_txaddress()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_txaddress(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_txaddress_txaddress((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_radio_rxaddresses(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr3()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr4()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr5()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr6()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_rxaddresses_addr7()?)
                << 7u32;
        Ok(_value)
    }
    fn write_radio_rxaddresses(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_rxaddresses_addr7((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_crccnf(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crccnf_len()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crccnf_skipaddr()?)
                << 8u32;
        Ok(_value)
    }
    fn write_radio_crccnf(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_crccnf_len((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_crccnf_skipaddr((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_crcpoly(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crcpoly_crcpoly()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_crcpoly(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_radio_crcpoly_crcpoly(_value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_radio_crcinit(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_crcinit_crcinit()?)
                << 0u32;
        Ok(_value)
    }
    fn write_radio_crcinit(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_radio_crcinit_crcinit(_value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_radio_tifs(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_tifs_tifs()?) << 0u32;
        Ok(_value)
    }
    fn write_radio_tifs(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_tifs_tifs((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_radio_rssisample(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_radio_rssisample_rssisample()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_radio_state(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_state_state()?) << 0u32;
        Ok(_value)
    }
    fn read_radio_datawhiteiv(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_radio_datawhiteiv_datawhiteiv()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_radio_datawhiteiv(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_radio_datawhiteiv_datawhiteiv(
                (_value[_i] >> 0) & 127u8,
            )?;
        }
        Ok(())
    }
    fn read_radio_dapn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dapn_dap(_dim)?)
            << 0u32;
        Ok(_value)
    }
    fn write_radio_dapn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_radio_dapn_dap(_dim, _value)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_radio_dacnf(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_dacnf_ena7()?) << 7u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd0()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd1()?)
            << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd2()?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd3()?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd4()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd5()?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd6()?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_dacnf_txadd7()?)
            << 15u32;
        Ok(_value)
    }
    fn write_radio_dacnf(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_ena7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_dacnf_txadd7((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_radio_modecnf0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_modecnf0_ru()?) << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_radio_modecnf0_dtx()?)
            << 8u32;
        Ok(_value)
    }
    fn write_radio_modecnf0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_modecnf0_ru((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_modecnf0_dtx((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_radio_power(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_radio_power_power()?) << 0u32;
        Ok(_value)
    }
    fn write_radio_power(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_radio_power_power((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40002000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40002000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073750016;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (28..=31, 29..=32) => {
                if _start < 32 && _end > 28 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (44..=47, 45..=48) => {
                if _start < 48 && _end > 44 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0uart0_events_cts()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0uart0_events_ncts()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0uart0_events_rxdrdy()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0_events_endrx()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (284..=295, 285..=296) => {
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0uart0_events_txdrdy()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 292 && _end > 288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0_events_endtx()?
                        .to_ne_bytes();
                    if _start <= 288 && _end > 288 {
                        _buf[(288 - _start) as usize] = _value[0];
                    }
                    if _start <= 289 && _end > 289 {
                        _buf[(289 - _start) as usize] = _value[1];
                    }
                    if _start <= 290 && _end > 290 {
                        _buf[(290 - _start) as usize] = _value[2];
                    }
                    if _start <= 291 && _end > 291 {
                        _buf[(291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 296 && _end > 292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0uart0_events_error()?
                        .to_ne_bytes();
                    if _start <= 292 && _end > 292 {
                        _buf[(292 - _start) as usize] = _value[0];
                    }
                    if _start <= 293 && _end > 293 {
                        _buf[(293 - _start) as usize] = _value[1];
                    }
                    if _start <= 294 && _end > 294 {
                        _buf[(294 - _start) as usize] = _value[2];
                    }
                    if _start <= 295 && _end > 295 {
                        _buf[(295 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (324..=327, 325..=328) => {
                if _start < 328 && _end > 324 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0uart0_events_rxto()?
                        .to_ne_bytes();
                    if _start <= 324 && _end > 324 {
                        _buf[(324 - _start) as usize] = _value[0];
                    }
                    if _start <= 325 && _end > 325 {
                        _buf[(325 - _start) as usize] = _value[1];
                    }
                    if _start <= 326 && _end > 326 {
                        _buf[(326 - _start) as usize] = _value[2];
                    }
                    if _start <= 327 && _end > 327 {
                        _buf[(327 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (332..=339, 333..=340) => {
                if _start < 336 && _end > 332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0_events_rxstarted()?
                        .to_ne_bytes();
                    if _start <= 332 && _end > 332 {
                        _buf[(332 - _start) as usize] = _value[0];
                    }
                    if _start <= 333 && _end > 333 {
                        _buf[(333 - _start) as usize] = _value[1];
                    }
                    if _start <= 334 && _end > 334 {
                        _buf[(334 - _start) as usize] = _value[2];
                    }
                    if _start <= 335 && _end > 335 {
                        _buf[(335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0_events_txstarted()?
                        .to_ne_bytes();
                    if _start <= 336 && _end > 336 {
                        _buf[(336 - _start) as usize] = _value[0];
                    }
                    if _start <= 337 && _end > 337 {
                        _buf[(337 - _start) as usize] = _value[1];
                    }
                    if _start <= 338 && _end > 338 {
                        _buf[(338 - _start) as usize] = _value[2];
                    }
                    if _start <= 339 && _end > 339 {
                        _buf[(339 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (344..=347, 345..=348) => {
                if _start < 348 && _end > 344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0_events_txstopped()?
                        .to_ne_bytes();
                    if _start <= 344 && _end > 344 {
                        _buf[(344 - _start) as usize] = _value[0];
                    }
                    if _start <= 345 && _end > 345 {
                        _buf[(345 - _start) as usize] = _value[1];
                    }
                    if _start <= 346 && _end > 346 {
                        _buf[(346 - _start) as usize] = _value[2];
                    }
                    if _start <= 347 && _end > 347 {
                        _buf[(347 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_uarte0uart0_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_uarte0_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value =
                        self.read_uarte0uart0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value =
                        self.read_uarte0uart0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1152..=1155, 1153..=1156) => {
                if _start < 1156 && _end > 1152 {
                    let _value =
                        self.read_uarte0uart0_errorsrc()?.to_ne_bytes();
                    if _start <= 1152 && _end > 1152 {
                        _buf[(1152 - _start) as usize] = _value[0];
                    }
                    if _start <= 1153 && _end > 1153 {
                        _buf[(1153 - _start) as usize] = _value[1];
                    }
                    if _start <= 1154 && _end > 1154 {
                        _buf[(1154 - _start) as usize] = _value[2];
                    }
                    if _start <= 1155 && _end > 1155 {
                        _buf[(1155 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_uarte0uart0_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1292 && _end > 1288 {
                    let _value =
                        self.read_uarte0uart0_psel_rts()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value =
                        self.read_uarte0uart0_psel_txd()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value =
                        self.read_uarte0uart0_psel_cts()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value =
                        self.read_uarte0uart0_psel_rxd()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_uart0_rxd()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0uart0_baudrate()?
                        .to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1332..=1343, 1333..=1344) => {
                if _start < 1336 && _end > 1332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0_rxd_ptr()?
                        .to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _value = self.read_uarte0_rxd_maxcnt()?.to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _value = self.read_uarte0_rxd_amount()?.to_ne_bytes();
                    if _start <= 1340 && _end > 1340 {
                        _buf[(1340 - _start) as usize] = _value[0];
                    }
                    if _start <= 1341 && _end > 1341 {
                        _buf[(1341 - _start) as usize] = _value[1];
                    }
                    if _start <= 1342 && _end > 1342 {
                        _buf[(1342 - _start) as usize] = _value[2];
                    }
                    if _start <= 1343 && _end > 1343 {
                        _buf[(1343 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1348..=1359, 1349..=1360) => {
                if _start < 1352 && _end > 1348 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_uarte0_txd_ptr()?
                        .to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_uarte0_txd_maxcnt()?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self.read_uarte0_txd_amount()?.to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1388..=1391, 1389..=1392) => {
                if _start < 1392 && _end > 1388 {
                    let _value = self.read_uarte0uart0_config()?.to_ne_bytes();
                    if _start <= 1388 && _end > 1388 {
                        _buf[(1388 - _start) as usize] = _value[0];
                    }
                    if _start <= 1389 && _end > 1389 {
                        _buf[(1389 - _start) as usize] = _value[1];
                    }
                    if _start <= 1390 && _end > 1390 {
                        _buf[(1390 - _start) as usize] = _value[2];
                    }
                    if _start <= 1391 && _end > 1391 {
                        _buf[(1391 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073750016;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    assert ! (_start <= 0 && _end >= 4u64 , "partial write for UARTE0 TASKS_STARTRX not implemented" ,);
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_tasks_startrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for UARTE0 TASKS_STOPRX not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_tasks_stoprx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert ! (_start <= 8 && _end >= 12u64 , "partial write for UARTE0 TASKS_STARTTX not implemented" ,);
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_tasks_starttx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12 && _end >= 16u64,
                        "partial write for UARTE0 TASKS_STOPTX not implemented",
                    );
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_tasks_stoptx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (28..=31, 29..=32) => {
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28 && _end >= 32u64,
                        "partial write for UART0 TASKS_SUSPEND not implemented",
                    );
                    let start = _start.saturating_sub(28) as usize;
                    let end = (_end.saturating_sub(28) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uart0_tasks_suspend(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (44..=47, 45..=48) => {
                if _start < 48 && _end > 44 {
                    assert ! (_start <= 44 && _end >= 48u64 , "partial write for UARTE0 TASKS_FLUSHRX not implemented" ,);
                    let start = _start.saturating_sub(44) as usize;
                    let end = (_end.saturating_sub(44) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0_tasks_flushrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for UARTE0 EVENTS_CTS not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_events_cts(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for UARTE0 EVENTS_NCTS not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_events_ncts(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264 && _end >= 268u64 , "partial write for UARTE0 EVENTS_RXDRDY not implemented" ,);
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_events_rxdrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272 && _end >= 276u64,
                        "partial write for UARTE0 EVENTS_ENDRX not implemented",
                    );
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0_events_endrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (284..=295, 285..=296) => {
                if _start < 288 && _end > 284 {
                    assert ! (_start <= 284 && _end >= 288u64 , "partial write for UARTE0 EVENTS_TXDRDY not implemented" ,);
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_events_txdrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 292 && _end > 288 {
                    assert!(
                        _start <= 288 && _end >= 292u64,
                        "partial write for UARTE0 EVENTS_ENDTX not implemented",
                    );
                    let start = _start.saturating_sub(288) as usize;
                    let end =
                        (_end.saturating_sub(288) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0_events_endtx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 296 && _end > 292 {
                    assert!(
                        _start <= 292 && _end >= 296u64,
                        "partial write for UARTE0 EVENTS_ERROR not implemented",
                    );
                    let start = _start.saturating_sub(292) as usize;
                    let end =
                        (_end.saturating_sub(292) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_events_error(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (324..=327, 325..=328) => {
                if _start < 328 && _end > 324 {
                    assert!(
                        _start <= 324 && _end >= 328u64,
                        "partial write for UARTE0 EVENTS_RXTO not implemented",
                    );
                    let start = _start.saturating_sub(324) as usize;
                    let end =
                        (_end.saturating_sub(324) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_events_rxto(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (332..=339, 333..=340) => {
                if _start < 336 && _end > 332 {
                    assert ! (_start <= 332 && _end >= 336u64 , "partial write for UARTE0 EVENTS_RXSTARTED not implemented" ,);
                    let start = _start.saturating_sub(332) as usize;
                    let end =
                        (_end.saturating_sub(332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0_events_rxstarted(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 340 && _end > 336 {
                    assert ! (_start <= 336 && _end >= 340u64 , "partial write for UARTE0 EVENTS_TXSTARTED not implemented" ,);
                    let start = _start.saturating_sub(336) as usize;
                    let end =
                        (_end.saturating_sub(336) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0_events_txstarted(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (344..=347, 345..=348) => {
                if _start < 348 && _end > 344 {
                    assert ! (_start <= 344 && _end >= 348u64 , "partial write for UARTE0 EVENTS_TXSTOPPED not implemented" ,);
                    let start = _start.saturating_sub(344) as usize;
                    let end =
                        (_end.saturating_sub(344) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0_events_txstopped(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_uarte0uart0_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_uarte0_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_uarte0uart0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_uarte0uart0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1152..=1155, 1153..=1156) => {
                if _start < 1156 && _end > 1152 {
                    let offset = _start.saturating_sub(1152);
                    let start = 1152u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1152) - offset) as usize;
                    self.write_uarte0uart0_errorsrc(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_uarte0uart0_enable(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_uarte0uart0_psel_rts(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_uarte0uart0_psel_txd(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_uarte0uart0_psel_cts(offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_uarte0uart0_psel_rxd(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_uart0_txd(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    assert!(
                        _start <= 1316 && _end >= 1320u64,
                        "partial write for UARTE0 BAUDRATE not implemented",
                    );
                    let start = _start.saturating_sub(1316) as usize;
                    let end =
                        (_end.saturating_sub(1316) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0uart0_baudrate(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1332..=1343, 1333..=1344) => {
                if _start < 1336 && _end > 1332 {
                    assert!(
                        _start <= 1332 && _end >= 1336u64,
                        "partial write for UARTE0 PTR not implemented",
                    );
                    let start = _start.saturating_sub(1332) as usize;
                    let end =
                        (_end.saturating_sub(1332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0_rxd_ptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1340 && _end > 1336 {
                    let offset = _start.saturating_sub(1336);
                    let start = 1336u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1336) - offset) as usize;
                    self.write_uarte0_rxd_maxcnt(offset, &_buf[start..end])?;
                }
                if _start < 1344 && _end > 1340 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1348..=1359, 1349..=1360) => {
                if _start < 1352 && _end > 1348 {
                    assert!(
                        _start <= 1348 && _end >= 1352u64,
                        "partial write for UARTE0 PTR not implemented",
                    );
                    let start = _start.saturating_sub(1348) as usize;
                    let end =
                        (_end.saturating_sub(1348) as usize).min(start + 4);
                    self.0.lock().unwrap().write_uarte0_txd_ptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1356 && _end > 1352 {
                    let offset = _start.saturating_sub(1352);
                    let start = 1352u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1352) - offset) as usize;
                    self.write_uarte0_txd_maxcnt(offset, &_buf[start..end])?;
                }
                if _start < 1360 && _end > 1356 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1388..=1391, 1389..=1392) => {
                if _start < 1392 && _end > 1388 {
                    let offset = _start.saturating_sub(1388);
                    let start = 1388u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1388) - offset) as usize;
                    self.write_uarte0uart0_config(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40002000 {
    fn read_uarte0uart0_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_shorts_cts_startrx()?,
        ) << 3u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_shorts_ncts_stoprx()?,
        ) << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_shorts_endrx_startrx()?,
        ) << 5u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_shorts_endrx_stoprx()?,
        ) << 6u32;
        Ok(_value)
    }
    fn write_uarte0uart0_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_shorts_cts_startrx(
                    (_value[_i] >> 3) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_shorts_ncts_stoprx(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_shorts_endrx_startrx(
                    (_value[_i] >> 5) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_shorts_endrx_stoprx(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_uarte0_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_inten_cts()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_inten_ncts()?) << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_uarte0_inten_rxdrdy()?)
            << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_uarte0_inten_endrx()?)
            << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_uarte0_inten_txdrdy()?)
            << 7u32;
        _value |= u32::from(self.0.lock().unwrap().read_uarte0_inten_endtx()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_uarte0_inten_error()?)
            << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_uarte0_inten_rxto()?)
            << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_inten_rxstarted()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_inten_txstarted()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_inten_txstopped()?)
                << 22u32;
        Ok(_value)
    }
    fn write_uarte0_inten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_cts((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_ncts((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_rxdrdy((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_endrx((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_txdrdy((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_endtx((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_error((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_rxto((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_rxstarted((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_txstarted((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_inten_txstopped((_value[_i] >> 6) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_uarte0uart0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_intenset_cts()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_intenset_ncts()?)
                << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenset_rxdrdy()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenset_endrx()?,
        ) << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenset_txdrdy()?,
        ) << 7u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenset_endtx()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenset_error()?,
        ) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_intenset_rxto()?)
                << 17u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_intenset_rxstarted()?,
        ) << 19u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_intenset_txstarted()?,
        ) << 20u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_intenset_txstopped()?,
        ) << 22u32;
        Ok(_value)
    }
    fn write_uarte0uart0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_cts((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_ncts((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_intenset_rxdrdy(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_endrx((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_intenset_txdrdy(
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_endtx((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_error((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_rxto((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_rxstarted(
                    (_value[_i] >> 3) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_txstarted(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenset_txstopped(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_uarte0uart0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_intenclr_cts()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_intenclr_ncts()?)
                << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenclr_rxdrdy()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenclr_endrx()?,
        ) << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenclr_txdrdy()?,
        ) << 7u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenclr_endtx()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_intenclr_error()?,
        ) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_intenclr_rxto()?)
                << 17u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_intenclr_rxstarted()?,
        ) << 19u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_intenclr_txstarted()?,
        ) << 20u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_uarte0uart0_intenclr_txstopped()?,
        ) << 22u32;
        Ok(_value)
    }
    fn write_uarte0uart0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_cts((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_ncts((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_intenclr_rxdrdy(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_endrx((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_intenclr_txdrdy(
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_endtx((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_error((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_rxto((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_rxstarted(
                    (_value[_i] >> 3) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_txstarted(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_intenclr_txstopped(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_uarte0uart0_errorsrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_errorsrc_overrun()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_errorsrc_parity()?,
        ) << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_errorsrc_framing()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_errorsrc_break()?,
        ) << 3u32;
        Ok(_value)
    }
    fn write_uarte0uart0_errorsrc(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_errorsrc_overrun(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_errorsrc_parity(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_errorsrc_framing(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_errorsrc_break((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_uarte0uart0_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_enable_enable()?)
                << 0u32;
        Ok(_value)
    }
    fn write_uarte0uart0_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_enable_enable((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
    fn read_uarte0uart0_psel_rts(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_psel_rts_pin()?)
                << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_psel_rts_connect()?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_uarte0uart0_psel_rts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_psel_rts_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_psel_rts_connect(
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_uarte0uart0_psel_txd(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_psel_txd_pin()?)
                << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_psel_txd_connect()?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_uarte0uart0_psel_txd(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_psel_txd_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_psel_txd_connect(
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_uarte0uart0_psel_cts(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_psel_cts_pin()?)
                << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_psel_cts_connect()?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_uarte0uart0_psel_cts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_psel_cts_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_psel_cts_connect(
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_uarte0uart0_psel_rxd(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_psel_rxd_pin()?)
                << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_uarte0uart0_psel_rxd_connect()?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_uarte0uart0_psel_rxd(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_psel_rxd_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_uarte0uart0_psel_rxd_connect(
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_uart0_rxd(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uart0_rxd_rxd()?) << 0u32;
        Ok(_value)
    }
    fn write_uart0_txd(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uart0_txd_txd((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_uarte0_rxd_maxcnt(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_rxd_maxcnt_maxcnt()?)
                << 0u32;
        Ok(_value)
    }
    fn write_uarte0_rxd_maxcnt(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_rxd_maxcnt_maxcnt((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_uarte0_rxd_amount(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_rxd_amount_amount()?)
                << 0u32;
        Ok(_value)
    }
    fn read_uarte0_txd_maxcnt(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_txd_maxcnt_maxcnt()?)
                << 0u32;
        Ok(_value)
    }
    fn write_uarte0_txd_maxcnt(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0_txd_maxcnt_maxcnt((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_uarte0_txd_amount(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0_txd_amount_amount()?)
                << 0u32;
        Ok(_value)
    }
    fn read_uarte0uart0_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_config_hwfc()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_uarte0uart0_config_parity()?)
                << 1u32;
        Ok(_value)
    }
    fn write_uarte0uart0_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_config_hwfc((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_uarte0uart0_config_parity((_value[_i] >> 1) & 7u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40003000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40003000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073754112;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (8..=11, 9..=12) => {
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (16..=23, 17..=24) => {
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 24 && _end > 20 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (28..=43, 29..=44) => {
                if _start < 32 && _end > 28 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 36 && _end > 32 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 40 && _end > 36 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 44 && _end > 40 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (48..=55, 49..=56) => {
                if _start < 52 && _end > 48 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 56 && _end > 52 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spim0spis0twim0twis0twi0_events_stopped()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spi0twi0_events_ready()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spim0spis0_events_endrx()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (280..=299, 281..=300) => {
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spim0_events_end()?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twi0_events_txdsent()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 292 && _end > 288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spim0_events_endtx()?
                        .to_ne_bytes();
                    if _start <= 288 && _end > 288 {
                        _buf[(288 - _start) as usize] = _value[0];
                    }
                    if _start <= 289 && _end > 289 {
                        _buf[(289 - _start) as usize] = _value[1];
                    }
                    if _start <= 290 && _end > 290 {
                        _buf[(290 - _start) as usize] = _value[2];
                    }
                    if _start <= 291 && _end > 291 {
                        _buf[(291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 296 && _end > 292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twim0twis0twi0_events_error()?
                        .to_ne_bytes();
                    if _start <= 292 && _end > 292 {
                        _buf[(292 - _start) as usize] = _value[0];
                    }
                    if _start <= 293 && _end > 293 {
                        _buf[(293 - _start) as usize] = _value[1];
                    }
                    if _start <= 294 && _end > 294 {
                        _buf[(294 - _start) as usize] = _value[2];
                    }
                    if _start <= 295 && _end > 295 {
                        _buf[(295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 300 && _end > 296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spis0_events_acquired()?
                        .to_ne_bytes();
                    if _start <= 296 && _end > 296 {
                        _buf[(296 - _start) as usize] = _value[0];
                    }
                    if _start <= 297 && _end > 297 {
                        _buf[(297 - _start) as usize] = _value[1];
                    }
                    if _start <= 298 && _end > 298 {
                        _buf[(298 - _start) as usize] = _value[2];
                    }
                    if _start <= 299 && _end > 299 {
                        _buf[(299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twi0_events_bb()?
                        .to_ne_bytes();
                    if _start <= 312 && _end > 312 {
                        _buf[(312 - _start) as usize] = _value[0];
                    }
                    if _start <= 313 && _end > 313 {
                        _buf[(313 - _start) as usize] = _value[1];
                    }
                    if _start <= 314 && _end > 314 {
                        _buf[(314 - _start) as usize] = _value[2];
                    }
                    if _start <= 315 && _end > 315 {
                        _buf[(315 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (328..=339, 329..=340) => {
                if _start < 332 && _end > 328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twim0twi0_events_suspended()?
                        .to_ne_bytes();
                    if _start <= 328 && _end > 328 {
                        _buf[(328 - _start) as usize] = _value[0];
                    }
                    if _start <= 329 && _end > 329 {
                        _buf[(329 - _start) as usize] = _value[1];
                    }
                    if _start <= 330 && _end > 330 {
                        _buf[(330 - _start) as usize] = _value[2];
                    }
                    if _start <= 331 && _end > 331 {
                        _buf[(331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 336 && _end > 332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spim0twim0twis0_events_started()?
                        .to_ne_bytes();
                    if _start <= 332 && _end > 332 {
                        _buf[(332 - _start) as usize] = _value[0];
                    }
                    if _start <= 333 && _end > 333 {
                        _buf[(333 - _start) as usize] = _value[1];
                    }
                    if _start <= 334 && _end > 334 {
                        _buf[(334 - _start) as usize] = _value[2];
                    }
                    if _start <= 335 && _end > 335 {
                        _buf[(335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twim0twis0_events_txstarted()?
                        .to_ne_bytes();
                    if _start <= 336 && _end > 336 {
                        _buf[(336 - _start) as usize] = _value[0];
                    }
                    if _start <= 337 && _end > 337 {
                        _buf[(337 - _start) as usize] = _value[1];
                    }
                    if _start <= 338 && _end > 338 {
                        _buf[(338 - _start) as usize] = _value[2];
                    }
                    if _start <= 339 && _end > 339 {
                        _buf[(339 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (348..=363, 349..=364) => {
                if _start < 352 && _end > 348 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twim0_events_lastrx()?
                        .to_ne_bytes();
                    if _start <= 348 && _end > 348 {
                        _buf[(348 - _start) as usize] = _value[0];
                    }
                    if _start <= 349 && _end > 349 {
                        _buf[(349 - _start) as usize] = _value[1];
                    }
                    if _start <= 350 && _end > 350 {
                        _buf[(350 - _start) as usize] = _value[2];
                    }
                    if _start <= 351 && _end > 351 {
                        _buf[(351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 356 && _end > 352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twim0_events_lasttx()?
                        .to_ne_bytes();
                    if _start <= 352 && _end > 352 {
                        _buf[(352 - _start) as usize] = _value[0];
                    }
                    if _start <= 353 && _end > 353 {
                        _buf[(353 - _start) as usize] = _value[1];
                    }
                    if _start <= 354 && _end > 354 {
                        _buf[(354 - _start) as usize] = _value[2];
                    }
                    if _start <= 355 && _end > 355 {
                        _buf[(355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 360 && _end > 356 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twis0_events_write()?
                        .to_ne_bytes();
                    if _start <= 356 && _end > 356 {
                        _buf[(356 - _start) as usize] = _value[0];
                    }
                    if _start <= 357 && _end > 357 {
                        _buf[(357 - _start) as usize] = _value[1];
                    }
                    if _start <= 358 && _end > 358 {
                        _buf[(358 - _start) as usize] = _value[2];
                    }
                    if _start <= 359 && _end > 359 {
                        _buf[(359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 364 && _end > 360 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_twis0_events_read()?
                        .to_ne_bytes();
                    if _start <= 360 && _end > 360 {
                        _buf[(360 - _start) as usize] = _value[0];
                    }
                    if _start <= 361 && _end > 361 {
                        _buf[(361 - _start) as usize] = _value[1];
                    }
                    if _start <= 362 && _end > 362 {
                        _buf[(362 - _start) as usize] = _value[2];
                    }
                    if _start <= 363 && _end > 363 {
                        _buf[(363 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self
                        .read_spim0spis0twim0twis0twi0_shorts()?
                        .to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_twim0twis0_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self
                        .read_spim0spis0twim0twis0spi0twi0_intenset()?
                        .to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self
                        .read_spim0spis0twim0twis0spi0twi0_intenclr()?
                        .to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_spis0_semstat()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1088..=1091, 1089..=1092) => {
                if _start < 1092 && _end > 1088 {
                    let _value = self.read_spis0_status()?.to_ne_bytes();
                    if _start <= 1088 && _end > 1088 {
                        _buf[(1088 - _start) as usize] = _value[0];
                    }
                    if _start <= 1089 && _end > 1089 {
                        _buf[(1089 - _start) as usize] = _value[1];
                    }
                    if _start <= 1090 && _end > 1090 {
                        _buf[(1090 - _start) as usize] = _value[2];
                    }
                    if _start <= 1091 && _end > 1091 {
                        _buf[(1091 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1220..=1223, 1221..=1224) => {
                if _start < 1224 && _end > 1220 {
                    let _value = self.read_twim0twi0_errorsrc()?.to_ne_bytes();
                    if _start <= 1220 && _end > 1220 {
                        _buf[(1220 - _start) as usize] = _value[0];
                    }
                    if _start <= 1221 && _end > 1221 {
                        _buf[(1221 - _start) as usize] = _value[1];
                    }
                    if _start <= 1222 && _end > 1222 {
                        _buf[(1222 - _start) as usize] = _value[2];
                    }
                    if _start <= 1223 && _end > 1223 {
                        _buf[(1223 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1232..=1239, 1233..=1240) => {
                if _start < 1236 && _end > 1232 {
                    let _value = self.read_twis0_errorsrc()?.to_ne_bytes();
                    if _start <= 1232 && _end > 1232 {
                        _buf[(1232 - _start) as usize] = _value[0];
                    }
                    if _start <= 1233 && _end > 1233 {
                        _buf[(1233 - _start) as usize] = _value[1];
                    }
                    if _start <= 1234 && _end > 1234 {
                        _buf[(1234 - _start) as usize] = _value[2];
                    }
                    if _start <= 1235 && _end > 1235 {
                        _buf[(1235 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1240 && _end > 1236 {
                    let _value = self.read_twis0_match()?.to_ne_bytes();
                    if _start <= 1236 && _end > 1236 {
                        _buf[(1236 - _start) as usize] = _value[0];
                    }
                    if _start <= 1237 && _end > 1237 {
                        _buf[(1237 - _start) as usize] = _value[1];
                    }
                    if _start <= 1238 && _end > 1238 {
                        _buf[(1238 - _start) as usize] = _value[2];
                    }
                    if _start <= 1239 && _end > 1239 {
                        _buf[(1239 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self
                        .read_spim0spis0twim0twis0spi0twi0_enable()?
                        .to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1292 && _end > 1288 {
                    let _value = self
                        .read_spim0spis0twim0twis0spi0twi0_psel_sck()?
                        .to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self
                        .read_spim0spis0twim0twis0spi0twi0_psel_mosi()?
                        .to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value =
                        self.read_spim0spis0spi0_psel_miso()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_spis0_psel_csn()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_spi0twi0_rxd()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_spi0twi0_txd()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spim0twim0spi0twi0_frequency()?
                        .to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1332..=1367, 1333..=1368) => {
                if _start < 1336 && _end > 1332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spim0spis0twim0twis0_rxd_ptr()?
                        .to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _value = self
                        .read_spim0spis0twim0twis0_rxd_maxcnt()?
                        .to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _value = self
                        .read_spim0spis0twim0twis0_rxd_amount()?
                        .to_ne_bytes();
                    if _start <= 1340 && _end > 1340 {
                        _buf[(1340 - _start) as usize] = _value[0];
                    }
                    if _start <= 1341 && _end > 1341 {
                        _buf[(1341 - _start) as usize] = _value[1];
                    }
                    if _start <= 1342 && _end > 1342 {
                        _buf[(1342 - _start) as usize] = _value[2];
                    }
                    if _start <= 1343 && _end > 1343 {
                        _buf[(1343 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_spim0twim0_rxd_list()?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_spim0spis0twim0twis0_txd_ptr()?
                        .to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self
                        .read_spim0spis0twim0twis0_txd_maxcnt()?
                        .to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self
                        .read_spim0spis0twim0twis0_txd_amount()?
                        .to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value = self.read_spim0twim0_txd_list()?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _value =
                        self.read_spim0spis0spi0_config()?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _value = self.read_spis0_def()?.to_ne_bytes();
                    if _start <= 1372 && _end > 1372 {
                        _buf[(1372 - _start) as usize] = _value[0];
                    }
                    if _start <= 1373 && _end > 1373 {
                        _buf[(1373 - _start) as usize] = _value[1];
                    }
                    if _start <= 1374 && _end > 1374 {
                        _buf[(1374 - _start) as usize] = _value[2];
                    }
                    if _start <= 1375 && _end > 1375 {
                        _buf[(1375 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1416..=1423, 1417..=1424) => {
                if _start < 1420 && _end > 1416 {
                    let _value =
                        self.read_twim0twis0twi0_address(0)?.to_ne_bytes();
                    if _start <= 1416 && _end > 1416 {
                        _buf[(1416 - _start) as usize] = _value[0];
                    }
                    if _start <= 1417 && _end > 1417 {
                        _buf[(1417 - _start) as usize] = _value[1];
                    }
                    if _start <= 1418 && _end > 1418 {
                        _buf[(1418 - _start) as usize] = _value[2];
                    }
                    if _start <= 1419 && _end > 1419 {
                        _buf[(1419 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1424 && _end > 1420 {
                    let _value =
                        self.read_twim0twis0twi0_address(1)?.to_ne_bytes();
                    if _start <= 1420 && _end > 1420 {
                        _buf[(1420 - _start) as usize] = _value[0];
                    }
                    if _start <= 1421 && _end > 1421 {
                        _buf[(1421 - _start) as usize] = _value[1];
                    }
                    if _start <= 1422 && _end > 1422 {
                        _buf[(1422 - _start) as usize] = _value[2];
                    }
                    if _start <= 1423 && _end > 1423 {
                        _buf[(1423 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1428..=1431, 1429..=1432) => {
                if _start < 1432 && _end > 1428 {
                    let _value = self.read_twis0_config()?.to_ne_bytes();
                    if _start <= 1428 && _end > 1428 {
                        _buf[(1428 - _start) as usize] = _value[0];
                    }
                    if _start <= 1429 && _end > 1429 {
                        _buf[(1429 - _start) as usize] = _value[1];
                    }
                    if _start <= 1430 && _end > 1430 {
                        _buf[(1430 - _start) as usize] = _value[2];
                    }
                    if _start <= 1431 && _end > 1431 {
                        _buf[(1431 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1472..=1475, 1473..=1476) => {
                if _start < 1476 && _end > 1472 {
                    let _value = self.read_spim0spis0twis0_orc()?.to_ne_bytes();
                    if _start <= 1472 && _end > 1472 {
                        _buf[(1472 - _start) as usize] = _value[0];
                    }
                    if _start <= 1473 && _end > 1473 {
                        _buf[(1473 - _start) as usize] = _value[1];
                    }
                    if _start <= 1474 && _end > 1474 {
                        _buf[(1474 - _start) as usize] = _value[2];
                    }
                    if _start <= 1475 && _end > 1475 {
                        _buf[(1475 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073754112;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for TWIM0 TASKS_STARTRX not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twim0twi0_tasks_startrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (8..=11, 9..=12) => {
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for TWIM0 TASKS_STARTTX not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twim0twi0_tasks_starttx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (16..=23, 17..=24) => {
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16 && _end >= 20u64,
                        "partial write for SPIM0 TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spim0_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert!(
                        _start <= 20 && _end >= 24u64,
                        "partial write for SPIM0 TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(20) as usize;
                    let end = (_end.saturating_sub(20) as usize).min(start + 4);
                    self.0
                        .lock()
                        .unwrap()
                        .write_spim0twim0twis0twi0_tasks_stop(
                            u32::from_ne_bytes(
                                _buf[start..end].try_into().unwrap(),
                            ),
                        )?;
                }
                Ok(())
            }
            (28..=43, 29..=44) => {
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28 && _end >= 32u64,
                        "partial write for SPIM0 TASKS_SUSPEND not implemented",
                    );
                    let start = _start.saturating_sub(28) as usize;
                    let end = (_end.saturating_sub(28) as usize).min(start + 4);
                    self.0
                        .lock()
                        .unwrap()
                        .write_spim0twim0twis0twi0_tasks_suspend(
                            u32::from_ne_bytes(
                                _buf[start..end].try_into().unwrap(),
                            ),
                        )?;
                }
                if _start < 36 && _end > 32 {
                    assert!(
                        _start <= 32 && _end >= 36u64,
                        "partial write for SPIM0 TASKS_RESUME not implemented",
                    );
                    let start = _start.saturating_sub(32) as usize;
                    let end = (_end.saturating_sub(32) as usize).min(start + 4);
                    self.0
                        .lock()
                        .unwrap()
                        .write_spim0twim0twis0twi0_tasks_resume(
                            u32::from_ne_bytes(
                                _buf[start..end].try_into().unwrap(),
                            ),
                        )?;
                }
                if _start < 40 && _end > 36 {
                    assert!(
                        _start <= 36 && _end >= 40u64,
                        "partial write for SPIS0 TASKS_ACQUIRE not implemented",
                    );
                    let start = _start.saturating_sub(36) as usize;
                    let end = (_end.saturating_sub(36) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis0_tasks_acquire(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 44 && _end > 40 {
                    assert!(
                        _start <= 40 && _end >= 44u64,
                        "partial write for SPIS0 TASKS_RELEASE not implemented",
                    );
                    let start = _start.saturating_sub(40) as usize;
                    let end = (_end.saturating_sub(40) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis0_tasks_release(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (48..=55, 49..=56) => {
                if _start < 52 && _end > 48 {
                    assert ! (_start <= 48 && _end >= 52u64 , "partial write for TWIS0 TASKS_PREPARERX not implemented" ,);
                    let start = _start.saturating_sub(48) as usize;
                    let end = (_end.saturating_sub(48) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twis0_tasks_preparerx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 56 && _end > 52 {
                    assert ! (_start <= 52 && _end >= 56u64 , "partial write for TWIS0 TASKS_PREPARETX not implemented" ,);
                    let start = _start.saturating_sub(52) as usize;
                    let end = (_end.saturating_sub(52) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twis0_tasks_preparetx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260 && _end >= 264u64 , "partial write for SPIM0 EVENTS_STOPPED not implemented" ,);
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0
                        .lock()
                        .unwrap()
                        .write_spim0spis0twim0twis0twi0_events_stopped(
                            u32::from_ne_bytes(
                                _buf[start..end].try_into().unwrap(),
                            ),
                        )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for SPI0 EVENTS_READY not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spi0twi0_events_ready(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272 && _end >= 276u64,
                        "partial write for SPIM0 EVENTS_ENDRX not implemented",
                    );
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spim0spis0_events_endrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (280..=299, 281..=300) => {
                if _start < 284 && _end > 280 {
                    assert!(
                        _start <= 280 && _end >= 284u64,
                        "partial write for SPIM0 EVENTS_END not implemented",
                    );
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spim0_events_end(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284 && _end >= 288u64,
                        "partial write for TWI0 EVENTS_TXDSENT not implemented",
                    );
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_events_txdsent(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 292 && _end > 288 {
                    assert!(
                        _start <= 288 && _end >= 292u64,
                        "partial write for SPIM0 EVENTS_ENDTX not implemented",
                    );
                    let start = _start.saturating_sub(288) as usize;
                    let end =
                        (_end.saturating_sub(288) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spim0_events_endtx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 296 && _end > 292 {
                    assert!(
                        _start <= 292 && _end >= 296u64,
                        "partial write for TWIM0 EVENTS_ERROR not implemented",
                    );
                    let start = _start.saturating_sub(292) as usize;
                    let end =
                        (_end.saturating_sub(292) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twim0twis0twi0_events_error(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 300 && _end > 296 {
                    assert ! (_start <= 296 && _end >= 300u64 , "partial write for SPIS0 EVENTS_ACQUIRED not implemented" ,);
                    let start = _start.saturating_sub(296) as usize;
                    let end =
                        (_end.saturating_sub(296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spis0_events_acquired(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    assert!(
                        _start <= 312 && _end >= 316u64,
                        "partial write for TWI0 EVENTS_BB not implemented",
                    );
                    let start = _start.saturating_sub(312) as usize;
                    let end =
                        (_end.saturating_sub(312) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twi0_events_bb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (328..=339, 329..=340) => {
                if _start < 332 && _end > 328 {
                    assert ! (_start <= 328 && _end >= 332u64 , "partial write for TWIM0 EVENTS_SUSPENDED not implemented" ,);
                    let start = _start.saturating_sub(328) as usize;
                    let end =
                        (_end.saturating_sub(328) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twim0twi0_events_suspended(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 336 && _end > 332 {
                    assert ! (_start <= 332 && _end >= 336u64 , "partial write for SPIM0 EVENTS_STARTED not implemented" ,);
                    let start = _start.saturating_sub(332) as usize;
                    let end =
                        (_end.saturating_sub(332) as usize).min(start + 4);
                    self.0
                        .lock()
                        .unwrap()
                        .write_spim0twim0twis0_events_started(
                            u32::from_ne_bytes(
                                _buf[start..end].try_into().unwrap(),
                            ),
                        )?;
                }
                if _start < 340 && _end > 336 {
                    assert ! (_start <= 336 && _end >= 340u64 , "partial write for TWIM0 EVENTS_TXSTARTED not implemented" ,);
                    let start = _start.saturating_sub(336) as usize;
                    let end =
                        (_end.saturating_sub(336) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twim0twis0_events_txstarted(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (348..=363, 349..=364) => {
                if _start < 352 && _end > 348 {
                    assert!(
                        _start <= 348 && _end >= 352u64,
                        "partial write for TWIM0 EVENTS_LASTRX not implemented",
                    );
                    let start = _start.saturating_sub(348) as usize;
                    let end =
                        (_end.saturating_sub(348) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twim0_events_lastrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 356 && _end > 352 {
                    assert!(
                        _start <= 352 && _end >= 356u64,
                        "partial write for TWIM0 EVENTS_LASTTX not implemented",
                    );
                    let start = _start.saturating_sub(352) as usize;
                    let end =
                        (_end.saturating_sub(352) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twim0_events_lasttx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 360 && _end > 356 {
                    assert!(
                        _start <= 356 && _end >= 360u64,
                        "partial write for TWIS0 EVENTS_WRITE not implemented",
                    );
                    let start = _start.saturating_sub(356) as usize;
                    let end =
                        (_end.saturating_sub(356) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twis0_events_write(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 364 && _end > 360 {
                    assert!(
                        _start <= 360 && _end >= 364u64,
                        "partial write for TWIS0 EVENTS_READ not implemented",
                    );
                    let start = _start.saturating_sub(360) as usize;
                    let end =
                        (_end.saturating_sub(360) as usize).min(start + 4);
                    self.0.lock().unwrap().write_twis0_events_read(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_spim0spis0twim0twis0twi0_shorts(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_twim0twis0_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_spim0spis0twim0twis0spi0twi0_intenset(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_spim0spis0twim0twis0spi0twi0_intenclr(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1088..=1091, 1089..=1092) => {
                if _start < 1092 && _end > 1088 {
                    let offset = _start.saturating_sub(1088);
                    let start = 1088u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1088) - offset) as usize;
                    self.write_spis0_status(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1220..=1223, 1221..=1224) => {
                if _start < 1224 && _end > 1220 {
                    let offset = _start.saturating_sub(1220);
                    let start = 1220u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1220) - offset) as usize;
                    self.write_twim0twi0_errorsrc(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1232..=1239, 1233..=1240) => {
                if _start < 1236 && _end > 1232 {
                    let offset = _start.saturating_sub(1232);
                    let start = 1232u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1232) - offset) as usize;
                    self.write_twis0_errorsrc(offset, &_buf[start..end])?;
                }
                if _start < 1240 && _end > 1236 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_spim0spis0twim0twis0spi0twi0_enable(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_spim0spis0twim0twis0spi0twi0_psel_sck(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_spim0spis0twim0twis0spi0twi0_psel_mosi(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_spim0spis0spi0_psel_miso(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_spis0_psel_csn(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_spi0twi0_txd(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    assert!(
                        _start <= 1316 && _end >= 1320u64,
                        "partial write for SPIM0 FREQUENCY not implemented",
                    );
                    let start = _start.saturating_sub(1316) as usize;
                    let end =
                        (_end.saturating_sub(1316) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spim0twim0spi0twi0_frequency(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1332..=1367, 1333..=1368) => {
                if _start < 1336 && _end > 1332 {
                    assert!(
                        _start <= 1332 && _end >= 1336u64,
                        "partial write for SPIM0 PTR not implemented",
                    );
                    let start = _start.saturating_sub(1332) as usize;
                    let end =
                        (_end.saturating_sub(1332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spim0spis0twim0twis0_rxd_ptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1340 && _end > 1336 {
                    let offset = _start.saturating_sub(1336);
                    let start = 1336u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1336) - offset) as usize;
                    self.write_spim0spis0twim0twis0_rxd_maxcnt(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1344 && _end > 1340 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1348 && _end > 1344 {
                    let offset = _start.saturating_sub(1344);
                    let start = 1344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1344) - offset) as usize;
                    self.write_spim0twim0_rxd_list(offset, &_buf[start..end])?;
                }
                if _start < 1352 && _end > 1348 {
                    assert!(
                        _start <= 1348 && _end >= 1352u64,
                        "partial write for SPIM0 PTR not implemented",
                    );
                    let start = _start.saturating_sub(1348) as usize;
                    let end =
                        (_end.saturating_sub(1348) as usize).min(start + 4);
                    self.0.lock().unwrap().write_spim0spis0twim0twis0_txd_ptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1356 && _end > 1352 {
                    let offset = _start.saturating_sub(1352);
                    let start = 1352u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1352) - offset) as usize;
                    self.write_spim0spis0twim0twis0_txd_maxcnt(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1360 && _end > 1356 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1364 && _end > 1360 {
                    let offset = _start.saturating_sub(1360);
                    let start = 1360u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1360) - offset) as usize;
                    self.write_spim0twim0_txd_list(offset, &_buf[start..end])?;
                }
                if _start < 1368 && _end > 1364 {
                    let offset = _start.saturating_sub(1364);
                    let start = 1364u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1364) - offset) as usize;
                    self.write_spim0spis0spi0_config(
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let offset = _start.saturating_sub(1372);
                    let start = 1372u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1372) - offset) as usize;
                    self.write_spis0_def(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1416..=1423, 1417..=1424) => {
                if _start < 1420 && _end > 1416 {
                    let offset = _start.saturating_sub(1416);
                    let start = 1416u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1416) - offset) as usize;
                    self.write_twim0twis0twi0_address(
                        0,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1424 && _end > 1420 {
                    let offset = _start.saturating_sub(1420);
                    let start = 1420u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1420) - offset) as usize;
                    self.write_twim0twis0twi0_address(
                        1,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (1428..=1431, 1429..=1432) => {
                if _start < 1432 && _end > 1428 {
                    let offset = _start.saturating_sub(1428);
                    let start = 1428u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1428) - offset) as usize;
                    self.write_twis0_config(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1472..=1475, 1473..=1476) => {
                if _start < 1476 && _end > 1472 {
                    let offset = _start.saturating_sub(1472);
                    let start = 1472u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1472) - offset) as usize;
                    self.write_spim0spis0twis0_orc(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40003000 {
    fn read_spim0spis0twim0twis0twi0_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_bb_suspend()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_bb_stop()?,
        ) << 1u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_end_acquire()?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_lasttx_startrx()?,
        ) << 7u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_lasttx_suspend()?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_lasttx_stop()?,
        ) << 9u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_lastrx_starttx()?,
        ) << 10u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_lastrx_stop()?,
        ) << 12u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_write_suspend()?,
        ) << 13u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_read_suspend()?,
        ) << 14u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0twi0_shorts_end_start()?,
        ) << 17u32;
        Ok(_value)
    }
    fn write_spim0spis0twim0twis0twi0_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_bb_suspend(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_bb_stop(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_end_acquire(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_lasttx_startrx(
                    (_value[_i] >> 7) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_lasttx_suspend(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_lasttx_stop(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_lastrx_starttx(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_lastrx_stop(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_write_suspend(
                    (_value[_i] >> 5) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_read_suspend(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0twi0_shorts_end_start(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_twim0twis0_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_twim0twis0_inten_stopped()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twim0twis0_inten_error()?)
                << 9u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_twim0twis0_inten_suspended()?,
        ) << 18u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_twim0twis0_inten_rxstarted()?,
        ) << 19u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_twim0twis0_inten_txstarted()?,
        ) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twim0twis0_inten_lastrx()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twim0twis0_inten_lasttx()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twim0twis0_inten_write()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twim0twis0_inten_read()?)
                << 26u32;
        Ok(_value)
    }
    fn write_twim0twis0_inten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_error((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_suspended((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_rxstarted((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_txstarted((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_lastrx((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_lasttx((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_write((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0_inten_read((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spim0spis0twim0twis0spi0twi0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_stopped()?,
        ) << 1u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_ready()?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_endrx()?,
        ) << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_end()?,
        ) << 6u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_txdsent()?,
        ) << 7u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_endtx()?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_error()?,
        ) << 9u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_acquired()?,
        ) << 10u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_bb()?,
        ) << 14u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_suspended()?,
        ) << 18u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_started()?,
        ) << 19u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_txstarted()?,
        ) << 20u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_lastrx()?,
        ) << 23u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_lasttx()?,
        ) << 24u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_write()?,
        ) << 25u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenset_read()?,
        ) << 26u32;
        Ok(_value)
    }
    fn write_spim0spis0twim0twis0spi0twi0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_stopped(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_ready(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_endrx(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_end(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_txdsent(
                    (_value[_i] >> 7) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_endtx(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_error(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_acquired(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_bb(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_suspended(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_started(
                    (_value[_i] >> 3) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_txstarted(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_lastrx(
                    (_value[_i] >> 7) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_lasttx(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_write(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenset_read(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_spim0spis0twim0twis0spi0twi0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_stopped()?,
        ) << 1u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_ready()?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_endrx()?,
        ) << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_end()?,
        ) << 6u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_txdsent()?,
        ) << 7u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_endtx()?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_error()?,
        ) << 9u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_acquired()?,
        ) << 10u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_bb()?,
        ) << 14u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_suspended()?,
        ) << 18u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_started()?,
        ) << 19u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_txstarted()?,
        ) << 20u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_lastrx()?,
        ) << 23u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_lasttx()?,
        ) << 24u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_write()?,
        ) << 25u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_intenclr_read()?,
        ) << 26u32;
        Ok(_value)
    }
    fn write_spim0spis0twim0twis0spi0twi0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_stopped(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_ready(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_endrx(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_end(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_txdsent(
                    (_value[_i] >> 7) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_endtx(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_error(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_acquired(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_bb(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_suspended(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_started(
                    (_value[_i] >> 3) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_txstarted(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_lastrx(
                    (_value[_i] >> 7) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_lasttx(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_write(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_intenclr_read(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_spis0_semstat(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis0_semstat_semstat()?)
                << 0u32;
        Ok(_value)
    }
    fn read_spis0_status(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis0_status_overread()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis0_status_overflow()?)
                << 1u32;
        Ok(_value)
    }
    fn write_spis0_status(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis0_status_overread((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis0_status_overflow((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_twim0twi0_errorsrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_twim0twi0_errorsrc_overrun()?,
        ) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twim0twi0_errorsrc_anack()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twim0twi0_errorsrc_dnack()?)
                << 2u32;
        Ok(_value)
    }
    fn write_twim0twi0_errorsrc(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twi0_errorsrc_overrun((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twi0_errorsrc_anack((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twi0_errorsrc_dnack((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_twis0_errorsrc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_twis0_errorsrc_overflow()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twis0_errorsrc_dnack()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twis0_errorsrc_overread()?)
                << 3u32;
        Ok(_value)
    }
    fn write_twis0_errorsrc(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twis0_errorsrc_overflow((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twis0_errorsrc_dnack((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twis0_errorsrc_overread((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_twis0_match(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_twis0_match_match()?) << 0u32;
        Ok(_value)
    }
    fn read_spim0spis0twim0twis0spi0twi0_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_enable_enable()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_spim0spis0twim0twis0spi0twi0_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_enable_enable(
                    (_value[_i] >> 0) & 15u8,
                )?;
        }
        Ok(())
    }
    fn read_spim0spis0twim0twis0spi0twi0_psel_sck(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_psel_sck_pin()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_psel_sck_connect()?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_spim0spis0twim0twis0spi0twi0_psel_sck(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_psel_sck_pin(
                    (_value[_i] >> 0) & 31u8,
                )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_psel_sck_connect(
                    (_value[_i] >> 7) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_spim0spis0twim0twis0spi0twi0_psel_mosi(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_psel_mosi_pin()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0spi0twi0_psel_mosi_connect()?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_spim0spis0twim0twis0spi0twi0_psel_mosi(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_psel_mosi_pin(
                    (_value[_i] >> 0) & 31u8,
                )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0spi0twi0_psel_mosi_connect(
                    (_value[_i] >> 7) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_spim0spis0spi0_psel_miso(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |= u32::from(
            self.0.lock().unwrap().read_spim0spis0spi0_psel_miso_pin()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0spi0_psel_miso_connect()?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_spim0spis0spi0_psel_miso(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0spi0_psel_miso_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0spi0_psel_miso_connect(
                    (_value[_i] >> 7) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_spis0_psel_csn(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |= u32::from(self.0.lock().unwrap().read_spis0_psel_csn_pin()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis0_psel_csn_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_spis0_psel_csn(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis0_psel_csn_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis0_psel_csn_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spi0twi0_rxd(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_rxd_rxd()?) << 0u32;
        Ok(_value)
    }
    fn read_spi0twi0_txd(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spi0twi0_txd_txd()?) << 0u32;
        Ok(_value)
    }
    fn write_spi0twi0_txd(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spi0twi0_txd_txd((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_spim0spis0twim0twis0_rxd_maxcnt(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0_rxd_maxcnt_maxcnt()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_spim0spis0twim0twis0_rxd_maxcnt(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0_rxd_maxcnt_maxcnt(
                    (_value[_i] >> 0) & 255u8,
                )?;
        }
        Ok(())
    }
    fn read_spim0spis0twim0twis0_rxd_amount(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0_rxd_amount_amount()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_spim0twim0_rxd_list(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spim0twim0_rxd_list_list()?)
                << 0u32;
        Ok(_value)
    }
    fn write_spim0twim0_rxd_list(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0twim0_rxd_list_list((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_spim0spis0twim0twis0_txd_maxcnt(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0_txd_maxcnt_maxcnt()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_spim0spis0twim0twis0_txd_maxcnt(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twim0twis0_txd_maxcnt_maxcnt(
                    (_value[_i] >> 0) & 255u8,
                )?;
        }
        Ok(())
    }
    fn read_spim0spis0twim0twis0_txd_amount(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_spim0spis0twim0twis0_txd_amount_amount()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_spim0twim0_txd_list(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spim0twim0_txd_list_list()?)
                << 0u32;
        Ok(_value)
    }
    fn write_spim0twim0_txd_list(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0twim0_txd_list_list((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_spim0spis0spi0_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_spim0spis0spi0_config_order()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_spim0spis0spi0_config_cpha()?,
        ) << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_spim0spis0spi0_config_cpol()?,
        ) << 2u32;
        Ok(_value)
    }
    fn write_spim0spis0spi0_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_spim0spis0spi0_config_order(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0spi0_config_cpha((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0spi0_config_cpol((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spis0_def(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spis0_def_def()?) << 0u32;
        Ok(_value)
    }
    fn write_spis0_def(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spis0_def_def((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_twim0twis0twi0_address(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_twim0twis0twi0_address_address(_dim)?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_twim0twis0twi0_address(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twim0twis0twi0_address_address(
                    _dim,
                    (_value[_i] >> 0) & 127u8,
                )?;
        }
        Ok(())
    }
    fn read_twis0_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_twis0_config_address0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_twis0_config_address1()?)
                << 1u32;
        Ok(_value)
    }
    fn write_twis0_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twis0_config_address0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_twis0_config_address1((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_spim0spis0twis0_orc(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_spim0spis0twis0_orc_orc()?)
                << 0u32;
        Ok(_value)
    }
    fn write_spim0spis0twis0_orc(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_spim0spis0twis0_orc_orc((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40005000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40005000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073762304;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (28..=31, 29..=32) => {
                if _start < 32 && _end > 28 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (36..=43, 37..=44) => {
                if _start < 40 && _end > 36 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 44 && _end > 40 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_ready()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_fielddetected()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_fieldlost()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_txframestart()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_txframeend()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_rxframestart()?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_rxframeend()?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_error()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (296..=307, 297..=308) => {
                if _start < 300 && _end > 296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_rxerror()?
                        .to_ne_bytes();
                    if _start <= 296 && _end > 296 {
                        _buf[(296 - _start) as usize] = _value[0];
                    }
                    if _start <= 297 && _end > 297 {
                        _buf[(297 - _start) as usize] = _value[1];
                    }
                    if _start <= 298 && _end > 298 {
                        _buf[(298 - _start) as usize] = _value[2];
                    }
                    if _start <= 299 && _end > 299 {
                        _buf[(299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 304 && _end > 300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_endrx()?
                        .to_ne_bytes();
                    if _start <= 300 && _end > 300 {
                        _buf[(300 - _start) as usize] = _value[0];
                    }
                    if _start <= 301 && _end > 301 {
                        _buf[(301 - _start) as usize] = _value[1];
                    }
                    if _start <= 302 && _end > 302 {
                        _buf[(302 - _start) as usize] = _value[2];
                    }
                    if _start <= 303 && _end > 303 {
                        _buf[(303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 308 && _end > 304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_endtx()?
                        .to_ne_bytes();
                    if _start <= 304 && _end > 304 {
                        _buf[(304 - _start) as usize] = _value[0];
                    }
                    if _start <= 305 && _end > 305 {
                        _buf[(305 - _start) as usize] = _value[1];
                    }
                    if _start <= 306 && _end > 306 {
                        _buf[(306 - _start) as usize] = _value[2];
                    }
                    if _start <= 307 && _end > 307 {
                        _buf[(307 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_autocolresstarted()?
                        .to_ne_bytes();
                    if _start <= 312 && _end > 312 {
                        _buf[(312 - _start) as usize] = _value[0];
                    }
                    if _start <= 313 && _end > 313 {
                        _buf[(313 - _start) as usize] = _value[1];
                    }
                    if _start <= 314 && _end > 314 {
                        _buf[(314 - _start) as usize] = _value[2];
                    }
                    if _start <= 315 && _end > 315 {
                        _buf[(315 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (328..=339, 329..=340) => {
                if _start < 332 && _end > 328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_collision()?
                        .to_ne_bytes();
                    if _start <= 328 && _end > 328 {
                        _buf[(328 - _start) as usize] = _value[0];
                    }
                    if _start <= 329 && _end > 329 {
                        _buf[(329 - _start) as usize] = _value[1];
                    }
                    if _start <= 330 && _end > 330 {
                        _buf[(330 - _start) as usize] = _value[2];
                    }
                    if _start <= 331 && _end > 331 {
                        _buf[(331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 336 && _end > 332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_selected()?
                        .to_ne_bytes();
                    if _start <= 332 && _end > 332 {
                        _buf[(332 - _start) as usize] = _value[0];
                    }
                    if _start <= 333 && _end > 333 {
                        _buf[(333 - _start) as usize] = _value[1];
                    }
                    if _start <= 334 && _end > 334 {
                        _buf[(334 - _start) as usize] = _value[2];
                    }
                    if _start <= 335 && _end > 335 {
                        _buf[(335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_events_started()?
                        .to_ne_bytes();
                    if _start <= 336 && _end > 336 {
                        _buf[(336 - _start) as usize] = _value[0];
                    }
                    if _start <= 337 && _end > 337 {
                        _buf[(337 - _start) as usize] = _value[1];
                    }
                    if _start <= 338 && _end > 338 {
                        _buf[(338 - _start) as usize] = _value[2];
                    }
                    if _start <= 339 && _end > 339 {
                        _buf[(339 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_nfct_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_nfct_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self.read_nfct_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_nfct_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1028..=1031, 1029..=1032) => {
                if _start < 1032 && _end > 1028 {
                    let _value = self.read_nfct_errorstatus()?.to_ne_bytes();
                    if _start <= 1028 && _end > 1028 {
                        _buf[(1028 - _start) as usize] = _value[0];
                    }
                    if _start <= 1029 && _end > 1029 {
                        _buf[(1029 - _start) as usize] = _value[1];
                    }
                    if _start <= 1030 && _end > 1030 {
                        _buf[(1030 - _start) as usize] = _value[2];
                    }
                    if _start <= 1031 && _end > 1031 {
                        _buf[(1031 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1036..=1039, 1037..=1040) => {
                if _start < 1040 && _end > 1036 {
                    let _value = self.read_nfct_framestatus_rx()?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1072..=1075, 1073..=1076) => {
                if _start < 1076 && _end > 1072 {
                    let _value =
                        self.read_nfct_currentloadctrl()?.to_ne_bytes();
                    if _start <= 1072 && _end > 1072 {
                        _buf[(1072 - _start) as usize] = _value[0];
                    }
                    if _start <= 1073 && _end > 1073 {
                        _buf[(1073 - _start) as usize] = _value[1];
                    }
                    if _start <= 1074 && _end > 1074 {
                        _buf[(1074 - _start) as usize] = _value[2];
                    }
                    if _start <= 1075 && _end > 1075 {
                        _buf[(1075 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1084..=1087, 1085..=1088) => {
                if _start < 1088 && _end > 1084 {
                    let _value = self.read_nfct_fieldpresent()?.to_ne_bytes();
                    if _start <= 1084 && _end > 1084 {
                        _buf[(1084 - _start) as usize] = _value[0];
                    }
                    if _start <= 1085 && _end > 1085 {
                        _buf[(1085 - _start) as usize] = _value[1];
                    }
                    if _start <= 1086 && _end > 1086 {
                        _buf[(1086 - _start) as usize] = _value[2];
                    }
                    if _start <= 1087 && _end > 1087 {
                        _buf[(1087 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1319, 1285..=1320) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_nfct_framedelaymin()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_nfct_framedelaymax()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_nfct_framedelaymode()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nfct_packetptr()?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_nfct_maxlen()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value =
                        self.read_nfct_txd_frameconfig()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_nfct_txd_amount()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value =
                        self.read_nfct_rxd_frameconfig()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_nfct_rxd_amount()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1424..=1435, 1425..=1436) => {
                if _start < 1428 && _end > 1424 {
                    let _value = self.read_nfct_nfcid1_last()?.to_ne_bytes();
                    if _start <= 1424 && _end > 1424 {
                        _buf[(1424 - _start) as usize] = _value[0];
                    }
                    if _start <= 1425 && _end > 1425 {
                        _buf[(1425 - _start) as usize] = _value[1];
                    }
                    if _start <= 1426 && _end > 1426 {
                        _buf[(1426 - _start) as usize] = _value[2];
                    }
                    if _start <= 1427 && _end > 1427 {
                        _buf[(1427 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1432 && _end > 1428 {
                    let _value =
                        self.read_nfct_nfcid1_2nd_last()?.to_ne_bytes();
                    if _start <= 1428 && _end > 1428 {
                        _buf[(1428 - _start) as usize] = _value[0];
                    }
                    if _start <= 1429 && _end > 1429 {
                        _buf[(1429 - _start) as usize] = _value[1];
                    }
                    if _start <= 1430 && _end > 1430 {
                        _buf[(1430 - _start) as usize] = _value[2];
                    }
                    if _start <= 1431 && _end > 1431 {
                        _buf[(1431 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1436 && _end > 1432 {
                    let _value =
                        self.read_nfct_nfcid1_3rd_last()?.to_ne_bytes();
                    if _start <= 1432 && _end > 1432 {
                        _buf[(1432 - _start) as usize] = _value[0];
                    }
                    if _start <= 1433 && _end > 1433 {
                        _buf[(1433 - _start) as usize] = _value[1];
                    }
                    if _start <= 1434 && _end > 1434 {
                        _buf[(1434 - _start) as usize] = _value[2];
                    }
                    if _start <= 1435 && _end > 1435 {
                        _buf[(1435 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1440..=1447, 1441..=1448) => {
                if _start < 1444 && _end > 1440 {
                    let _value = self.read_nfct_sensres()?.to_ne_bytes();
                    if _start <= 1440 && _end > 1440 {
                        _buf[(1440 - _start) as usize] = _value[0];
                    }
                    if _start <= 1441 && _end > 1441 {
                        _buf[(1441 - _start) as usize] = _value[1];
                    }
                    if _start <= 1442 && _end > 1442 {
                        _buf[(1442 - _start) as usize] = _value[2];
                    }
                    if _start <= 1443 && _end > 1443 {
                        _buf[(1443 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1448 && _end > 1444 {
                    let _value = self.read_nfct_selres()?.to_ne_bytes();
                    if _start <= 1444 && _end > 1444 {
                        _buf[(1444 - _start) as usize] = _value[0];
                    }
                    if _start <= 1445 && _end > 1445 {
                        _buf[(1445 - _start) as usize] = _value[1];
                    }
                    if _start <= 1446 && _end > 1446 {
                        _buf[(1446 - _start) as usize] = _value[2];
                    }
                    if _start <= 1447 && _end > 1447 {
                        _buf[(1447 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073762304;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for NFCT TASKS_ACTIVATE not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_tasks_activate(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for NFCT TASKS_DISABLE not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_tasks_disable(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for NFCT TASKS_SENSE not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_tasks_sense(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12 && _end >= 16u64,
                        "partial write for NFCT TASKS_STARTTX not implemented",
                    );
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_tasks_starttx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (28..=31, 29..=32) => {
                if _start < 32 && _end > 28 {
                    assert ! (_start <= 28 && _end >= 32u64 , "partial write for NFCT TASKS_ENABLERXDATA not implemented" ,);
                    let start = _start.saturating_sub(28) as usize;
                    let end = (_end.saturating_sub(28) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_tasks_enablerxdata(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (36..=43, 37..=44) => {
                if _start < 40 && _end > 36 {
                    assert!(
                        _start <= 36 && _end >= 40u64,
                        "partial write for NFCT TASKS_GOIDLE not implemented",
                    );
                    let start = _start.saturating_sub(36) as usize;
                    let end = (_end.saturating_sub(36) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_tasks_goidle(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 44 && _end > 40 {
                    assert!(
                        _start <= 40 && _end >= 44u64,
                        "partial write for NFCT TASKS_GOSLEEP not implemented",
                    );
                    let start = _start.saturating_sub(40) as usize;
                    let end = (_end.saturating_sub(40) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_tasks_gosleep(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for NFCT EVENTS_READY not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_ready(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260 && _end >= 264u64 , "partial write for NFCT EVENTS_FIELDDETECTED not implemented" ,);
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_fielddetected(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264 && _end >= 268u64 , "partial write for NFCT EVENTS_FIELDLOST not implemented" ,);
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_fieldlost(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert ! (_start <= 268 && _end >= 272u64 , "partial write for NFCT EVENTS_TXFRAMESTART not implemented" ,);
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_txframestart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert ! (_start <= 272 && _end >= 276u64 , "partial write for NFCT EVENTS_TXFRAMEEND not implemented" ,);
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_txframeend(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert ! (_start <= 276 && _end >= 280u64 , "partial write for NFCT EVENTS_RXFRAMESTART not implemented" ,);
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_rxframestart(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert ! (_start <= 280 && _end >= 284u64 , "partial write for NFCT EVENTS_RXFRAMEEND not implemented" ,);
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_rxframeend(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284 && _end >= 288u64,
                        "partial write for NFCT EVENTS_ERROR not implemented",
                    );
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_error(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (296..=307, 297..=308) => {
                if _start < 300 && _end > 296 {
                    assert!(
                        _start <= 296 && _end >= 300u64,
                        "partial write for NFCT EVENTS_RXERROR not implemented",
                    );
                    let start = _start.saturating_sub(296) as usize;
                    let end =
                        (_end.saturating_sub(296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_rxerror(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 304 && _end > 300 {
                    assert!(
                        _start <= 300 && _end >= 304u64,
                        "partial write for NFCT EVENTS_ENDRX not implemented",
                    );
                    let start = _start.saturating_sub(300) as usize;
                    let end =
                        (_end.saturating_sub(300) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_endrx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 308 && _end > 304 {
                    assert!(
                        _start <= 304 && _end >= 308u64,
                        "partial write for NFCT EVENTS_ENDTX not implemented",
                    );
                    let start = _start.saturating_sub(304) as usize;
                    let end =
                        (_end.saturating_sub(304) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_endtx(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    assert ! (_start <= 312 && _end >= 316u64 , "partial write for NFCT EVENTS_AUTOCOLRESSTARTED not implemented" ,);
                    let start = _start.saturating_sub(312) as usize;
                    let end =
                        (_end.saturating_sub(312) as usize).min(start + 4);
                    self.0
                        .lock()
                        .unwrap()
                        .write_nfct_events_autocolresstarted(
                            u32::from_ne_bytes(
                                _buf[start..end].try_into().unwrap(),
                            ),
                        )?;
                }
                Ok(())
            }
            (328..=339, 329..=340) => {
                if _start < 332 && _end > 328 {
                    assert ! (_start <= 328 && _end >= 332u64 , "partial write for NFCT EVENTS_COLLISION not implemented" ,);
                    let start = _start.saturating_sub(328) as usize;
                    let end =
                        (_end.saturating_sub(328) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_collision(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 336 && _end > 332 {
                    assert ! (_start <= 332 && _end >= 336u64 , "partial write for NFCT EVENTS_SELECTED not implemented" ,);
                    let start = _start.saturating_sub(332) as usize;
                    let end =
                        (_end.saturating_sub(332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_selected(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 340 && _end > 336 {
                    assert!(
                        _start <= 336 && _end >= 340u64,
                        "partial write for NFCT EVENTS_STARTED not implemented",
                    );
                    let start = _start.saturating_sub(336) as usize;
                    let end =
                        (_end.saturating_sub(336) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_events_started(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_nfct_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_nfct_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_nfct_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_nfct_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1028..=1031, 1029..=1032) => {
                if _start < 1032 && _end > 1028 {
                    let offset = _start.saturating_sub(1028);
                    let start = 1028u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1028) - offset) as usize;
                    self.write_nfct_errorstatus(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1036..=1039, 1037..=1040) => {
                if _start < 1040 && _end > 1036 {
                    let offset = _start.saturating_sub(1036);
                    let start = 1036u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1036) - offset) as usize;
                    self.write_nfct_framestatus_rx(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1072..=1075, 1073..=1076) => {
                if _start < 1076 && _end > 1072 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1084..=1087, 1085..=1088) => {
                if _start < 1088 && _end > 1084 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1284..=1319, 1285..=1320) => {
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_nfct_framedelaymin(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_nfct_framedelaymax(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_nfct_framedelaymode(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296 && _end >= 1300u64,
                        "partial write for NFCT PACKETPTR not implemented",
                    );
                    let start = _start.saturating_sub(1296) as usize;
                    let end =
                        (_end.saturating_sub(1296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nfct_packetptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_nfct_maxlen(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_nfct_txd_frameconfig(offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_nfct_txd_amount(offset, &_buf[start..end])?;
                }
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_nfct_rxd_frameconfig(offset, &_buf[start..end])?;
                }
                if _start < 1320 && _end > 1316 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1424..=1435, 1425..=1436) => {
                if _start < 1428 && _end > 1424 {
                    let offset = _start.saturating_sub(1424);
                    let start = 1424u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1424) - offset) as usize;
                    self.write_nfct_nfcid1_last(offset, &_buf[start..end])?;
                }
                if _start < 1432 && _end > 1428 {
                    let offset = _start.saturating_sub(1428);
                    let start = 1428u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1428) - offset) as usize;
                    self.write_nfct_nfcid1_2nd_last(offset, &_buf[start..end])?;
                }
                if _start < 1436 && _end > 1432 {
                    let offset = _start.saturating_sub(1432);
                    let start = 1432u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1432) - offset) as usize;
                    self.write_nfct_nfcid1_3rd_last(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1440..=1447, 1441..=1448) => {
                if _start < 1444 && _end > 1440 {
                    let offset = _start.saturating_sub(1440);
                    let start = 1440u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1440) - offset) as usize;
                    self.write_nfct_sensres(offset, &_buf[start..end])?;
                }
                if _start < 1448 && _end > 1444 {
                    let offset = _start.saturating_sub(1444);
                    let start = 1444u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1444) - offset) as usize;
                    self.write_nfct_selres(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40005000 {
    fn read_nfct_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_shorts_fielddetected_activate()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_shorts_fieldlost_sense()?,
        ) << 1u32;
        Ok(_value)
    }
    fn write_nfct_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_shorts_fielddetected_activate(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_shorts_fieldlost_sense(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_nfct_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_ready()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_fielddetected()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_fieldlost()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_txframestart()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_txframeend()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_rxframestart()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_rxframeend()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_error()?) << 7u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_inten_rxerror()?)
            << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_endrx()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_endtx()?) << 12u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_inten_autocolresstarted()?,
        ) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_inten_collision()?)
                << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_inten_selected()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_inten_started()?)
            << 20u32;
        Ok(_value)
    }
    fn write_nfct_inten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_fielddetected((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_fieldlost((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_txframestart((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_txframeend((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_rxframestart((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_rxframeend((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_error((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_rxerror((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_endrx((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_endtx((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_nfct_inten_autocolresstarted(
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_collision((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_selected((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_inten_started((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_nfct_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_intenset_ready()?)
            << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_intenset_fielddetected()?,
        ) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenset_fieldlost()?)
                << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_intenset_txframestart()?,
        ) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenset_txframeend()?)
                << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_intenset_rxframestart()?,
        ) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenset_rxframeend()?)
                << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_intenset_error()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenset_rxerror()?)
                << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_intenset_endrx()?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_intenset_endtx()?)
            << 12u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_intenset_autocolresstarted()?,
        ) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenset_collision()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenset_selected()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenset_started()?)
                << 20u32;
        Ok(_value)
    }
    fn write_nfct_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_intenset_fielddetected(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_fieldlost((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_txframestart((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_txframeend((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_rxframestart((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_rxframeend((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_error((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_rxerror((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_endrx((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_endtx((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_autocolresstarted(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_collision((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_selected((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenset_started((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_nfct_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_intenclr_ready()?)
            << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_intenclr_fielddetected()?,
        ) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenclr_fieldlost()?)
                << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_intenclr_txframestart()?,
        ) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenclr_txframeend()?)
                << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_intenclr_rxframestart()?,
        ) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenclr_rxframeend()?)
                << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_intenclr_error()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenclr_rxerror()?)
                << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_intenclr_endrx()?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_intenclr_endtx()?)
            << 12u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_intenclr_autocolresstarted()?,
        ) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenclr_collision()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenclr_selected()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_intenclr_started()?)
                << 20u32;
        Ok(_value)
    }
    fn write_nfct_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_intenclr_fielddetected(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_fieldlost((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_txframestart((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_txframeend((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_rxframestart((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_rxframeend((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_error((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_rxerror((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_endrx((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_endtx((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_autocolresstarted(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_collision((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_selected((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_intenclr_started((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_nfct_errorstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_errorstatus_framedelaytimeout()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_errorstatus_nfcfieldtoostrong()?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_errorstatus_nfcfieldtooweak()?,
        ) << 3u32;
        Ok(_value)
    }
    fn write_nfct_errorstatus(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_errorstatus_framedelaytimeout(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_errorstatus_nfcfieldtoostrong(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_errorstatus_nfcfieldtooweak(
                    (_value[_i] >> 3) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_nfct_framestatus_rx(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_framestatus_rx_crcerror()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_framestatus_rx_paritystatus()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_framestatus_rx_overrun()?,
        ) << 3u32;
        Ok(_value)
    }
    fn write_nfct_framestatus_rx(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_framestatus_rx_crcerror(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_framestatus_rx_paritystatus(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_framestatus_rx_overrun(
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_nfct_currentloadctrl(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_currentloadctrl_currentloadctrl()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_nfct_fieldpresent(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_fieldpresent_fieldpresent()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_fieldpresent_lockdetect()?,
        ) << 1u32;
        Ok(_value)
    }
    fn read_nfct_framedelaymin(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_framedelaymin_framedelaymin()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_nfct_framedelaymin(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0
                .lock()
                .unwrap()
                .write_nfct_framedelaymin_framedelaymin(_value)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_nfct_framedelaymax(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_framedelaymax_framedelaymax()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_nfct_framedelaymax(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0
                .lock()
                .unwrap()
                .write_nfct_framedelaymax_framedelaymax(_value)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_nfct_framedelaymode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_framedelaymode_framedelaymode()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_nfct_framedelaymode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_framedelaymode_framedelaymode(
                    (_value[_i] >> 0) & 3u8,
                )?;
        }
        Ok(())
    }
    fn read_nfct_maxlen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_maxlen_maxlen()?)
            << 0u32;
        Ok(_value)
    }
    fn write_nfct_maxlen(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 1u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_nfct_maxlen_maxlen(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_nfct_txd_frameconfig(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_txd_frameconfig_parity()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_txd_frameconfig_discardmode()?,
        ) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_txd_frameconfig_sof()?)
                << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_txd_frameconfig_crcmodetx()?,
        ) << 4u32;
        Ok(_value)
    }
    fn write_nfct_txd_frameconfig(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_txd_frameconfig_parity(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_txd_frameconfig_discardmode(
                    (_value[_i] >> 1) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_txd_frameconfig_sof((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_txd_frameconfig_crcmodetx(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_nfct_txd_amount(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_txd_amount_txdatabits()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_txd_amount_txdatabytes()?,
        ) << 3u32;
        Ok(_value)
    }
    fn write_nfct_txd_amount(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_txd_amount_txdatabits((_value[_i] >> 0) & 7u8)?;
        }
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 3) & 31u8) as u16;
            _extracted |= ((_value[((0 + 0 + 1) - _start) as usize] & 15u8)
                as u16)
                << (3 + (0 * 8));
            self.0
                .lock()
                .unwrap()
                .write_nfct_txd_amount_txdatabytes(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_nfct_rxd_frameconfig(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_rxd_frameconfig_parity()?,
        ) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_rxd_frameconfig_sof()?)
                << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_rxd_frameconfig_crcmoderx()?,
        ) << 4u32;
        Ok(_value)
    }
    fn write_nfct_rxd_frameconfig(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_rxd_frameconfig_parity(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_rxd_frameconfig_sof((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_rxd_frameconfig_crcmoderx(
                    (_value[_i] >> 4) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_nfct_rxd_amount(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_rxd_amount_rxdatabits()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nfct_rxd_amount_rxdatabytes()?,
        ) << 3u32;
        Ok(_value)
    }
    fn read_nfct_nfcid1_last(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_nfcid1_last_nfcid1_z()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_nfcid1_last_nfcid1_y()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_nfcid1_last_nfcid1_x()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_nfcid1_last_nfcid1_w()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nfct_nfcid1_last(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_nfcid1_last_nfcid1_z((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_nfcid1_last_nfcid1_y((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_nfcid1_last_nfcid1_x((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_nfcid1_last_nfcid1_w((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nfct_nfcid1_2nd_last(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_nfcid1_2nd_last_nfcid1_v()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_nfcid1_2nd_last_nfcid1_u()?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_nfcid1_2nd_last_nfcid1_t()?,
        ) << 16u32;
        Ok(_value)
    }
    fn write_nfct_nfcid1_2nd_last(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_nfcid1_2nd_last_nfcid1_v(
                (_value[_i] >> 0) & 255u8,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_nfct_nfcid1_2nd_last_nfcid1_u(
                (_value[_i] >> 0) & 255u8,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_nfct_nfcid1_2nd_last_nfcid1_t(
                (_value[_i] >> 0) & 255u8,
            )?;
        }
        Ok(())
    }
    fn read_nfct_nfcid1_3rd_last(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_nfcid1_3rd_last_nfcid1_s()?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_nfcid1_3rd_last_nfcid1_r()?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_nfct_nfcid1_3rd_last_nfcid1_q()?,
        ) << 16u32;
        Ok(_value)
    }
    fn write_nfct_nfcid1_3rd_last(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_nfct_nfcid1_3rd_last_nfcid1_s(
                (_value[_i] >> 0) & 255u8,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_nfct_nfcid1_3rd_last_nfcid1_r(
                (_value[_i] >> 0) & 255u8,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_nfct_nfcid1_3rd_last_nfcid1_q(
                (_value[_i] >> 0) & 255u8,
            )?;
        }
        Ok(())
    }
    fn read_nfct_sensres(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_sensres_bitframesdd()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_sensres_rfu5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_sensres_nfcidsize()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_sensres_platfconfig()?)
                << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_sensres_rfu74()?)
            << 12u32;
        Ok(_value)
    }
    fn write_nfct_sensres(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_sensres_bitframesdd((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_sensres_rfu5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_sensres_nfcidsize((_value[_i] >> 6) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_sensres_platfconfig((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_sensres_rfu74((_value[_i] >> 4) & 15u8)?;
        }
        Ok(())
    }
    fn read_nfct_selres(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_selres_rfu10()?) << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_nfct_selres_cascade()?)
            << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_selres_rfu43()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_selres_protocol()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nfct_selres_rfu7()?) << 7u32;
        Ok(_value)
    }
    fn write_nfct_selres(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_selres_rfu10((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_selres_cascade((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_selres_rfu43((_value[_i] >> 3) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_selres_protocol((_value[_i] >> 5) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nfct_selres_rfu7((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40006000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40006000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073766400;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=31, 1..=32) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 24 && _end > 20 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 28 && _end > 24 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 32 && _end > 28 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (48..=79, 49..=80) => {
                if _start < 52 && _end > 48 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 56 && _end > 52 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 60 && _end > 56 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 64 && _end > 60 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 68 && _end > 64 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 72 && _end > 68 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 76 && _end > 72 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 80 && _end > 76 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (96..=127, 97..=128) => {
                if _start < 100 && _end > 96 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 104 && _end > 100 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 108 && _end > 104 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 112 && _end > 108 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 116 && _end > 112 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 120 && _end > 116 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 124 && _end > 120 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 128 && _end > 124 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(0)?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(1)?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(2)?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(3)?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(4)?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(5)?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(6)?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_inn(7)?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (380..=383, 381..=384) => {
                if _start < 384 && _end > 380 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_gpiote_events_port()?
                        .to_ne_bytes();
                    if _start <= 380 && _end > 380 {
                        _buf[(380 - _start) as usize] = _value[0];
                    }
                    if _start <= 381 && _end > 381 {
                        _buf[(381 - _start) as usize] = _value[1];
                    }
                    if _start <= 382 && _end > 382 {
                        _buf[(382 - _start) as usize] = _value[2];
                    }
                    if _start <= 383 && _end > 383 {
                        _buf[(383 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_gpiote_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_gpiote_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1327, 1297..=1328) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_gpiote_confign(0)?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_gpiote_confign(1)?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_gpiote_confign(2)?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_gpiote_confign(3)?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_gpiote_confign(4)?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_gpiote_confign(5)?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_gpiote_confign(6)?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _value = self.read_gpiote_confign(7)?.to_ne_bytes();
                    if _start <= 1324 && _end > 1324 {
                        _buf[(1324 - _start) as usize] = _value[0];
                    }
                    if _start <= 1325 && _end > 1325 {
                        _buf[(1325 - _start) as usize] = _value[1];
                    }
                    if _start <= 1326 && _end > 1326 {
                        _buf[(1326 - _start) as usize] = _value[2];
                    }
                    if _start <= 1327 && _end > 1327 {
                        _buf[(1327 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073766400;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=31, 1..=32) => {
                if _start < 4 && _end > 0 {
                    assert ! (_start <= 0 && _end >= 4u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert ! (_start <= 4 && _end >= 8u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert ! (_start <= 8 && _end >= 12u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert ! (_start <= 12 && _end >= 16u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert ! (_start <= 16 && _end >= 20u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert ! (_start <= 20 && _end >= 24u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(20) as usize;
                    let end = (_end.saturating_sub(20) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 28 && _end > 24 {
                    assert ! (_start <= 24 && _end >= 28u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(24) as usize;
                    let end = (_end.saturating_sub(24) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 32 && _end > 28 {
                    assert ! (_start <= 28 && _end >= 32u64 , "partial write for GPIOTE TASKS_OUT[%s] not implemented" ,);
                    let start = _start.saturating_sub(28) as usize;
                    let end = (_end.saturating_sub(28) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_outn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (48..=79, 49..=80) => {
                if _start < 52 && _end > 48 {
                    assert ! (_start <= 48 && _end >= 52u64 , "partial write for GPIOTE TASKS_SET[%s] not implemented" ,);
                    let start = _start.saturating_sub(48) as usize;
                    let end = (_end.saturating_sub(48) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_setn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 56 && _end > 52 {
                    assert ! (_start <= 52 && _end >= 56u64 , "partial write for GPIOTE TASKS_SET[%s] not implemented" ,);
                    let start = _start.saturating_sub(52) as usize;
                    let end = (_end.saturating_sub(52) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_setn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 60 && _end > 56 {
                    assert ! (_start <= 56 && _end >= 60u64 , "partial write for GPIOTE TASKS_SET[%s] not implemented" ,);
                    let start = _start.saturating_sub(56) as usize;
                    let end = (_end.saturating_sub(56) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_setn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 64 && _end > 60 {
                    assert ! (_start <= 60 && _end >= 64u64 , "partial write for GPIOTE TASKS_SET[%s] not implemented" ,);
                    let start = _start.saturating_sub(60) as usize;
                    let end = (_end.saturating_sub(60) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_setn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 68 && _end > 64 {
                    assert ! (_start <= 64 && _end >= 68u64 , "partial write for GPIOTE TASKS_SET[%s] not implemented" ,);
                    let start = _start.saturating_sub(64) as usize;
                    let end = (_end.saturating_sub(64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_setn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 72 && _end > 68 {
                    assert ! (_start <= 68 && _end >= 72u64 , "partial write for GPIOTE TASKS_SET[%s] not implemented" ,);
                    let start = _start.saturating_sub(68) as usize;
                    let end = (_end.saturating_sub(68) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_setn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 76 && _end > 72 {
                    assert ! (_start <= 72 && _end >= 76u64 , "partial write for GPIOTE TASKS_SET[%s] not implemented" ,);
                    let start = _start.saturating_sub(72) as usize;
                    let end = (_end.saturating_sub(72) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_setn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 80 && _end > 76 {
                    assert ! (_start <= 76 && _end >= 80u64 , "partial write for GPIOTE TASKS_SET[%s] not implemented" ,);
                    let start = _start.saturating_sub(76) as usize;
                    let end = (_end.saturating_sub(76) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_setn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (96..=127, 97..=128) => {
                if _start < 100 && _end > 96 {
                    assert ! (_start <= 96 && _end >= 100u64 , "partial write for GPIOTE TASKS_CLR[%s] not implemented" ,);
                    let start = _start.saturating_sub(96) as usize;
                    let end = (_end.saturating_sub(96) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_clrn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 104 && _end > 100 {
                    assert ! (_start <= 100 && _end >= 104u64 , "partial write for GPIOTE TASKS_CLR[%s] not implemented" ,);
                    let start = _start.saturating_sub(100) as usize;
                    let end =
                        (_end.saturating_sub(100) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_clrn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 108 && _end > 104 {
                    assert ! (_start <= 104 && _end >= 108u64 , "partial write for GPIOTE TASKS_CLR[%s] not implemented" ,);
                    let start = _start.saturating_sub(104) as usize;
                    let end =
                        (_end.saturating_sub(104) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_clrn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 112 && _end > 108 {
                    assert ! (_start <= 108 && _end >= 112u64 , "partial write for GPIOTE TASKS_CLR[%s] not implemented" ,);
                    let start = _start.saturating_sub(108) as usize;
                    let end =
                        (_end.saturating_sub(108) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_clrn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 116 && _end > 112 {
                    assert ! (_start <= 112 && _end >= 116u64 , "partial write for GPIOTE TASKS_CLR[%s] not implemented" ,);
                    let start = _start.saturating_sub(112) as usize;
                    let end =
                        (_end.saturating_sub(112) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_clrn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 120 && _end > 116 {
                    assert ! (_start <= 116 && _end >= 120u64 , "partial write for GPIOTE TASKS_CLR[%s] not implemented" ,);
                    let start = _start.saturating_sub(116) as usize;
                    let end =
                        (_end.saturating_sub(116) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_clrn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 124 && _end > 120 {
                    assert ! (_start <= 120 && _end >= 124u64 , "partial write for GPIOTE TASKS_CLR[%s] not implemented" ,);
                    let start = _start.saturating_sub(120) as usize;
                    let end =
                        (_end.saturating_sub(120) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_clrn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 128 && _end > 124 {
                    assert ! (_start <= 124 && _end >= 128u64 , "partial write for GPIOTE TASKS_CLR[%s] not implemented" ,);
                    let start = _start.saturating_sub(124) as usize;
                    let end =
                        (_end.saturating_sub(124) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_tasks_clrn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    assert ! (_start <= 256 && _end >= 260u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260 && _end >= 264u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264 && _end >= 268u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert ! (_start <= 268 && _end >= 272u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert ! (_start <= 272 && _end >= 276u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert ! (_start <= 276 && _end >= 280u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert ! (_start <= 280 && _end >= 284u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert ! (_start <= 284 && _end >= 288u64 , "partial write for GPIOTE EVENTS_IN[%s] not implemented" ,);
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_inn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (380..=383, 381..=384) => {
                if _start < 384 && _end > 380 {
                    assert!(
                        _start <= 380 && _end >= 384u64,
                        "partial write for GPIOTE EVENTS_PORT not implemented",
                    );
                    let start = _start.saturating_sub(380) as usize;
                    let end =
                        (_end.saturating_sub(380) as usize).min(start + 4);
                    self.0.lock().unwrap().write_gpiote_events_port(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_gpiote_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_gpiote_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1327, 1297..=1328) => {
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_gpiote_confign(0, offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_gpiote_confign(1, offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_gpiote_confign(2, offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_gpiote_confign(3, offset, &_buf[start..end])?;
                }
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_gpiote_confign(4, offset, &_buf[start..end])?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_gpiote_confign(5, offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = _start.saturating_sub(1320);
                    let start = 1320u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1320) - offset) as usize;
                    self.write_gpiote_confign(6, offset, &_buf[start..end])?;
                }
                if _start < 1328 && _end > 1324 {
                    let offset = _start.saturating_sub(1324);
                    let start = 1324u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1324) - offset) as usize;
                    self.write_gpiote_confign(7, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40006000 {
    fn read_gpiote_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in0()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in1()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in2()?)
            << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in3()?)
            << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in4()?)
            << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in5()?)
            << 5u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in6()?)
            << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenset_in7()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpiote_intenset_port()?)
                << 31u32;
        Ok(_value)
    }
    fn write_gpiote_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_in7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenset_port((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpiote_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in0()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in1()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in2()?)
            << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in3()?)
            << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in4()?)
            << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in5()?)
            << 5u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in6()?)
            << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_gpiote_intenclr_in7()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpiote_intenclr_port()?)
                << 31u32;
        Ok(_value)
    }
    fn write_gpiote_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_in7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_intenclr_port((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_gpiote_confign(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpiote_confign_mode(_dim)?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_gpiote_confign_psel(_dim)?)
                << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_gpiote_confign_polarity(_dim)?,
        ) << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_gpiote_confign_outinit(_dim)?,
        ) << 20u32;
        Ok(_value)
    }
    fn write_gpiote_confign(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_confign_mode(_dim, (_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_confign_psel(_dim, (_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_gpiote_confign_polarity(_dim, (_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_gpiote_confign_outinit(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40007000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40007000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073770496;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=343, 257..=344) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_started()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_end()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_done()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_resultdone()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_calibratedone()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_stopped()?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limith(0)?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 292 && _end > 288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limith(1)?
                        .to_ne_bytes();
                    if _start <= 288 && _end > 288 {
                        _buf[(288 - _start) as usize] = _value[0];
                    }
                    if _start <= 289 && _end > 289 {
                        _buf[(289 - _start) as usize] = _value[1];
                    }
                    if _start <= 290 && _end > 290 {
                        _buf[(290 - _start) as usize] = _value[2];
                    }
                    if _start <= 291 && _end > 291 {
                        _buf[(291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 300 && _end > 296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limith(2)?
                        .to_ne_bytes();
                    if _start <= 296 && _end > 296 {
                        _buf[(296 - _start) as usize] = _value[0];
                    }
                    if _start <= 297 && _end > 297 {
                        _buf[(297 - _start) as usize] = _value[1];
                    }
                    if _start <= 298 && _end > 298 {
                        _buf[(298 - _start) as usize] = _value[2];
                    }
                    if _start <= 299 && _end > 299 {
                        _buf[(299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 308 && _end > 304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limith(3)?
                        .to_ne_bytes();
                    if _start <= 304 && _end > 304 {
                        _buf[(304 - _start) as usize] = _value[0];
                    }
                    if _start <= 305 && _end > 305 {
                        _buf[(305 - _start) as usize] = _value[1];
                    }
                    if _start <= 306 && _end > 306 {
                        _buf[(306 - _start) as usize] = _value[2];
                    }
                    if _start <= 307 && _end > 307 {
                        _buf[(307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 316 && _end > 312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limith(4)?
                        .to_ne_bytes();
                    if _start <= 312 && _end > 312 {
                        _buf[(312 - _start) as usize] = _value[0];
                    }
                    if _start <= 313 && _end > 313 {
                        _buf[(313 - _start) as usize] = _value[1];
                    }
                    if _start <= 314 && _end > 314 {
                        _buf[(314 - _start) as usize] = _value[2];
                    }
                    if _start <= 315 && _end > 315 {
                        _buf[(315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 324 && _end > 320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limith(5)?
                        .to_ne_bytes();
                    if _start <= 320 && _end > 320 {
                        _buf[(320 - _start) as usize] = _value[0];
                    }
                    if _start <= 321 && _end > 321 {
                        _buf[(321 - _start) as usize] = _value[1];
                    }
                    if _start <= 322 && _end > 322 {
                        _buf[(322 - _start) as usize] = _value[2];
                    }
                    if _start <= 323 && _end > 323 {
                        _buf[(323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 332 && _end > 328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limith(6)?
                        .to_ne_bytes();
                    if _start <= 328 && _end > 328 {
                        _buf[(328 - _start) as usize] = _value[0];
                    }
                    if _start <= 329 && _end > 329 {
                        _buf[(329 - _start) as usize] = _value[1];
                    }
                    if _start <= 330 && _end > 330 {
                        _buf[(330 - _start) as usize] = _value[2];
                    }
                    if _start <= 331 && _end > 331 {
                        _buf[(331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limith(7)?
                        .to_ne_bytes();
                    if _start <= 336 && _end > 336 {
                        _buf[(336 - _start) as usize] = _value[0];
                    }
                    if _start <= 337 && _end > 337 {
                        _buf[(337 - _start) as usize] = _value[1];
                    }
                    if _start <= 338 && _end > 338 {
                        _buf[(338 - _start) as usize] = _value[2];
                    }
                    if _start <= 339 && _end > 339 {
                        _buf[(339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limitl(0)?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 296 && _end > 292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limitl(1)?
                        .to_ne_bytes();
                    if _start <= 292 && _end > 292 {
                        _buf[(292 - _start) as usize] = _value[0];
                    }
                    if _start <= 293 && _end > 293 {
                        _buf[(293 - _start) as usize] = _value[1];
                    }
                    if _start <= 294 && _end > 294 {
                        _buf[(294 - _start) as usize] = _value[2];
                    }
                    if _start <= 295 && _end > 295 {
                        _buf[(295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 304 && _end > 300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limitl(2)?
                        .to_ne_bytes();
                    if _start <= 300 && _end > 300 {
                        _buf[(300 - _start) as usize] = _value[0];
                    }
                    if _start <= 301 && _end > 301 {
                        _buf[(301 - _start) as usize] = _value[1];
                    }
                    if _start <= 302 && _end > 302 {
                        _buf[(302 - _start) as usize] = _value[2];
                    }
                    if _start <= 303 && _end > 303 {
                        _buf[(303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 312 && _end > 308 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limitl(3)?
                        .to_ne_bytes();
                    if _start <= 308 && _end > 308 {
                        _buf[(308 - _start) as usize] = _value[0];
                    }
                    if _start <= 309 && _end > 309 {
                        _buf[(309 - _start) as usize] = _value[1];
                    }
                    if _start <= 310 && _end > 310 {
                        _buf[(310 - _start) as usize] = _value[2];
                    }
                    if _start <= 311 && _end > 311 {
                        _buf[(311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 320 && _end > 316 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limitl(4)?
                        .to_ne_bytes();
                    if _start <= 316 && _end > 316 {
                        _buf[(316 - _start) as usize] = _value[0];
                    }
                    if _start <= 317 && _end > 317 {
                        _buf[(317 - _start) as usize] = _value[1];
                    }
                    if _start <= 318 && _end > 318 {
                        _buf[(318 - _start) as usize] = _value[2];
                    }
                    if _start <= 319 && _end > 319 {
                        _buf[(319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 328 && _end > 324 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limitl(5)?
                        .to_ne_bytes();
                    if _start <= 324 && _end > 324 {
                        _buf[(324 - _start) as usize] = _value[0];
                    }
                    if _start <= 325 && _end > 325 {
                        _buf[(325 - _start) as usize] = _value[1];
                    }
                    if _start <= 326 && _end > 326 {
                        _buf[(326 - _start) as usize] = _value[2];
                    }
                    if _start <= 327 && _end > 327 {
                        _buf[(327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 336 && _end > 332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limitl(6)?
                        .to_ne_bytes();
                    if _start <= 332 && _end > 332 {
                        _buf[(332 - _start) as usize] = _value[0];
                    }
                    if _start <= 333 && _end > 333 {
                        _buf[(333 - _start) as usize] = _value[1];
                    }
                    if _start <= 334 && _end > 334 {
                        _buf[(334 - _start) as usize] = _value[2];
                    }
                    if _start <= 335 && _end > 335 {
                        _buf[(335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 344 && _end > 340 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_events_chn_limitl(7)?
                        .to_ne_bytes();
                    if _start <= 340 && _end > 340 {
                        _buf[(340 - _start) as usize] = _value[0];
                    }
                    if _start <= 341 && _end > 341 {
                        _buf[(341 - _start) as usize] = _value[1];
                    }
                    if _start <= 342 && _end > 342 {
                        _buf[(342 - _start) as usize] = _value[2];
                    }
                    if _start <= 343 && _end > 343 {
                        _buf[(343 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_saadc_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self.read_saadc_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_saadc_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_saadc_status()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_saadc_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1423, 1297..=1424) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_saadc_chn_pselp(0)?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_saadc_chn_pselp(1)?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _value = self.read_saadc_chn_pselp(2)?.to_ne_bytes();
                    if _start <= 1328 && _end > 1328 {
                        _buf[(1328 - _start) as usize] = _value[0];
                    }
                    if _start <= 1329 && _end > 1329 {
                        _buf[(1329 - _start) as usize] = _value[1];
                    }
                    if _start <= 1330 && _end > 1330 {
                        _buf[(1330 - _start) as usize] = _value[2];
                    }
                    if _start <= 1331 && _end > 1331 {
                        _buf[(1331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_saadc_chn_pselp(3)?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value = self.read_saadc_chn_pselp(4)?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1380 && _end > 1376 {
                    let _value = self.read_saadc_chn_pselp(5)?.to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1396 && _end > 1392 {
                    let _value = self.read_saadc_chn_pselp(6)?.to_ne_bytes();
                    if _start <= 1392 && _end > 1392 {
                        _buf[(1392 - _start) as usize] = _value[0];
                    }
                    if _start <= 1393 && _end > 1393 {
                        _buf[(1393 - _start) as usize] = _value[1];
                    }
                    if _start <= 1394 && _end > 1394 {
                        _buf[(1394 - _start) as usize] = _value[2];
                    }
                    if _start <= 1395 && _end > 1395 {
                        _buf[(1395 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1412 && _end > 1408 {
                    let _value = self.read_saadc_chn_pselp(7)?.to_ne_bytes();
                    if _start <= 1408 && _end > 1408 {
                        _buf[(1408 - _start) as usize] = _value[0];
                    }
                    if _start <= 1409 && _end > 1409 {
                        _buf[(1409 - _start) as usize] = _value[1];
                    }
                    if _start <= 1410 && _end > 1410 {
                        _buf[(1410 - _start) as usize] = _value[2];
                    }
                    if _start <= 1411 && _end > 1411 {
                        _buf[(1411 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_saadc_chn_pseln(0)?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_saadc_chn_pseln(1)?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _value = self.read_saadc_chn_pseln(2)?.to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_saadc_chn_pseln(3)?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _value = self.read_saadc_chn_pseln(4)?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1384 && _end > 1380 {
                    let _value = self.read_saadc_chn_pseln(5)?.to_ne_bytes();
                    if _start <= 1380 && _end > 1380 {
                        _buf[(1380 - _start) as usize] = _value[0];
                    }
                    if _start <= 1381 && _end > 1381 {
                        _buf[(1381 - _start) as usize] = _value[1];
                    }
                    if _start <= 1382 && _end > 1382 {
                        _buf[(1382 - _start) as usize] = _value[2];
                    }
                    if _start <= 1383 && _end > 1383 {
                        _buf[(1383 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1400 && _end > 1396 {
                    let _value = self.read_saadc_chn_pseln(6)?.to_ne_bytes();
                    if _start <= 1396 && _end > 1396 {
                        _buf[(1396 - _start) as usize] = _value[0];
                    }
                    if _start <= 1397 && _end > 1397 {
                        _buf[(1397 - _start) as usize] = _value[1];
                    }
                    if _start <= 1398 && _end > 1398 {
                        _buf[(1398 - _start) as usize] = _value[2];
                    }
                    if _start <= 1399 && _end > 1399 {
                        _buf[(1399 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1416 && _end > 1412 {
                    let _value = self.read_saadc_chn_pseln(7)?.to_ne_bytes();
                    if _start <= 1412 && _end > 1412 {
                        _buf[(1412 - _start) as usize] = _value[0];
                    }
                    if _start <= 1413 && _end > 1413 {
                        _buf[(1413 - _start) as usize] = _value[1];
                    }
                    if _start <= 1414 && _end > 1414 {
                        _buf[(1414 - _start) as usize] = _value[2];
                    }
                    if _start <= 1415 && _end > 1415 {
                        _buf[(1415 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_saadc_chn_config(0)?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_saadc_chn_config(1)?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _value = self.read_saadc_chn_config(2)?.to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_saadc_chn_config(3)?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1372 && _end > 1368 {
                    let _value = self.read_saadc_chn_config(4)?.to_ne_bytes();
                    if _start <= 1368 && _end > 1368 {
                        _buf[(1368 - _start) as usize] = _value[0];
                    }
                    if _start <= 1369 && _end > 1369 {
                        _buf[(1369 - _start) as usize] = _value[1];
                    }
                    if _start <= 1370 && _end > 1370 {
                        _buf[(1370 - _start) as usize] = _value[2];
                    }
                    if _start <= 1371 && _end > 1371 {
                        _buf[(1371 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1388 && _end > 1384 {
                    let _value = self.read_saadc_chn_config(5)?.to_ne_bytes();
                    if _start <= 1384 && _end > 1384 {
                        _buf[(1384 - _start) as usize] = _value[0];
                    }
                    if _start <= 1385 && _end > 1385 {
                        _buf[(1385 - _start) as usize] = _value[1];
                    }
                    if _start <= 1386 && _end > 1386 {
                        _buf[(1386 - _start) as usize] = _value[2];
                    }
                    if _start <= 1387 && _end > 1387 {
                        _buf[(1387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1404 && _end > 1400 {
                    let _value = self.read_saadc_chn_config(6)?.to_ne_bytes();
                    if _start <= 1400 && _end > 1400 {
                        _buf[(1400 - _start) as usize] = _value[0];
                    }
                    if _start <= 1401 && _end > 1401 {
                        _buf[(1401 - _start) as usize] = _value[1];
                    }
                    if _start <= 1402 && _end > 1402 {
                        _buf[(1402 - _start) as usize] = _value[2];
                    }
                    if _start <= 1403 && _end > 1403 {
                        _buf[(1403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1420 && _end > 1416 {
                    let _value = self.read_saadc_chn_config(7)?.to_ne_bytes();
                    if _start <= 1416 && _end > 1416 {
                        _buf[(1416 - _start) as usize] = _value[0];
                    }
                    if _start <= 1417 && _end > 1417 {
                        _buf[(1417 - _start) as usize] = _value[1];
                    }
                    if _start <= 1418 && _end > 1418 {
                        _buf[(1418 - _start) as usize] = _value[2];
                    }
                    if _start <= 1419 && _end > 1419 {
                        _buf[(1419 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_saadc_chn_limit(0)?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _value = self.read_saadc_chn_limit(1)?.to_ne_bytes();
                    if _start <= 1324 && _end > 1324 {
                        _buf[(1324 - _start) as usize] = _value[0];
                    }
                    if _start <= 1325 && _end > 1325 {
                        _buf[(1325 - _start) as usize] = _value[1];
                    }
                    if _start <= 1326 && _end > 1326 {
                        _buf[(1326 - _start) as usize] = _value[2];
                    }
                    if _start <= 1327 && _end > 1327 {
                        _buf[(1327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _value = self.read_saadc_chn_limit(2)?.to_ne_bytes();
                    if _start <= 1340 && _end > 1340 {
                        _buf[(1340 - _start) as usize] = _value[0];
                    }
                    if _start <= 1341 && _end > 1341 {
                        _buf[(1341 - _start) as usize] = _value[1];
                    }
                    if _start <= 1342 && _end > 1342 {
                        _buf[(1342 - _start) as usize] = _value[2];
                    }
                    if _start <= 1343 && _end > 1343 {
                        _buf[(1343 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self.read_saadc_chn_limit(3)?.to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1376 && _end > 1372 {
                    let _value = self.read_saadc_chn_limit(4)?.to_ne_bytes();
                    if _start <= 1372 && _end > 1372 {
                        _buf[(1372 - _start) as usize] = _value[0];
                    }
                    if _start <= 1373 && _end > 1373 {
                        _buf[(1373 - _start) as usize] = _value[1];
                    }
                    if _start <= 1374 && _end > 1374 {
                        _buf[(1374 - _start) as usize] = _value[2];
                    }
                    if _start <= 1375 && _end > 1375 {
                        _buf[(1375 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1392 && _end > 1388 {
                    let _value = self.read_saadc_chn_limit(5)?.to_ne_bytes();
                    if _start <= 1388 && _end > 1388 {
                        _buf[(1388 - _start) as usize] = _value[0];
                    }
                    if _start <= 1389 && _end > 1389 {
                        _buf[(1389 - _start) as usize] = _value[1];
                    }
                    if _start <= 1390 && _end > 1390 {
                        _buf[(1390 - _start) as usize] = _value[2];
                    }
                    if _start <= 1391 && _end > 1391 {
                        _buf[(1391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1408 && _end > 1404 {
                    let _value = self.read_saadc_chn_limit(6)?.to_ne_bytes();
                    if _start <= 1404 && _end > 1404 {
                        _buf[(1404 - _start) as usize] = _value[0];
                    }
                    if _start <= 1405 && _end > 1405 {
                        _buf[(1405 - _start) as usize] = _value[1];
                    }
                    if _start <= 1406 && _end > 1406 {
                        _buf[(1406 - _start) as usize] = _value[2];
                    }
                    if _start <= 1407 && _end > 1407 {
                        _buf[(1407 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1424 && _end > 1420 {
                    let _value = self.read_saadc_chn_limit(7)?.to_ne_bytes();
                    if _start <= 1420 && _end > 1420 {
                        _buf[(1420 - _start) as usize] = _value[0];
                    }
                    if _start <= 1421 && _end > 1421 {
                        _buf[(1421 - _start) as usize] = _value[1];
                    }
                    if _start <= 1422 && _end > 1422 {
                        _buf[(1422 - _start) as usize] = _value[2];
                    }
                    if _start <= 1423 && _end > 1423 {
                        _buf[(1423 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1520..=1531, 1521..=1532) => {
                if _start < 1524 && _end > 1520 {
                    let _value = self.read_saadc_resolution()?.to_ne_bytes();
                    if _start <= 1520 && _end > 1520 {
                        _buf[(1520 - _start) as usize] = _value[0];
                    }
                    if _start <= 1521 && _end > 1521 {
                        _buf[(1521 - _start) as usize] = _value[1];
                    }
                    if _start <= 1522 && _end > 1522 {
                        _buf[(1522 - _start) as usize] = _value[2];
                    }
                    if _start <= 1523 && _end > 1523 {
                        _buf[(1523 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1528 && _end > 1524 {
                    let _value = self.read_saadc_oversample()?.to_ne_bytes();
                    if _start <= 1524 && _end > 1524 {
                        _buf[(1524 - _start) as usize] = _value[0];
                    }
                    if _start <= 1525 && _end > 1525 {
                        _buf[(1525 - _start) as usize] = _value[1];
                    }
                    if _start <= 1526 && _end > 1526 {
                        _buf[(1526 - _start) as usize] = _value[2];
                    }
                    if _start <= 1527 && _end > 1527 {
                        _buf[(1527 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1532 && _end > 1528 {
                    let _value = self.read_saadc_samplerate()?.to_ne_bytes();
                    if _start <= 1528 && _end > 1528 {
                        _buf[(1528 - _start) as usize] = _value[0];
                    }
                    if _start <= 1529 && _end > 1529 {
                        _buf[(1529 - _start) as usize] = _value[1];
                    }
                    if _start <= 1530 && _end > 1530 {
                        _buf[(1530 - _start) as usize] = _value[2];
                    }
                    if _start <= 1531 && _end > 1531 {
                        _buf[(1531 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1580..=1591, 1581..=1592) => {
                if _start < 1584 && _end > 1580 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_saadc_result_ptr()?
                        .to_ne_bytes();
                    if _start <= 1580 && _end > 1580 {
                        _buf[(1580 - _start) as usize] = _value[0];
                    }
                    if _start <= 1581 && _end > 1581 {
                        _buf[(1581 - _start) as usize] = _value[1];
                    }
                    if _start <= 1582 && _end > 1582 {
                        _buf[(1582 - _start) as usize] = _value[2];
                    }
                    if _start <= 1583 && _end > 1583 {
                        _buf[(1583 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1588 && _end > 1584 {
                    let _value = self.read_saadc_result_maxcnt()?.to_ne_bytes();
                    if _start <= 1584 && _end > 1584 {
                        _buf[(1584 - _start) as usize] = _value[0];
                    }
                    if _start <= 1585 && _end > 1585 {
                        _buf[(1585 - _start) as usize] = _value[1];
                    }
                    if _start <= 1586 && _end > 1586 {
                        _buf[(1586 - _start) as usize] = _value[2];
                    }
                    if _start <= 1587 && _end > 1587 {
                        _buf[(1587 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1592 && _end > 1588 {
                    let _value = self.read_saadc_result_amount()?.to_ne_bytes();
                    if _start <= 1588 && _end > 1588 {
                        _buf[(1588 - _start) as usize] = _value[0];
                    }
                    if _start <= 1589 && _end > 1589 {
                        _buf[(1589 - _start) as usize] = _value[1];
                    }
                    if _start <= 1590 && _end > 1590 {
                        _buf[(1590 - _start) as usize] = _value[2];
                    }
                    if _start <= 1591 && _end > 1591 {
                        _buf[(1591 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073770496;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for SAADC TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for SAADC TASKS_SAMPLE not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_tasks_sample(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for SAADC TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert ! (_start <= 12 && _end >= 16u64 , "partial write for SAADC TASKS_CALIBRATEOFFSET not implemented" ,);
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_tasks_calibrateoffset(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=343, 257..=344) => {
                if _start < 260 && _end > 256 {
                    assert ! (_start <= 256 && _end >= 260u64 , "partial write for SAADC EVENTS_STARTED not implemented" ,);
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_started(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for SAADC EVENTS_END not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_end(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for SAADC EVENTS_DONE not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_done(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert ! (_start <= 268 && _end >= 272u64 , "partial write for SAADC EVENTS_RESULTDONE not implemented" ,);
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_resultdone(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert ! (_start <= 272 && _end >= 276u64 , "partial write for SAADC EVENTS_CALIBRATEDONE not implemented" ,);
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_calibratedone(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert ! (_start <= 276 && _end >= 280u64 , "partial write for SAADC EVENTS_STOPPED not implemented" ,);
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_stopped(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert!(
                        _start <= 280 && _end >= 284u64,
                        "partial write for SAADC LIMITH not implemented",
                    );
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limith(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 292 && _end > 288 {
                    assert!(
                        _start <= 288 && _end >= 292u64,
                        "partial write for SAADC LIMITH not implemented",
                    );
                    let start = _start.saturating_sub(288) as usize;
                    let end =
                        (_end.saturating_sub(288) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limith(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 300 && _end > 296 {
                    assert!(
                        _start <= 296 && _end >= 300u64,
                        "partial write for SAADC LIMITH not implemented",
                    );
                    let start = _start.saturating_sub(296) as usize;
                    let end =
                        (_end.saturating_sub(296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limith(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 308 && _end > 304 {
                    assert!(
                        _start <= 304 && _end >= 308u64,
                        "partial write for SAADC LIMITH not implemented",
                    );
                    let start = _start.saturating_sub(304) as usize;
                    let end =
                        (_end.saturating_sub(304) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limith(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 316 && _end > 312 {
                    assert!(
                        _start <= 312 && _end >= 316u64,
                        "partial write for SAADC LIMITH not implemented",
                    );
                    let start = _start.saturating_sub(312) as usize;
                    let end =
                        (_end.saturating_sub(312) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limith(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 324 && _end > 320 {
                    assert!(
                        _start <= 320 && _end >= 324u64,
                        "partial write for SAADC LIMITH not implemented",
                    );
                    let start = _start.saturating_sub(320) as usize;
                    let end =
                        (_end.saturating_sub(320) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limith(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 332 && _end > 328 {
                    assert!(
                        _start <= 328 && _end >= 332u64,
                        "partial write for SAADC LIMITH not implemented",
                    );
                    let start = _start.saturating_sub(328) as usize;
                    let end =
                        (_end.saturating_sub(328) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limith(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 340 && _end > 336 {
                    assert!(
                        _start <= 336 && _end >= 340u64,
                        "partial write for SAADC LIMITH not implemented",
                    );
                    let start = _start.saturating_sub(336) as usize;
                    let end =
                        (_end.saturating_sub(336) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limith(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284 && _end >= 288u64,
                        "partial write for SAADC LIMITL not implemented",
                    );
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limitl(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 296 && _end > 292 {
                    assert!(
                        _start <= 292 && _end >= 296u64,
                        "partial write for SAADC LIMITL not implemented",
                    );
                    let start = _start.saturating_sub(292) as usize;
                    let end =
                        (_end.saturating_sub(292) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limitl(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 304 && _end > 300 {
                    assert!(
                        _start <= 300 && _end >= 304u64,
                        "partial write for SAADC LIMITL not implemented",
                    );
                    let start = _start.saturating_sub(300) as usize;
                    let end =
                        (_end.saturating_sub(300) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limitl(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 312 && _end > 308 {
                    assert!(
                        _start <= 308 && _end >= 312u64,
                        "partial write for SAADC LIMITL not implemented",
                    );
                    let start = _start.saturating_sub(308) as usize;
                    let end =
                        (_end.saturating_sub(308) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limitl(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 320 && _end > 316 {
                    assert!(
                        _start <= 316 && _end >= 320u64,
                        "partial write for SAADC LIMITL not implemented",
                    );
                    let start = _start.saturating_sub(316) as usize;
                    let end =
                        (_end.saturating_sub(316) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limitl(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 328 && _end > 324 {
                    assert!(
                        _start <= 324 && _end >= 328u64,
                        "partial write for SAADC LIMITL not implemented",
                    );
                    let start = _start.saturating_sub(324) as usize;
                    let end =
                        (_end.saturating_sub(324) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limitl(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 336 && _end > 332 {
                    assert!(
                        _start <= 332 && _end >= 336u64,
                        "partial write for SAADC LIMITL not implemented",
                    );
                    let start = _start.saturating_sub(332) as usize;
                    let end =
                        (_end.saturating_sub(332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limitl(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 344 && _end > 340 {
                    assert!(
                        _start <= 340 && _end >= 344u64,
                        "partial write for SAADC LIMITL not implemented",
                    );
                    let start = _start.saturating_sub(340) as usize;
                    let end =
                        (_end.saturating_sub(340) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_events_chn_limitl(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_saadc_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_saadc_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_saadc_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_saadc_enable(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1423, 1297..=1424) => {
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_saadc_chn_pselp(0, offset, &_buf[start..end])?;
                }
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_saadc_chn_pselp(1, offset, &_buf[start..end])?;
                }
                if _start < 1332 && _end > 1328 {
                    let offset = _start.saturating_sub(1328);
                    let start = 1328u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1328) - offset) as usize;
                    self.write_saadc_chn_pselp(2, offset, &_buf[start..end])?;
                }
                if _start < 1348 && _end > 1344 {
                    let offset = _start.saturating_sub(1344);
                    let start = 1344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1344) - offset) as usize;
                    self.write_saadc_chn_pselp(3, offset, &_buf[start..end])?;
                }
                if _start < 1364 && _end > 1360 {
                    let offset = _start.saturating_sub(1360);
                    let start = 1360u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1360) - offset) as usize;
                    self.write_saadc_chn_pselp(4, offset, &_buf[start..end])?;
                }
                if _start < 1380 && _end > 1376 {
                    let offset = _start.saturating_sub(1376);
                    let start = 1376u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1376) - offset) as usize;
                    self.write_saadc_chn_pselp(5, offset, &_buf[start..end])?;
                }
                if _start < 1396 && _end > 1392 {
                    let offset = _start.saturating_sub(1392);
                    let start = 1392u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1392) - offset) as usize;
                    self.write_saadc_chn_pselp(6, offset, &_buf[start..end])?;
                }
                if _start < 1412 && _end > 1408 {
                    let offset = _start.saturating_sub(1408);
                    let start = 1408u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1408) - offset) as usize;
                    self.write_saadc_chn_pselp(7, offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_saadc_chn_pseln(0, offset, &_buf[start..end])?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_saadc_chn_pseln(1, offset, &_buf[start..end])?;
                }
                if _start < 1336 && _end > 1332 {
                    let offset = _start.saturating_sub(1332);
                    let start = 1332u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1332) - offset) as usize;
                    self.write_saadc_chn_pseln(2, offset, &_buf[start..end])?;
                }
                if _start < 1352 && _end > 1348 {
                    let offset = _start.saturating_sub(1348);
                    let start = 1348u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1348) - offset) as usize;
                    self.write_saadc_chn_pseln(3, offset, &_buf[start..end])?;
                }
                if _start < 1368 && _end > 1364 {
                    let offset = _start.saturating_sub(1364);
                    let start = 1364u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1364) - offset) as usize;
                    self.write_saadc_chn_pseln(4, offset, &_buf[start..end])?;
                }
                if _start < 1384 && _end > 1380 {
                    let offset = _start.saturating_sub(1380);
                    let start = 1380u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1380) - offset) as usize;
                    self.write_saadc_chn_pseln(5, offset, &_buf[start..end])?;
                }
                if _start < 1400 && _end > 1396 {
                    let offset = _start.saturating_sub(1396);
                    let start = 1396u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1396) - offset) as usize;
                    self.write_saadc_chn_pseln(6, offset, &_buf[start..end])?;
                }
                if _start < 1416 && _end > 1412 {
                    let offset = _start.saturating_sub(1412);
                    let start = 1412u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1412) - offset) as usize;
                    self.write_saadc_chn_pseln(7, offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_saadc_chn_config(0, offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = _start.saturating_sub(1320);
                    let start = 1320u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1320) - offset) as usize;
                    self.write_saadc_chn_config(1, offset, &_buf[start..end])?;
                }
                if _start < 1340 && _end > 1336 {
                    let offset = _start.saturating_sub(1336);
                    let start = 1336u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1336) - offset) as usize;
                    self.write_saadc_chn_config(2, offset, &_buf[start..end])?;
                }
                if _start < 1356 && _end > 1352 {
                    let offset = _start.saturating_sub(1352);
                    let start = 1352u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1352) - offset) as usize;
                    self.write_saadc_chn_config(3, offset, &_buf[start..end])?;
                }
                if _start < 1372 && _end > 1368 {
                    let offset = _start.saturating_sub(1368);
                    let start = 1368u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1368) - offset) as usize;
                    self.write_saadc_chn_config(4, offset, &_buf[start..end])?;
                }
                if _start < 1388 && _end > 1384 {
                    let offset = _start.saturating_sub(1384);
                    let start = 1384u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1384) - offset) as usize;
                    self.write_saadc_chn_config(5, offset, &_buf[start..end])?;
                }
                if _start < 1404 && _end > 1400 {
                    let offset = _start.saturating_sub(1400);
                    let start = 1400u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1400) - offset) as usize;
                    self.write_saadc_chn_config(6, offset, &_buf[start..end])?;
                }
                if _start < 1420 && _end > 1416 {
                    let offset = _start.saturating_sub(1416);
                    let start = 1416u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1416) - offset) as usize;
                    self.write_saadc_chn_config(7, offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_saadc_chn_limit(0, offset, &_buf[start..end])?;
                }
                if _start < 1328 && _end > 1324 {
                    let offset = _start.saturating_sub(1324);
                    let start = 1324u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1324) - offset) as usize;
                    self.write_saadc_chn_limit(1, offset, &_buf[start..end])?;
                }
                if _start < 1344 && _end > 1340 {
                    let offset = _start.saturating_sub(1340);
                    let start = 1340u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1340) - offset) as usize;
                    self.write_saadc_chn_limit(2, offset, &_buf[start..end])?;
                }
                if _start < 1360 && _end > 1356 {
                    let offset = _start.saturating_sub(1356);
                    let start = 1356u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1356) - offset) as usize;
                    self.write_saadc_chn_limit(3, offset, &_buf[start..end])?;
                }
                if _start < 1376 && _end > 1372 {
                    let offset = _start.saturating_sub(1372);
                    let start = 1372u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1372) - offset) as usize;
                    self.write_saadc_chn_limit(4, offset, &_buf[start..end])?;
                }
                if _start < 1392 && _end > 1388 {
                    let offset = _start.saturating_sub(1388);
                    let start = 1388u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1388) - offset) as usize;
                    self.write_saadc_chn_limit(5, offset, &_buf[start..end])?;
                }
                if _start < 1408 && _end > 1404 {
                    let offset = _start.saturating_sub(1404);
                    let start = 1404u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1404) - offset) as usize;
                    self.write_saadc_chn_limit(6, offset, &_buf[start..end])?;
                }
                if _start < 1424 && _end > 1420 {
                    let offset = _start.saturating_sub(1420);
                    let start = 1420u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1420) - offset) as usize;
                    self.write_saadc_chn_limit(7, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1520..=1531, 1521..=1532) => {
                if _start < 1524 && _end > 1520 {
                    let offset = _start.saturating_sub(1520);
                    let start = 1520u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1520) - offset) as usize;
                    self.write_saadc_resolution(offset, &_buf[start..end])?;
                }
                if _start < 1528 && _end > 1524 {
                    let offset = _start.saturating_sub(1524);
                    let start = 1524u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1524) - offset) as usize;
                    self.write_saadc_oversample(offset, &_buf[start..end])?;
                }
                if _start < 1532 && _end > 1528 {
                    let offset = _start.saturating_sub(1528);
                    let start = 1528u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1528) - offset) as usize;
                    self.write_saadc_samplerate(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1580..=1591, 1581..=1592) => {
                if _start < 1584 && _end > 1580 {
                    assert!(
                        _start <= 1580 && _end >= 1584u64,
                        "partial write for SAADC PTR not implemented",
                    );
                    let start = _start.saturating_sub(1580) as usize;
                    let end =
                        (_end.saturating_sub(1580) as usize).min(start + 4);
                    self.0.lock().unwrap().write_saadc_result_ptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1588 && _end > 1584 {
                    let offset = _start.saturating_sub(1584);
                    let start = 1584u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1584) - offset) as usize;
                    self.write_saadc_result_maxcnt(offset, &_buf[start..end])?;
                }
                if _start < 1592 && _end > 1588 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40007000 {
    fn read_saadc_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_inten_started()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_end()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_done()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_resultdone()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_calibratedone()?)
                << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_inten_stopped()?)
            << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch0limith()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch0limitl()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch1limith()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch1limitl()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch2limith()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch2limitl()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch3limith()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch3limitl()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch4limith()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch4limitl()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch5limith()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch5limitl()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch6limith()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch6limitl()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch7limith()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_inten_ch7limitl()?)
                << 21u32;
        Ok(_value)
    }
    fn write_saadc_inten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_started((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_end((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_done((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_resultdone((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_calibratedone((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_stopped((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch0limith((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch0limitl((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch1limith((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch1limitl((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch2limith((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch2limitl((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch3limith((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch3limitl((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch4limith((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch4limitl((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch5limith((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch5limitl((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch6limith((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch6limitl((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch7limith((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_inten_ch7limitl((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_saadc_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_started()?)
                << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_intenset_end()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_intenset_done()?)
            << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_resultdone()?)
                << 3u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_saadc_intenset_calibratedone()?,
        ) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_stopped()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch0limith()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch0limitl()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch1limith()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch1limitl()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch2limith()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch2limitl()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch3limith()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch3limitl()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch4limith()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch4limitl()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch5limith()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch5limitl()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch6limith()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch6limitl()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch7limith()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenset_ch7limitl()?)
                << 21u32;
        Ok(_value)
    }
    fn write_saadc_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_started((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_end((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_done((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_resultdone((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_saadc_intenset_calibratedone(
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_stopped((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch0limith((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch0limitl((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch1limith((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch1limitl((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch2limith((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch2limitl((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch3limith((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch3limitl((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch4limith((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch4limitl((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch5limith((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch5limitl((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch6limith((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch6limitl((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch7limith((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenset_ch7limitl((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_saadc_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_started()?)
                << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_intenclr_end()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_intenclr_done()?)
            << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_resultdone()?)
                << 3u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_saadc_intenclr_calibratedone()?,
        ) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_stopped()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch0limith()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch0limitl()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch1limith()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch1limitl()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch2limith()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch2limitl()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch3limith()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch3limitl()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch4limith()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch4limitl()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch5limith()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch5limitl()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch6limith()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch6limitl()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch7limith()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_intenclr_ch7limitl()?)
                << 21u32;
        Ok(_value)
    }
    fn write_saadc_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_started((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_end((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_done((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_resultdone((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_saadc_intenclr_calibratedone(
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_stopped((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch0limith((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch0limitl((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch1limith((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch1limitl((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch2limith((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch2limitl((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch3limith((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch3limitl((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch4limith((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch4limitl((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch5limith((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch5limitl((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch6limith((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch6limitl((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch7limith((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_intenclr_ch7limitl((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_saadc_status(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_status_status()?)
            << 0u32;
        Ok(_value)
    }
    fn read_saadc_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_enable_enable()?)
            << 0u32;
        Ok(_value)
    }
    fn write_saadc_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_enable_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_saadc_chn_pselp(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_pselp_pselp(_dim)?)
                << 0u32;
        Ok(_value)
    }
    fn write_saadc_chn_pselp(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_chn_pselp_pselp(_dim, (_value[_i] >> 0) & 31u8)?;
        }
        Ok(())
    }
    fn read_saadc_chn_pseln(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_pseln_pseln(_dim)?)
                << 0u32;
        Ok(_value)
    }
    fn write_saadc_chn_pseln(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_chn_pseln_pseln(_dim, (_value[_i] >> 0) & 31u8)?;
        }
        Ok(())
    }
    fn read_saadc_chn_config(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_config_resp(_dim)?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_config_resn(_dim)?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_config_gain(_dim)?)
                << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_saadc_chn_config_refsel(_dim)?,
        ) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_config_tacq(_dim)?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_config_mode(_dim)?)
                << 20u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_saadc_chn_config_burst(_dim)?,
        ) << 24u32;
        Ok(_value)
    }
    fn write_saadc_chn_config(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_chn_config_resp(_dim, (_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_chn_config_resn(_dim, (_value[_i] >> 4) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_chn_config_gain(_dim, (_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_saadc_chn_config_refsel(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_chn_config_tacq(_dim, (_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_saadc_chn_config_mode(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_saadc_chn_config_burst(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_saadc_chn_limit(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_limit_low(_dim)?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_chn_limit_high(_dim)?)
                << 16u32;
        Ok(_value)
    }
    fn write_saadc_chn_limit(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0
                .lock()
                .unwrap()
                .write_saadc_chn_limit_low(_dim, _value)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        if _start <= 2 && _end >= 4 {
            let _offset_start = (2 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0
                .lock()
                .unwrap()
                .write_saadc_chn_limit_high(_dim, _value)?;
        } else if (_start > 2 && _start < 4) || (_end > 2 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_saadc_resolution(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_resolution_val()?)
                << 0u32;
        Ok(_value)
    }
    fn write_saadc_resolution(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_resolution_val((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_saadc_oversample(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_saadc_oversample_oversample()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_saadc_oversample(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_oversample_oversample((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
    fn read_saadc_samplerate(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_saadc_samplerate_cc()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_saadc_samplerate_mode()?)
                << 12u32;
        Ok(_value)
    }
    fn write_saadc_samplerate(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 7u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_saadc_samplerate_cc(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_saadc_samplerate_mode((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_saadc_result_maxcnt(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_saadc_result_maxcnt_maxcnt()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_saadc_result_maxcnt(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 127u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_saadc_result_maxcnt_maxcnt(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_saadc_result_amount(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_saadc_result_amount_amount()?,
        ) << 0u32;
        Ok(_value)
    }
}
pub(crate) struct PeripheralPage0x40008000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40008000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073774592;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (64..=79, 65..=80) => {
                if _start < 68 && _end > 64 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 72 && _end > 68 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 76 && _end > 72 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 80 && _end > 76 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (320..=335, 321..=336) => {
                if _start < 324 && _end > 320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_events_comparen(0)?
                        .to_ne_bytes();
                    if _start <= 320 && _end > 320 {
                        _buf[(320 - _start) as usize] = _value[0];
                    }
                    if _start <= 321 && _end > 321 {
                        _buf[(321 - _start) as usize] = _value[1];
                    }
                    if _start <= 322 && _end > 322 {
                        _buf[(322 - _start) as usize] = _value[2];
                    }
                    if _start <= 323 && _end > 323 {
                        _buf[(323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 328 && _end > 324 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_events_comparen(1)?
                        .to_ne_bytes();
                    if _start <= 324 && _end > 324 {
                        _buf[(324 - _start) as usize] = _value[0];
                    }
                    if _start <= 325 && _end > 325 {
                        _buf[(325 - _start) as usize] = _value[1];
                    }
                    if _start <= 326 && _end > 326 {
                        _buf[(326 - _start) as usize] = _value[2];
                    }
                    if _start <= 327 && _end > 327 {
                        _buf[(327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 332 && _end > 328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_events_comparen(2)?
                        .to_ne_bytes();
                    if _start <= 328 && _end > 328 {
                        _buf[(328 - _start) as usize] = _value[0];
                    }
                    if _start <= 329 && _end > 329 {
                        _buf[(329 - _start) as usize] = _value[1];
                    }
                    if _start <= 330 && _end > 330 {
                        _buf[(330 - _start) as usize] = _value[2];
                    }
                    if _start <= 331 && _end > 331 {
                        _buf[(331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 336 && _end > 332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_events_comparen(3)?
                        .to_ne_bytes();
                    if _start <= 332 && _end > 332 {
                        _buf[(332 - _start) as usize] = _value[0];
                    }
                    if _start <= 333 && _end > 333 {
                        _buf[(333 - _start) as usize] = _value[1];
                    }
                    if _start <= 334 && _end > 334 {
                        _buf[(334 - _start) as usize] = _value[2];
                    }
                    if _start <= 335 && _end > 335 {
                        _buf[(335 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_timer0_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_timer0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_timer0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_timer0_mode()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_timer0_bitmode()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_timer0_prescaler()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_ccn(0)?
                        .to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_ccn(1)?
                        .to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_ccn(2)?
                        .to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer0_ccn(3)?
                        .to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073774592;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for TIMER0 TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for TIMER0 TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for TIMER0 TASKS_COUNT not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_count(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12 && _end >= 16u64,
                        "partial write for TIMER0 TASKS_CLEAR not implemented",
                    );
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_clear(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert ! (_start <= 16 && _end >= 20u64 , "partial write for TIMER0 TASKS_SHUTDOWN not implemented" ,);
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_shutdown(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (64..=79, 65..=80) => {
                if _start < 68 && _end > 64 {
                    assert ! (_start <= 64 && _end >= 68u64 , "partial write for TIMER0 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(64) as usize;
                    let end = (_end.saturating_sub(64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_capturen(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 72 && _end > 68 {
                    assert ! (_start <= 68 && _end >= 72u64 , "partial write for TIMER0 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(68) as usize;
                    let end = (_end.saturating_sub(68) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_capturen(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 76 && _end > 72 {
                    assert ! (_start <= 72 && _end >= 76u64 , "partial write for TIMER0 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(72) as usize;
                    let end = (_end.saturating_sub(72) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_capturen(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 80 && _end > 76 {
                    assert ! (_start <= 76 && _end >= 80u64 , "partial write for TIMER0 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(76) as usize;
                    let end = (_end.saturating_sub(76) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_tasks_capturen(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (320..=335, 321..=336) => {
                if _start < 324 && _end > 320 {
                    assert ! (_start <= 320 && _end >= 324u64 , "partial write for TIMER0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(320) as usize;
                    let end =
                        (_end.saturating_sub(320) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_events_comparen(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 328 && _end > 324 {
                    assert ! (_start <= 324 && _end >= 328u64 , "partial write for TIMER0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(324) as usize;
                    let end =
                        (_end.saturating_sub(324) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_events_comparen(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 332 && _end > 328 {
                    assert ! (_start <= 328 && _end >= 332u64 , "partial write for TIMER0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(328) as usize;
                    let end =
                        (_end.saturating_sub(328) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_events_comparen(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 336 && _end > 332 {
                    assert ! (_start <= 332 && _end >= 336u64 , "partial write for TIMER0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(332) as usize;
                    let end =
                        (_end.saturating_sub(332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_events_comparen(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_timer0_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_timer0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_timer0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_timer0_mode(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_timer0_bitmode(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_timer0_prescaler(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    assert!(
                        _start <= 1344 && _end >= 1348u64,
                        "partial write for TIMER0 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1344) as usize;
                    let end =
                        (_end.saturating_sub(1344) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_ccn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1352 && _end > 1348 {
                    assert!(
                        _start <= 1348 && _end >= 1352u64,
                        "partial write for TIMER0 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1348) as usize;
                    let end =
                        (_end.saturating_sub(1348) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_ccn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1356 && _end > 1352 {
                    assert!(
                        _start <= 1352 && _end >= 1356u64,
                        "partial write for TIMER0 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1352) as usize;
                    let end =
                        (_end.saturating_sub(1352) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_ccn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1360 && _end > 1356 {
                    assert!(
                        _start <= 1356 && _end >= 1360u64,
                        "partial write for TIMER0 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1356) as usize;
                    let end =
                        (_end.saturating_sub(1356) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer0_ccn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40008000 {
    fn read_timer0_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare0_clear()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare1_clear()?,
        ) << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare2_clear()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare3_clear()?,
        ) << 3u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare0_stop()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare1_stop()?,
        ) << 9u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare2_stop()?,
        ) << 10u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_shorts_compare3_stop()?,
        ) << 11u32;
        Ok(_value)
    }
    fn write_timer0_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare0_clear(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare1_clear(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare2_clear(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare3_clear(
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare0_stop(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare1_stop(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare2_stop(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer0_shorts_compare3_stop(
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_timer0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenset_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenset_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenset_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenset_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_timer0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenset_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenset_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenset_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenset_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_timer0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenclr_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenclr_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenclr_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_intenclr_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_timer0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenclr_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenclr_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenclr_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_intenclr_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_timer0_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_mode_mode()?) << 0u32;
        Ok(_value)
    }
    fn write_timer0_mode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_mode_mode((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_timer0_bitmode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer0_bitmode_bitmode()?)
                << 0u32;
        Ok(_value)
    }
    fn write_timer0_bitmode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_bitmode_bitmode((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_timer0_prescaler(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer0_prescaler_prescaler()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_timer0_prescaler(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer0_prescaler_prescaler((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000B000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000B000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073786880;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_tick()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_ovrflw()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (320..=335, 321..=336) => {
                if _start < 324 && _end > 320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_comparen(0)?
                        .to_ne_bytes();
                    if _start <= 320 && _end > 320 {
                        _buf[(320 - _start) as usize] = _value[0];
                    }
                    if _start <= 321 && _end > 321 {
                        _buf[(321 - _start) as usize] = _value[1];
                    }
                    if _start <= 322 && _end > 322 {
                        _buf[(322 - _start) as usize] = _value[2];
                    }
                    if _start <= 323 && _end > 323 {
                        _buf[(323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 328 && _end > 324 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_comparen(1)?
                        .to_ne_bytes();
                    if _start <= 324 && _end > 324 {
                        _buf[(324 - _start) as usize] = _value[0];
                    }
                    if _start <= 325 && _end > 325 {
                        _buf[(325 - _start) as usize] = _value[1];
                    }
                    if _start <= 326 && _end > 326 {
                        _buf[(326 - _start) as usize] = _value[2];
                    }
                    if _start <= 327 && _end > 327 {
                        _buf[(327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 332 && _end > 328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_comparen(2)?
                        .to_ne_bytes();
                    if _start <= 328 && _end > 328 {
                        _buf[(328 - _start) as usize] = _value[0];
                    }
                    if _start <= 329 && _end > 329 {
                        _buf[(329 - _start) as usize] = _value[1];
                    }
                    if _start <= 330 && _end > 330 {
                        _buf[(330 - _start) as usize] = _value[2];
                    }
                    if _start <= 331 && _end > 331 {
                        _buf[(331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 336 && _end > 332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rtc0_events_comparen(3)?
                        .to_ne_bytes();
                    if _start <= 332 && _end > 332 {
                        _buf[(332 - _start) as usize] = _value[0];
                    }
                    if _start <= 333 && _end > 333 {
                        _buf[(333 - _start) as usize] = _value[1];
                    }
                    if _start <= 334 && _end > 334 {
                        _buf[(334 - _start) as usize] = _value[2];
                    }
                    if _start <= 335 && _end > 335 {
                        _buf[(335 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_rtc0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_rtc0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (832..=843, 833..=844) => {
                if _start < 836 && _end > 832 {
                    let _value = self.read_rtc0_evten()?.to_ne_bytes();
                    if _start <= 832 && _end > 832 {
                        _buf[(832 - _start) as usize] = _value[0];
                    }
                    if _start <= 833 && _end > 833 {
                        _buf[(833 - _start) as usize] = _value[1];
                    }
                    if _start <= 834 && _end > 834 {
                        _buf[(834 - _start) as usize] = _value[2];
                    }
                    if _start <= 835 && _end > 835 {
                        _buf[(835 - _start) as usize] = _value[3];
                    }
                }
                if _start < 840 && _end > 836 {
                    let _value = self.read_rtc0_evtenset()?.to_ne_bytes();
                    if _start <= 836 && _end > 836 {
                        _buf[(836 - _start) as usize] = _value[0];
                    }
                    if _start <= 837 && _end > 837 {
                        _buf[(837 - _start) as usize] = _value[1];
                    }
                    if _start <= 838 && _end > 838 {
                        _buf[(838 - _start) as usize] = _value[2];
                    }
                    if _start <= 839 && _end > 839 {
                        _buf[(839 - _start) as usize] = _value[3];
                    }
                }
                if _start < 844 && _end > 840 {
                    let _value = self.read_rtc0_evtenclr()?.to_ne_bytes();
                    if _start <= 840 && _end > 840 {
                        _buf[(840 - _start) as usize] = _value[0];
                    }
                    if _start <= 841 && _end > 841 {
                        _buf[(841 - _start) as usize] = _value[1];
                    }
                    if _start <= 842 && _end > 842 {
                        _buf[(842 - _start) as usize] = _value[2];
                    }
                    if _start <= 843 && _end > 843 {
                        _buf[(843 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_rtc0_counter()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_rtc0_prescaler()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_rtc0_ccn(0)?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_rtc0_ccn(1)?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_rtc0_ccn(2)?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self.read_rtc0_ccn(3)?.to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073786880;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for RTC0 TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for RTC0 TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for RTC0 TASKS_CLEAR not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_tasks_clear(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert ! (_start <= 12 && _end >= 16u64 , "partial write for RTC0 TASKS_TRIGOVRFLW not implemented" ,);
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_tasks_trigovrflw(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for RTC0 EVENTS_TICK not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_tick(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for RTC0 EVENTS_OVRFLW not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_ovrflw(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (320..=335, 321..=336) => {
                if _start < 324 && _end > 320 {
                    assert ! (_start <= 320 && _end >= 324u64 , "partial write for RTC0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(320) as usize;
                    let end =
                        (_end.saturating_sub(320) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_comparen(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 328 && _end > 324 {
                    assert ! (_start <= 324 && _end >= 328u64 , "partial write for RTC0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(324) as usize;
                    let end =
                        (_end.saturating_sub(324) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_comparen(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 332 && _end > 328 {
                    assert ! (_start <= 328 && _end >= 332u64 , "partial write for RTC0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(328) as usize;
                    let end =
                        (_end.saturating_sub(328) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_comparen(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 336 && _end > 332 {
                    assert ! (_start <= 332 && _end >= 336u64 , "partial write for RTC0 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(332) as usize;
                    let end =
                        (_end.saturating_sub(332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rtc0_events_comparen(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_rtc0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_rtc0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (832..=843, 833..=844) => {
                if _start < 836 && _end > 832 {
                    let offset = _start.saturating_sub(832);
                    let start = 832u64.saturating_sub(_start) as usize;
                    let end = ((_end - 832) - offset) as usize;
                    self.write_rtc0_evten(offset, &_buf[start..end])?;
                }
                if _start < 840 && _end > 836 {
                    let offset = _start.saturating_sub(836);
                    let start = 836u64.saturating_sub(_start) as usize;
                    let end = ((_end - 836) - offset) as usize;
                    self.write_rtc0_evtenset(offset, &_buf[start..end])?;
                }
                if _start < 844 && _end > 840 {
                    let offset = _start.saturating_sub(840);
                    let start = 840u64.saturating_sub(_start) as usize;
                    let end = ((_end - 840) - offset) as usize;
                    self.write_rtc0_evtenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_rtc0_prescaler(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    let offset = _start.saturating_sub(1344);
                    let start = 1344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1344) - offset) as usize;
                    self.write_rtc0_ccn(0, offset, &_buf[start..end])?;
                }
                if _start < 1352 && _end > 1348 {
                    let offset = _start.saturating_sub(1348);
                    let start = 1348u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1348) - offset) as usize;
                    self.write_rtc0_ccn(1, offset, &_buf[start..end])?;
                }
                if _start < 1356 && _end > 1352 {
                    let offset = _start.saturating_sub(1352);
                    let start = 1352u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1352) - offset) as usize;
                    self.write_rtc0_ccn(2, offset, &_buf[start..end])?;
                }
                if _start < 1360 && _end > 1356 {
                    let offset = _start.saturating_sub(1356);
                    let start = 1356u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1356) - offset) as usize;
                    self.write_rtc0_ccn(3, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000B000 {
    fn read_rtc0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_intenset_tick()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_ovrflw()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenset_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_rtc0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenset_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_intenclr_tick()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_ovrflw()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_intenclr_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_rtc0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_intenclr_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_evten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evten_tick()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evten_ovrflw()?) << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evten_compare0()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evten_compare1()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evten_compare2()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evten_compare3()?)
            << 19u32;
        Ok(_value)
    }
    fn write_rtc0_evten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evten_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_evtenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evtenset_tick()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_ovrflw()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenset_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_rtc0_evtenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenset_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_evtenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_tick()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_ovrflw()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_evtenclr_compare3()?)
                << 19u32;
        Ok(_value)
    }
    fn write_rtc0_evtenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_tick((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_ovrflw((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rtc0_evtenclr_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rtc0_counter(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_counter_counter()?)
                << 0u32;
        Ok(_value)
    }
    fn read_rtc0_prescaler(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_prescaler_prescaler()?)
                << 0u32;
        Ok(_value)
    }
    fn write_rtc0_prescaler(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 15u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_rtc0_prescaler_prescaler(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_rtc0_ccn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rtc0_ccn_compare(_dim)?)
                << 0u32;
        Ok(_value)
    }
    fn write_rtc0_ccn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0
                .lock()
                .unwrap()
                .write_rtc0_ccn_compare(_dim, _value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000C000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000C000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073790976;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_temp_events_datardy()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_temp_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_temp_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1288..=1291, 1289..=1292) => {
                if _start < 1292 && _end > 1288 {
                    let _value =
                        self.0.lock().unwrap().read_temp_temp()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1312..=1335, 1313..=1336) => {
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_temp_a0()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_temp_a1()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_temp_a2()?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _value = self.read_temp_a3()?.to_ne_bytes();
                    if _start <= 1324 && _end > 1324 {
                        _buf[(1324 - _start) as usize] = _value[0];
                    }
                    if _start <= 1325 && _end > 1325 {
                        _buf[(1325 - _start) as usize] = _value[1];
                    }
                    if _start <= 1326 && _end > 1326 {
                        _buf[(1326 - _start) as usize] = _value[2];
                    }
                    if _start <= 1327 && _end > 1327 {
                        _buf[(1327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _value = self.read_temp_a4()?.to_ne_bytes();
                    if _start <= 1328 && _end > 1328 {
                        _buf[(1328 - _start) as usize] = _value[0];
                    }
                    if _start <= 1329 && _end > 1329 {
                        _buf[(1329 - _start) as usize] = _value[1];
                    }
                    if _start <= 1330 && _end > 1330 {
                        _buf[(1330 - _start) as usize] = _value[2];
                    }
                    if _start <= 1331 && _end > 1331 {
                        _buf[(1331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _value = self.read_temp_a5()?.to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1367, 1345..=1368) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_temp_b0()?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_temp_b1()?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_temp_b2()?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self.read_temp_b3()?.to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value = self.read_temp_b4()?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _value = self.read_temp_b5()?.to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1376..=1395, 1377..=1396) => {
                if _start < 1380 && _end > 1376 {
                    let _value = self.read_temp_t0()?.to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1384 && _end > 1380 {
                    let _value = self.read_temp_t1()?.to_ne_bytes();
                    if _start <= 1380 && _end > 1380 {
                        _buf[(1380 - _start) as usize] = _value[0];
                    }
                    if _start <= 1381 && _end > 1381 {
                        _buf[(1381 - _start) as usize] = _value[1];
                    }
                    if _start <= 1382 && _end > 1382 {
                        _buf[(1382 - _start) as usize] = _value[2];
                    }
                    if _start <= 1383 && _end > 1383 {
                        _buf[(1383 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1388 && _end > 1384 {
                    let _value = self.read_temp_t2()?.to_ne_bytes();
                    if _start <= 1384 && _end > 1384 {
                        _buf[(1384 - _start) as usize] = _value[0];
                    }
                    if _start <= 1385 && _end > 1385 {
                        _buf[(1385 - _start) as usize] = _value[1];
                    }
                    if _start <= 1386 && _end > 1386 {
                        _buf[(1386 - _start) as usize] = _value[2];
                    }
                    if _start <= 1387 && _end > 1387 {
                        _buf[(1387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1392 && _end > 1388 {
                    let _value = self.read_temp_t3()?.to_ne_bytes();
                    if _start <= 1388 && _end > 1388 {
                        _buf[(1388 - _start) as usize] = _value[0];
                    }
                    if _start <= 1389 && _end > 1389 {
                        _buf[(1389 - _start) as usize] = _value[1];
                    }
                    if _start <= 1390 && _end > 1390 {
                        _buf[(1390 - _start) as usize] = _value[2];
                    }
                    if _start <= 1391 && _end > 1391 {
                        _buf[(1391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1396 && _end > 1392 {
                    let _value = self.read_temp_t4()?.to_ne_bytes();
                    if _start <= 1392 && _end > 1392 {
                        _buf[(1392 - _start) as usize] = _value[0];
                    }
                    if _start <= 1393 && _end > 1393 {
                        _buf[(1393 - _start) as usize] = _value[1];
                    }
                    if _start <= 1394 && _end > 1394 {
                        _buf[(1394 - _start) as usize] = _value[2];
                    }
                    if _start <= 1395 && _end > 1395 {
                        _buf[(1395 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073790976;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for TEMP TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_temp_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for TEMP TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_temp_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for TEMP EVENTS_DATARDY not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_temp_events_datardy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_temp_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_temp_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1288..=1291, 1289..=1292) => {
                if _start < 1292 && _end > 1288 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1312..=1335, 1313..=1336) => {
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_temp_a0(offset, &_buf[start..end])?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_temp_a1(offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = _start.saturating_sub(1320);
                    let start = 1320u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1320) - offset) as usize;
                    self.write_temp_a2(offset, &_buf[start..end])?;
                }
                if _start < 1328 && _end > 1324 {
                    let offset = _start.saturating_sub(1324);
                    let start = 1324u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1324) - offset) as usize;
                    self.write_temp_a3(offset, &_buf[start..end])?;
                }
                if _start < 1332 && _end > 1328 {
                    let offset = _start.saturating_sub(1328);
                    let start = 1328u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1328) - offset) as usize;
                    self.write_temp_a4(offset, &_buf[start..end])?;
                }
                if _start < 1336 && _end > 1332 {
                    let offset = _start.saturating_sub(1332);
                    let start = 1332u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1332) - offset) as usize;
                    self.write_temp_a5(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1367, 1345..=1368) => {
                if _start < 1348 && _end > 1344 {
                    let offset = _start.saturating_sub(1344);
                    let start = 1344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1344) - offset) as usize;
                    self.write_temp_b0(offset, &_buf[start..end])?;
                }
                if _start < 1352 && _end > 1348 {
                    let offset = _start.saturating_sub(1348);
                    let start = 1348u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1348) - offset) as usize;
                    self.write_temp_b1(offset, &_buf[start..end])?;
                }
                if _start < 1356 && _end > 1352 {
                    let offset = _start.saturating_sub(1352);
                    let start = 1352u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1352) - offset) as usize;
                    self.write_temp_b2(offset, &_buf[start..end])?;
                }
                if _start < 1360 && _end > 1356 {
                    let offset = _start.saturating_sub(1356);
                    let start = 1356u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1356) - offset) as usize;
                    self.write_temp_b3(offset, &_buf[start..end])?;
                }
                if _start < 1364 && _end > 1360 {
                    let offset = _start.saturating_sub(1360);
                    let start = 1360u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1360) - offset) as usize;
                    self.write_temp_b4(offset, &_buf[start..end])?;
                }
                if _start < 1368 && _end > 1364 {
                    let offset = _start.saturating_sub(1364);
                    let start = 1364u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1364) - offset) as usize;
                    self.write_temp_b5(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1376..=1395, 1377..=1396) => {
                if _start < 1380 && _end > 1376 {
                    let offset = _start.saturating_sub(1376);
                    let start = 1376u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1376) - offset) as usize;
                    self.write_temp_t0(offset, &_buf[start..end])?;
                }
                if _start < 1384 && _end > 1380 {
                    let offset = _start.saturating_sub(1380);
                    let start = 1380u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1380) - offset) as usize;
                    self.write_temp_t1(offset, &_buf[start..end])?;
                }
                if _start < 1388 && _end > 1384 {
                    let offset = _start.saturating_sub(1384);
                    let start = 1384u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1384) - offset) as usize;
                    self.write_temp_t2(offset, &_buf[start..end])?;
                }
                if _start < 1392 && _end > 1388 {
                    let offset = _start.saturating_sub(1388);
                    let start = 1388u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1388) - offset) as usize;
                    self.write_temp_t3(offset, &_buf[start..end])?;
                }
                if _start < 1396 && _end > 1392 {
                    let offset = _start.saturating_sub(1392);
                    let start = 1392u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1392) - offset) as usize;
                    self.write_temp_t4(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000C000 {
    fn read_temp_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_temp_intenset_datardy()?)
                << 0u32;
        Ok(_value)
    }
    fn write_temp_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_intenset_datardy((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_temp_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_temp_intenclr_datardy()?)
                << 0u32;
        Ok(_value)
    }
    fn write_temp_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_intenclr_datardy((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_temp_a0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_a0_a0()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_a0(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 15u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_a0_a0(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_a1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_a1_a1()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_a1(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 15u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_a1_a1(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_a2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_a2_a2()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_a2(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 15u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_a2_a2(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_a3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_a3_a3()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_a3(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 15u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_a3_a3(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_a4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_a4_a4()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_a4(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 15u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_a4_a4(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_a5(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_a5_a5()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_a5(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 15u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_a5_a5(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_b0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_b0_b0()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_b0(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 63u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_b0_b0(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_b1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_b1_b1()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_b1(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 63u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_b1_b1(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_b2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_b2_b2()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_b2(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 63u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_b2_b2(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_b3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_b3_b3()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_b3(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 63u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_b3_b3(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_b4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_b4_b4()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_b4(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 63u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_b4_b4(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_b5(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_b5_b5()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_b5(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 63u8)
                as u16)
                << (0 + (1 * 8));
            self.0.lock().unwrap().write_temp_b5_b5(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_temp_t0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_t0_t0()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_t0(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_t0_t0((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_temp_t1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_t1_t1()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_t1(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_t1_t1((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_temp_t2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_t2_t2()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_t2(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_t2_t2((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_temp_t3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_t3_t3()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_t3(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_t3_t3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_temp_t4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_temp_t4_t4()?) << 0u32;
        Ok(_value)
    }
    fn write_temp_t4(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_temp_t4_t4((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000D000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000D000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073795072;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_rng_events_valrdy()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_rng_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_rng_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_rng_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_rng_config()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_rng_value()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073795072;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for RNG TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rng_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for RNG TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rng_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for RNG EVENTS_VALRDY not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_rng_events_valrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_rng_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_rng_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_rng_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_rng_config(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000D000 {
    fn read_rng_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rng_shorts_valrdy_stop()?)
                << 0u32;
        Ok(_value)
    }
    fn write_rng_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_shorts_valrdy_stop((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rng_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rng_intenset_valrdy()?)
            << 0u32;
        Ok(_value)
    }
    fn write_rng_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_intenset_valrdy((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rng_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_rng_intenclr_valrdy()?)
            << 0u32;
        Ok(_value)
    }
    fn write_rng_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_intenclr_valrdy((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rng_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rng_config_dercen()?) << 0u32;
        Ok(_value)
    }
    fn write_rng_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_rng_config_dercen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_rng_value(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_rng_value_value()?) << 0u32;
        Ok(_value)
    }
}
pub(crate) struct PeripheralPage0x4000E000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000E000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073799168;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ecb_events_endecb()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ecb_events_errorecb()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_ecb_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_ecb_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1287, 1285..=1288) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ecb_ecbdataptr()?
                        .to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073799168;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for ECB TASKS_STARTECB not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_tasks_startecb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for ECB TASKS_STOPECB not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_tasks_stopecb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for ECB EVENTS_ENDECB not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_events_endecb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for ECB EVENTS_ERRORECB not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_events_errorecb(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_ecb_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_ecb_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1287, 1285..=1288) => {
                if _start < 1288 && _end > 1284 {
                    assert!(
                        _start <= 1284 && _end >= 1288u64,
                        "partial write for ECB ECBDATAPTR not implemented",
                    );
                    let start = _start.saturating_sub(1284) as usize;
                    let end =
                        (_end.saturating_sub(1284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ecb_ecbdataptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000E000 {
    fn read_ecb_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_ecb_intenset_endecb()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ecb_intenset_errorecb()?)
                << 1u32;
        Ok(_value)
    }
    fn write_ecb_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_intenset_endecb((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_intenset_errorecb((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ecb_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_ecb_intenclr_endecb()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ecb_intenclr_errorecb()?)
                << 1u32;
        Ok(_value)
    }
    fn write_ecb_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_intenclr_endecb((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ecb_intenclr_errorecb((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4000F000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4000F000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073803264;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ccmaar_events_endksgen()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ccmaar_events_endcrypt()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ccmaar_events_error()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_ccm_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_ccmaar_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_ccmaar_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_ccmaar_micstatus()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_ccmaar_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_ccmaar_mode()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ccmaar_cnfptr()?
                        .to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value =
                        self.0.lock().unwrap().read_ccm_inptr()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ccmaar_outptr()?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ccmaar_scratchptr()?
                        .to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073803264;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for CCM TASKS_KSGEN not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccmaar_tasks_ksgen(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for CCM TASKS_CRYPT not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccm_tasks_crypt(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for CCM TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccmaar_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for CCM EVENTS_ENDKSGEN not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccmaar_events_endksgen(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for CCM EVENTS_ENDCRYPT not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccmaar_events_endcrypt(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for CCM EVENTS_ERROR not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccmaar_events_error(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_ccm_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_ccmaar_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_ccmaar_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_ccmaar_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_ccmaar_mode(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    assert!(
                        _start <= 1288 && _end >= 1292u64,
                        "partial write for CCM CNFPTR not implemented",
                    );
                    let start = _start.saturating_sub(1288) as usize;
                    let end =
                        (_end.saturating_sub(1288) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccmaar_cnfptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    assert!(
                        _start <= 1292 && _end >= 1296u64,
                        "partial write for CCM INPTR not implemented",
                    );
                    let start = _start.saturating_sub(1292) as usize;
                    let end =
                        (_end.saturating_sub(1292) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccm_inptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296 && _end >= 1300u64,
                        "partial write for CCM OUTPTR not implemented",
                    );
                    let start = _start.saturating_sub(1296) as usize;
                    let end =
                        (_end.saturating_sub(1296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccmaar_outptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    assert!(
                        _start <= 1300 && _end >= 1304u64,
                        "partial write for CCM SCRATCHPTR not implemented",
                    );
                    let start = _start.saturating_sub(1300) as usize;
                    let end =
                        (_end.saturating_sub(1300) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ccmaar_scratchptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4000F000 {
    fn read_ccm_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccm_shorts_endksgen_crypt()?)
                << 0u32;
        Ok(_value)
    }
    fn write_ccm_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccm_shorts_endksgen_crypt((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ccmaar_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_intenset_endksgen()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_intenset_endcrypt()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_intenset_error()?)
                << 2u32;
        Ok(_value)
    }
    fn write_ccmaar_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_intenset_endksgen((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_intenset_endcrypt((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_intenset_error((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ccmaar_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_intenclr_endksgen()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_intenclr_endcrypt()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_intenclr_error()?)
                << 2u32;
        Ok(_value)
    }
    fn write_ccmaar_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_intenclr_endksgen((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_intenclr_endcrypt((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_intenclr_error((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ccmaar_micstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_ccmaar_micstatus_micstatus()?,
        ) << 0u32;
        Ok(_value)
    }
    fn read_ccmaar_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_enable_enable()?)
                << 0u32;
        Ok(_value)
    }
    fn write_ccmaar_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_enable_enable((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_ccmaar_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_mode_mode()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ccmaar_mode_datarate()?)
                << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_ccmaar_mode_length()?)
            << 24u32;
        Ok(_value)
    }
    fn write_ccmaar_mode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_mode_mode((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_mode_datarate((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ccmaar_mode_length((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40010000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40010000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073807360;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_wdt_events_timeout()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_wdt_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_wdt_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1031, 1025..=1032) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_wdt_runstatus()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1032 && _end > 1028 {
                    let _value = self.read_wdt_reqstatus()?.to_ne_bytes();
                    if _start <= 1028 && _end > 1028 {
                        _buf[(1028 - _start) as usize] = _value[0];
                    }
                    if _start <= 1029 && _end > 1029 {
                        _buf[(1029 - _start) as usize] = _value[1];
                    }
                    if _start <= 1030 && _end > 1030 {
                        _buf[(1030 - _start) as usize] = _value[2];
                    }
                    if _start <= 1031 && _end > 1031 {
                        _buf[(1031 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1295, 1285..=1296) => {
                if _start < 1288 && _end > 1284 {
                    let _value =
                        self.0.lock().unwrap().read_wdt_crv()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_wdt_rren()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_wdt_config()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1536..=1567, 1537..=1568) => {
                if _start < 1540 && _end > 1536 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1544 && _end > 1540 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1548 && _end > 1544 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1552 && _end > 1548 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1556 && _end > 1552 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1560 && _end > 1556 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1564 && _end > 1560 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1568 && _end > 1564 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073807360;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for WDT TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for WDT EVENTS_TIMEOUT not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_events_timeout(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_wdt_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_wdt_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1031, 1025..=1032) => {
                if _start < 1028 && _end > 1024 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1032 && _end > 1028 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1284..=1295, 1285..=1296) => {
                if _start < 1288 && _end > 1284 {
                    assert!(
                        _start <= 1284 && _end >= 1288u64,
                        "partial write for WDT CRV not implemented",
                    );
                    let start = _start.saturating_sub(1284) as usize;
                    let end =
                        (_end.saturating_sub(1284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_crv(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_wdt_rren(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_wdt_config(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1536..=1567, 1537..=1568) => {
                if _start < 1540 && _end > 1536 {
                    assert!(
                        _start <= 1536 && _end >= 1540u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1536) as usize;
                    let end =
                        (_end.saturating_sub(1536) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1544 && _end > 1540 {
                    assert!(
                        _start <= 1540 && _end >= 1544u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1540) as usize;
                    let end =
                        (_end.saturating_sub(1540) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1548 && _end > 1544 {
                    assert!(
                        _start <= 1544 && _end >= 1548u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1544) as usize;
                    let end =
                        (_end.saturating_sub(1544) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1552 && _end > 1548 {
                    assert!(
                        _start <= 1548 && _end >= 1552u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1548) as usize;
                    let end =
                        (_end.saturating_sub(1548) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1556 && _end > 1552 {
                    assert!(
                        _start <= 1552 && _end >= 1556u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1552) as usize;
                    let end =
                        (_end.saturating_sub(1552) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1560 && _end > 1556 {
                    assert!(
                        _start <= 1556 && _end >= 1560u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1556) as usize;
                    let end =
                        (_end.saturating_sub(1556) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1564 && _end > 1560 {
                    assert!(
                        _start <= 1560 && _end >= 1564u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1560) as usize;
                    let end =
                        (_end.saturating_sub(1560) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1568 && _end > 1564 {
                    assert!(
                        _start <= 1564 && _end >= 1568u64,
                        "partial write for WDT RR[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1564) as usize;
                    let end =
                        (_end.saturating_sub(1564) as usize).min(start + 4);
                    self.0.lock().unwrap().write_wdt_rrn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40010000 {
    fn read_wdt_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_intenset_timeout()?)
                << 0u32;
        Ok(_value)
    }
    fn write_wdt_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_intenset_timeout((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_wdt_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_intenclr_timeout()?)
                << 0u32;
        Ok(_value)
    }
    fn write_wdt_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_intenclr_timeout((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_wdt_runstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_runstatus_runstatus()?)
                << 0u32;
        Ok(_value)
    }
    fn read_wdt_reqstatus(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_reqstatus_rr7()?) << 7u32;
        Ok(_value)
    }
    fn read_wdt_rren(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_rren_rr7()?) << 7u32;
        Ok(_value)
    }
    fn write_wdt_rren(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_rren_rr7((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_wdt_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_config_sleep()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_wdt_config_halt()?) << 3u32;
        Ok(_value)
    }
    fn write_wdt_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_config_sleep((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_wdt_config_halt((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40012000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40012000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073815552;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=275, 257..=276) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_events_samplerdy()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_events_reportrdy()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_events_accof()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_events_dblrdy()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_events_stopped()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_qdec_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_qdec_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_qdec_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_qdec_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_qdec_ledpol()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_qdec_sampleper()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_sample()?
                        .to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_qdec_reportper()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value =
                        self.0.lock().unwrap().read_qdec_acc()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_qdec_accread()?
                        .to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_qdec_psel_led()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_qdec_psel_a()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_qdec_psel_b()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_qdec_dbfen()?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1355, 1345..=1356) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_qdec_ledpre()?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_qdec_accdbl()?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_qdec_accdblread()?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073815552;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for QDEC TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for QDEC TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert ! (_start <= 8 && _end >= 12u64 , "partial write for QDEC TASKS_READCLRACC not implemented" ,);
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_tasks_readclracc(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12 && _end >= 16u64,
                        "partial write for QDEC TASKS_RDCLRACC not implemented",
                    );
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_tasks_rdclracc(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16 && _end >= 20u64,
                        "partial write for QDEC TASKS_RDCLRDBL not implemented",
                    );
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_tasks_rdclrdbl(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=275, 257..=276) => {
                if _start < 260 && _end > 256 {
                    assert ! (_start <= 256 && _end >= 260u64 , "partial write for QDEC EVENTS_SAMPLERDY not implemented" ,);
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_events_samplerdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260 && _end >= 264u64 , "partial write for QDEC EVENTS_REPORTRDY not implemented" ,);
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_events_reportrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for QDEC EVENTS_ACCOF not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_events_accof(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268 && _end >= 272u64,
                        "partial write for QDEC EVENTS_DBLRDY not implemented",
                    );
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_events_dblrdy(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272 && _end >= 276u64,
                        "partial write for QDEC EVENTS_STOPPED not implemented",
                    );
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_qdec_events_stopped(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_qdec_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_qdec_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_qdec_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_qdec_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_qdec_ledpol(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_qdec_sampleper(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_qdec_reportper(offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_qdec_psel_led(offset, &_buf[start..end])?;
                }
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_qdec_psel_a(offset, &_buf[start..end])?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_qdec_psel_b(offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = _start.saturating_sub(1320);
                    let start = 1320u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1320) - offset) as usize;
                    self.write_qdec_dbfen(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1355, 1345..=1356) => {
                if _start < 1348 && _end > 1344 {
                    let offset = _start.saturating_sub(1344);
                    let start = 1344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1344) - offset) as usize;
                    self.write_qdec_ledpre(offset, &_buf[start..end])?;
                }
                if _start < 1352 && _end > 1348 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1356 && _end > 1352 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40012000 {
    fn read_qdec_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_qdec_shorts_reportrdy_readclracc()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_qdec_shorts_samplerdy_stop()?,
        ) << 1u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_qdec_shorts_reportrdy_rdclracc()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_qdec_shorts_reportrdy_stop()?,
        ) << 3u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_qdec_shorts_dblrdy_rdclrdbl()?,
        ) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_shorts_dblrdy_stop()?)
                << 5u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_qdec_shorts_samplerdy_readclracc()?,
        ) << 6u32;
        Ok(_value)
    }
    fn write_qdec_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_shorts_reportrdy_readclracc(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_shorts_samplerdy_stop((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_shorts_reportrdy_rdclracc(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_shorts_reportrdy_stop((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_qdec_shorts_dblrdy_rdclrdbl(
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_shorts_dblrdy_stop((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_shorts_samplerdy_readclracc(
                    (_value[_i] >> 6) & 1 != 0,
                )?;
        }
        Ok(())
    }
    fn read_qdec_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenset_samplerdy()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenset_reportrdy()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_intenset_accof()?)
            << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenset_dblrdy()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenset_stopped()?)
                << 4u32;
        Ok(_value)
    }
    fn write_qdec_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenset_samplerdy((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenset_reportrdy((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenset_accof((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenset_dblrdy((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenset_stopped((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenclr_samplerdy()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenclr_reportrdy()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_intenclr_accof()?)
            << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenclr_dblrdy()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_intenclr_stopped()?)
                << 4u32;
        Ok(_value)
    }
    fn write_qdec_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenclr_samplerdy((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenclr_reportrdy((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenclr_accof((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenclr_dblrdy((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_intenclr_stopped((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_enable_enable()?)
            << 0u32;
        Ok(_value)
    }
    fn write_qdec_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_enable_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_ledpol(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_ledpol_ledpol()?)
            << 0u32;
        Ok(_value)
    }
    fn write_qdec_ledpol(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_ledpol_ledpol((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_sampleper(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_sampleper_sampleper()?)
                << 0u32;
        Ok(_value)
    }
    fn write_qdec_sampleper(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_sampleper_sampleper((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
    fn read_qdec_reportper(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_reportper_reportper()?)
                << 0u32;
        Ok(_value)
    }
    fn write_qdec_reportper(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_reportper_reportper((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
    fn read_qdec_psel_led(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_psel_led_pin()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_psel_led_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_qdec_psel_led(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_psel_led_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_psel_led_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_psel_a(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_psel_a_pin()?) << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_psel_a_connect()?)
            << 31u32;
        Ok(_value)
    }
    fn write_qdec_psel_a(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_psel_a_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_psel_a_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_psel_b(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_psel_b_pin()?) << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_psel_b_connect()?)
            << 31u32;
        Ok(_value)
    }
    fn write_qdec_psel_b(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_psel_b_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_psel_b_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_dbfen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_qdec_dbfen_dbfen()?) << 0u32;
        Ok(_value)
    }
    fn write_qdec_dbfen(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_qdec_dbfen_dbfen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_qdec_ledpre(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_ledpre_ledpre()?)
            << 0u32;
        Ok(_value)
    }
    fn write_qdec_ledpre(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 1u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_qdec_ledpre_ledpre(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_qdec_accdbl(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_qdec_accdbl_accdbl()?)
            << 0u32;
        Ok(_value)
    }
    fn read_qdec_accdblread(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_qdec_accdblread_accdblread()?,
        ) << 0u32;
        Ok(_value)
    }
}
pub(crate) struct PeripheralPage0x40013000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40013000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073819648;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=271, 257..=272) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_complpcomp_events_ready()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_complpcomp_events_down()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_complpcomp_events_up()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_complpcomp_events_cross()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_complpcomp_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_comp_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self.read_complpcomp_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_complpcomp_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_complpcomp_result()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1295, 1281..=1296) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_complpcomp_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_complpcomp_psel()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_complpcomp_refsel()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value =
                        self.read_complpcomp_extrefsel()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1312..=1315, 1313..=1316) => {
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_lpcomp_anadetect()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1328..=1343, 1329..=1344) => {
                if _start < 1332 && _end > 1328 {
                    let _value = self.read_comp_th()?.to_ne_bytes();
                    if _start <= 1328 && _end > 1328 {
                        _buf[(1328 - _start) as usize] = _value[0];
                    }
                    if _start <= 1329 && _end > 1329 {
                        _buf[(1329 - _start) as usize] = _value[1];
                    }
                    if _start <= 1330 && _end > 1330 {
                        _buf[(1330 - _start) as usize] = _value[2];
                    }
                    if _start <= 1331 && _end > 1331 {
                        _buf[(1331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _value = self.read_comp_mode()?.to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _value = self.read_complpcomp_hyst()?.to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _value = self.read_comp_isource()?.to_ne_bytes();
                    if _start <= 1340 && _end > 1340 {
                        _buf[(1340 - _start) as usize] = _value[0];
                    }
                    if _start <= 1341 && _end > 1341 {
                        _buf[(1341 - _start) as usize] = _value[1];
                    }
                    if _start <= 1342 && _end > 1342 {
                        _buf[(1342 - _start) as usize] = _value[2];
                    }
                    if _start <= 1343 && _end > 1343 {
                        _buf[(1343 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073819648;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for COMP TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_complpcomp_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for COMP TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_complpcomp_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for COMP TASKS_SAMPLE not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_complpcomp_tasks_sample(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=271, 257..=272) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for COMP EVENTS_READY not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_complpcomp_events_ready(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for COMP EVENTS_DOWN not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_complpcomp_events_down(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for COMP EVENTS_UP not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_complpcomp_events_up(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268 && _end >= 272u64,
                        "partial write for COMP EVENTS_CROSS not implemented",
                    );
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_complpcomp_events_cross(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_complpcomp_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_comp_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_complpcomp_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_complpcomp_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1280..=1295, 1281..=1296) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_complpcomp_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_complpcomp_psel(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_complpcomp_refsel(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_complpcomp_extrefsel(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1312..=1315, 1313..=1316) => {
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_lpcomp_anadetect(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1328..=1343, 1329..=1344) => {
                if _start < 1332 && _end > 1328 {
                    let offset = _start.saturating_sub(1328);
                    let start = 1328u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1328) - offset) as usize;
                    self.write_comp_th(offset, &_buf[start..end])?;
                }
                if _start < 1336 && _end > 1332 {
                    let offset = _start.saturating_sub(1332);
                    let start = 1332u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1332) - offset) as usize;
                    self.write_comp_mode(offset, &_buf[start..end])?;
                }
                if _start < 1340 && _end > 1336 {
                    let offset = _start.saturating_sub(1336);
                    let start = 1336u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1336) - offset) as usize;
                    self.write_complpcomp_hyst(offset, &_buf[start..end])?;
                }
                if _start < 1344 && _end > 1340 {
                    let offset = _start.saturating_sub(1340);
                    let start = 1340u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1340) - offset) as usize;
                    self.write_comp_isource(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40013000 {
    fn read_complpcomp_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_complpcomp_shorts_ready_sample()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_complpcomp_shorts_ready_stop()?,
        ) << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_complpcomp_shorts_down_stop()?,
        ) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_shorts_up_stop()?)
                << 3u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_complpcomp_shorts_cross_stop()?,
        ) << 4u32;
        Ok(_value)
    }
    fn write_complpcomp_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_shorts_ready_sample(
                    (_value[_i] >> 0) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_complpcomp_shorts_ready_stop(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_complpcomp_shorts_down_stop(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_shorts_up_stop((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_complpcomp_shorts_cross_stop(
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_comp_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_inten_ready()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_inten_down()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_inten_up()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_inten_cross()?) << 3u32;
        Ok(_value)
    }
    fn write_comp_inten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_inten_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_inten_down((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_inten_up((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_inten_cross((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_complpcomp_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_intenset_ready()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_intenset_down()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_intenset_up()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_intenset_cross()?)
                << 3u32;
        Ok(_value)
    }
    fn write_complpcomp_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_intenset_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_intenset_down((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_intenset_up((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_intenset_cross((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_complpcomp_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_intenclr_ready()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_intenclr_down()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_intenclr_up()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_intenclr_cross()?)
                << 3u32;
        Ok(_value)
    }
    fn write_complpcomp_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_intenclr_ready((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_intenclr_down((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_intenclr_up((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_intenclr_cross((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_complpcomp_result(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_result_result()?)
                << 0u32;
        Ok(_value)
    }
    fn read_complpcomp_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_enable_enable()?)
                << 0u32;
        Ok(_value)
    }
    fn write_complpcomp_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_enable_enable((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_complpcomp_psel(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_psel_psel()?)
                << 0u32;
        Ok(_value)
    }
    fn write_complpcomp_psel(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_psel_psel((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_complpcomp_refsel(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_refsel_refsel()?)
                << 0u32;
        Ok(_value)
    }
    fn write_complpcomp_refsel(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_refsel_refsel((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_complpcomp_extrefsel(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_complpcomp_extrefsel_extrefsel()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_complpcomp_extrefsel(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_extrefsel_extrefsel(
                    (_value[_i] >> 0) & 7u8,
                )?;
        }
        Ok(())
    }
    fn read_lpcomp_anadetect(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_lpcomp_anadetect_anadetect()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_lpcomp_anadetect(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_lpcomp_anadetect_anadetect((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_comp_th(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_th_thdown()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_th_thup()?) << 8u32;
        Ok(_value)
    }
    fn write_comp_th(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_th_thdown((_value[_i] >> 0) & 63u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_th_thup((_value[_i] >> 0) & 63u8)?;
        }
        Ok(())
    }
    fn read_comp_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_mode_sp()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_mode_main()?) << 8u32;
        Ok(_value)
    }
    fn write_comp_mode(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_mode_sp((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_mode_main((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_complpcomp_hyst(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_complpcomp_hyst_hyst()?)
                << 0u32;
        Ok(_value)
    }
    fn write_complpcomp_hyst(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_complpcomp_hyst_hyst((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_comp_isource(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_comp_isource_isource()?)
                << 0u32;
        Ok(_value)
    }
    fn write_comp_isource(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_comp_isource_isource((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40014000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40014000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073823744;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=63, 1..=64) => {
                if _start < 4 && _end > 0 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(0)?
                        .to_ne_bytes();
                    if _start <= 0 && _end > 0 {
                        _buf[(0 - _start) as usize] = _value[0];
                    }
                    if _start <= 1 && _end > 1 {
                        _buf[(1 - _start) as usize] = _value[1];
                    }
                    if _start <= 2 && _end > 2 {
                        _buf[(2 - _start) as usize] = _value[2];
                    }
                    if _start <= 3 && _end > 3 {
                        _buf[(3 - _start) as usize] = _value[3];
                    }
                }
                if _start < 8 && _end > 4 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(1)?
                        .to_ne_bytes();
                    if _start <= 4 && _end > 4 {
                        _buf[(4 - _start) as usize] = _value[0];
                    }
                    if _start <= 5 && _end > 5 {
                        _buf[(5 - _start) as usize] = _value[1];
                    }
                    if _start <= 6 && _end > 6 {
                        _buf[(6 - _start) as usize] = _value[2];
                    }
                    if _start <= 7 && _end > 7 {
                        _buf[(7 - _start) as usize] = _value[3];
                    }
                }
                if _start < 12 && _end > 8 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(2)?
                        .to_ne_bytes();
                    if _start <= 8 && _end > 8 {
                        _buf[(8 - _start) as usize] = _value[0];
                    }
                    if _start <= 9 && _end > 9 {
                        _buf[(9 - _start) as usize] = _value[1];
                    }
                    if _start <= 10 && _end > 10 {
                        _buf[(10 - _start) as usize] = _value[2];
                    }
                    if _start <= 11 && _end > 11 {
                        _buf[(11 - _start) as usize] = _value[3];
                    }
                }
                if _start < 16 && _end > 12 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(3)?
                        .to_ne_bytes();
                    if _start <= 12 && _end > 12 {
                        _buf[(12 - _start) as usize] = _value[0];
                    }
                    if _start <= 13 && _end > 13 {
                        _buf[(13 - _start) as usize] = _value[1];
                    }
                    if _start <= 14 && _end > 14 {
                        _buf[(14 - _start) as usize] = _value[2];
                    }
                    if _start <= 15 && _end > 15 {
                        _buf[(15 - _start) as usize] = _value[3];
                    }
                }
                if _start < 20 && _end > 16 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(4)?
                        .to_ne_bytes();
                    if _start <= 16 && _end > 16 {
                        _buf[(16 - _start) as usize] = _value[0];
                    }
                    if _start <= 17 && _end > 17 {
                        _buf[(17 - _start) as usize] = _value[1];
                    }
                    if _start <= 18 && _end > 18 {
                        _buf[(18 - _start) as usize] = _value[2];
                    }
                    if _start <= 19 && _end > 19 {
                        _buf[(19 - _start) as usize] = _value[3];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(5)?
                        .to_ne_bytes();
                    if _start <= 20 && _end > 20 {
                        _buf[(20 - _start) as usize] = _value[0];
                    }
                    if _start <= 21 && _end > 21 {
                        _buf[(21 - _start) as usize] = _value[1];
                    }
                    if _start <= 22 && _end > 22 {
                        _buf[(22 - _start) as usize] = _value[2];
                    }
                    if _start <= 23 && _end > 23 {
                        _buf[(23 - _start) as usize] = _value[3];
                    }
                }
                if _start < 28 && _end > 24 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(6)?
                        .to_ne_bytes();
                    if _start <= 24 && _end > 24 {
                        _buf[(24 - _start) as usize] = _value[0];
                    }
                    if _start <= 25 && _end > 25 {
                        _buf[(25 - _start) as usize] = _value[1];
                    }
                    if _start <= 26 && _end > 26 {
                        _buf[(26 - _start) as usize] = _value[2];
                    }
                    if _start <= 27 && _end > 27 {
                        _buf[(27 - _start) as usize] = _value[3];
                    }
                }
                if _start < 32 && _end > 28 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(7)?
                        .to_ne_bytes();
                    if _start <= 28 && _end > 28 {
                        _buf[(28 - _start) as usize] = _value[0];
                    }
                    if _start <= 29 && _end > 29 {
                        _buf[(29 - _start) as usize] = _value[1];
                    }
                    if _start <= 30 && _end > 30 {
                        _buf[(30 - _start) as usize] = _value[2];
                    }
                    if _start <= 31 && _end > 31 {
                        _buf[(31 - _start) as usize] = _value[3];
                    }
                }
                if _start < 36 && _end > 32 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(8)?
                        .to_ne_bytes();
                    if _start <= 32 && _end > 32 {
                        _buf[(32 - _start) as usize] = _value[0];
                    }
                    if _start <= 33 && _end > 33 {
                        _buf[(33 - _start) as usize] = _value[1];
                    }
                    if _start <= 34 && _end > 34 {
                        _buf[(34 - _start) as usize] = _value[2];
                    }
                    if _start <= 35 && _end > 35 {
                        _buf[(35 - _start) as usize] = _value[3];
                    }
                }
                if _start < 40 && _end > 36 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(9)?
                        .to_ne_bytes();
                    if _start <= 36 && _end > 36 {
                        _buf[(36 - _start) as usize] = _value[0];
                    }
                    if _start <= 37 && _end > 37 {
                        _buf[(37 - _start) as usize] = _value[1];
                    }
                    if _start <= 38 && _end > 38 {
                        _buf[(38 - _start) as usize] = _value[2];
                    }
                    if _start <= 39 && _end > 39 {
                        _buf[(39 - _start) as usize] = _value[3];
                    }
                }
                if _start < 44 && _end > 40 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(10)?
                        .to_ne_bytes();
                    if _start <= 40 && _end > 40 {
                        _buf[(40 - _start) as usize] = _value[0];
                    }
                    if _start <= 41 && _end > 41 {
                        _buf[(41 - _start) as usize] = _value[1];
                    }
                    if _start <= 42 && _end > 42 {
                        _buf[(42 - _start) as usize] = _value[2];
                    }
                    if _start <= 43 && _end > 43 {
                        _buf[(43 - _start) as usize] = _value[3];
                    }
                }
                if _start < 48 && _end > 44 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(11)?
                        .to_ne_bytes();
                    if _start <= 44 && _end > 44 {
                        _buf[(44 - _start) as usize] = _value[0];
                    }
                    if _start <= 45 && _end > 45 {
                        _buf[(45 - _start) as usize] = _value[1];
                    }
                    if _start <= 46 && _end > 46 {
                        _buf[(46 - _start) as usize] = _value[2];
                    }
                    if _start <= 47 && _end > 47 {
                        _buf[(47 - _start) as usize] = _value[3];
                    }
                }
                if _start < 52 && _end > 48 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(12)?
                        .to_ne_bytes();
                    if _start <= 48 && _end > 48 {
                        _buf[(48 - _start) as usize] = _value[0];
                    }
                    if _start <= 49 && _end > 49 {
                        _buf[(49 - _start) as usize] = _value[1];
                    }
                    if _start <= 50 && _end > 50 {
                        _buf[(50 - _start) as usize] = _value[2];
                    }
                    if _start <= 51 && _end > 51 {
                        _buf[(51 - _start) as usize] = _value[3];
                    }
                }
                if _start < 56 && _end > 52 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(13)?
                        .to_ne_bytes();
                    if _start <= 52 && _end > 52 {
                        _buf[(52 - _start) as usize] = _value[0];
                    }
                    if _start <= 53 && _end > 53 {
                        _buf[(53 - _start) as usize] = _value[1];
                    }
                    if _start <= 54 && _end > 54 {
                        _buf[(54 - _start) as usize] = _value[2];
                    }
                    if _start <= 55 && _end > 55 {
                        _buf[(55 - _start) as usize] = _value[3];
                    }
                }
                if _start < 60 && _end > 56 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(14)?
                        .to_ne_bytes();
                    if _start <= 56 && _end > 56 {
                        _buf[(56 - _start) as usize] = _value[0];
                    }
                    if _start <= 57 && _end > 57 {
                        _buf[(57 - _start) as usize] = _value[1];
                    }
                    if _start <= 58 && _end > 58 {
                        _buf[(58 - _start) as usize] = _value[2];
                    }
                    if _start <= 59 && _end > 59 {
                        _buf[(59 - _start) as usize] = _value[3];
                    }
                }
                if _start < 64 && _end > 60 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_swi0egu0_unused(15)?
                        .to_ne_bytes();
                    if _start <= 60 && _end > 60 {
                        _buf[(60 - _start) as usize] = _value[0];
                    }
                    if _start <= 61 && _end > 61 {
                        _buf[(61 - _start) as usize] = _value[1];
                    }
                    if _start <= 62 && _end > 62 {
                        _buf[(62 - _start) as usize] = _value[2];
                    }
                    if _start <= 63 && _end > 63 {
                        _buf[(63 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (256..=319, 257..=320) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(0)?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(1)?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(2)?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(3)?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(4)?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(5)?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(6)?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(7)?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 292 && _end > 288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(8)?
                        .to_ne_bytes();
                    if _start <= 288 && _end > 288 {
                        _buf[(288 - _start) as usize] = _value[0];
                    }
                    if _start <= 289 && _end > 289 {
                        _buf[(289 - _start) as usize] = _value[1];
                    }
                    if _start <= 290 && _end > 290 {
                        _buf[(290 - _start) as usize] = _value[2];
                    }
                    if _start <= 291 && _end > 291 {
                        _buf[(291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 296 && _end > 292 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(9)?
                        .to_ne_bytes();
                    if _start <= 292 && _end > 292 {
                        _buf[(292 - _start) as usize] = _value[0];
                    }
                    if _start <= 293 && _end > 293 {
                        _buf[(293 - _start) as usize] = _value[1];
                    }
                    if _start <= 294 && _end > 294 {
                        _buf[(294 - _start) as usize] = _value[2];
                    }
                    if _start <= 295 && _end > 295 {
                        _buf[(295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 300 && _end > 296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(10)?
                        .to_ne_bytes();
                    if _start <= 296 && _end > 296 {
                        _buf[(296 - _start) as usize] = _value[0];
                    }
                    if _start <= 297 && _end > 297 {
                        _buf[(297 - _start) as usize] = _value[1];
                    }
                    if _start <= 298 && _end > 298 {
                        _buf[(298 - _start) as usize] = _value[2];
                    }
                    if _start <= 299 && _end > 299 {
                        _buf[(299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 304 && _end > 300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(11)?
                        .to_ne_bytes();
                    if _start <= 300 && _end > 300 {
                        _buf[(300 - _start) as usize] = _value[0];
                    }
                    if _start <= 301 && _end > 301 {
                        _buf[(301 - _start) as usize] = _value[1];
                    }
                    if _start <= 302 && _end > 302 {
                        _buf[(302 - _start) as usize] = _value[2];
                    }
                    if _start <= 303 && _end > 303 {
                        _buf[(303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 308 && _end > 304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(12)?
                        .to_ne_bytes();
                    if _start <= 304 && _end > 304 {
                        _buf[(304 - _start) as usize] = _value[0];
                    }
                    if _start <= 305 && _end > 305 {
                        _buf[(305 - _start) as usize] = _value[1];
                    }
                    if _start <= 306 && _end > 306 {
                        _buf[(306 - _start) as usize] = _value[2];
                    }
                    if _start <= 307 && _end > 307 {
                        _buf[(307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 312 && _end > 308 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(13)?
                        .to_ne_bytes();
                    if _start <= 308 && _end > 308 {
                        _buf[(308 - _start) as usize] = _value[0];
                    }
                    if _start <= 309 && _end > 309 {
                        _buf[(309 - _start) as usize] = _value[1];
                    }
                    if _start <= 310 && _end > 310 {
                        _buf[(310 - _start) as usize] = _value[2];
                    }
                    if _start <= 311 && _end > 311 {
                        _buf[(311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 316 && _end > 312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(14)?
                        .to_ne_bytes();
                    if _start <= 312 && _end > 312 {
                        _buf[(312 - _start) as usize] = _value[0];
                    }
                    if _start <= 313 && _end > 313 {
                        _buf[(313 - _start) as usize] = _value[1];
                    }
                    if _start <= 314 && _end > 314 {
                        _buf[(314 - _start) as usize] = _value[2];
                    }
                    if _start <= 315 && _end > 315 {
                        _buf[(315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 320 && _end > 316 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_egu0_events_triggeredn(15)?
                        .to_ne_bytes();
                    if _start <= 316 && _end > 316 {
                        _buf[(316 - _start) as usize] = _value[0];
                    }
                    if _start <= 317 && _end > 317 {
                        _buf[(317 - _start) as usize] = _value[1];
                    }
                    if _start <= 318 && _end > 318 {
                        _buf[(318 - _start) as usize] = _value[2];
                    }
                    if _start <= 319 && _end > 319 {
                        _buf[(319 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_egu0_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self.read_egu0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_egu0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073823744;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=63, 1..=64) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12 && _end >= 16u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16 && _end >= 20u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert!(
                        _start <= 20 && _end >= 24u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(20) as usize;
                    let end = (_end.saturating_sub(20) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 28 && _end > 24 {
                    assert!(
                        _start <= 24 && _end >= 28u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(24) as usize;
                    let end = (_end.saturating_sub(24) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28 && _end >= 32u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(28) as usize;
                    let end = (_end.saturating_sub(28) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 36 && _end > 32 {
                    assert!(
                        _start <= 32 && _end >= 36u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(32) as usize;
                    let end = (_end.saturating_sub(32) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 40 && _end > 36 {
                    assert!(
                        _start <= 36 && _end >= 40u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(36) as usize;
                    let end = (_end.saturating_sub(36) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 44 && _end > 40 {
                    assert!(
                        _start <= 40 && _end >= 44u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(40) as usize;
                    let end = (_end.saturating_sub(40) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 48 && _end > 44 {
                    assert!(
                        _start <= 44 && _end >= 48u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(44) as usize;
                    let end = (_end.saturating_sub(44) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 52 && _end > 48 {
                    assert!(
                        _start <= 48 && _end >= 52u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(48) as usize;
                    let end = (_end.saturating_sub(48) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 56 && _end > 52 {
                    assert!(
                        _start <= 52 && _end >= 56u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(52) as usize;
                    let end = (_end.saturating_sub(52) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 60 && _end > 56 {
                    assert!(
                        _start <= 56 && _end >= 60u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(56) as usize;
                    let end = (_end.saturating_sub(56) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 64 && _end > 60 {
                    assert!(
                        _start <= 60 && _end >= 64u64,
                        "partial write for SWI0 UNUSED not implemented",
                    );
                    let start = _start.saturating_sub(60) as usize;
                    let end = (_end.saturating_sub(60) as usize).min(start + 4);
                    self.0.lock().unwrap().write_swi0egu0_unused(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=319, 257..=320) => {
                if _start < 260 && _end > 256 {
                    assert ! (_start <= 256 && _end >= 260u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert ! (_start <= 260 && _end >= 264u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264 && _end >= 268u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert ! (_start <= 268 && _end >= 272u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert ! (_start <= 272 && _end >= 276u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert ! (_start <= 276 && _end >= 280u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert ! (_start <= 280 && _end >= 284u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert ! (_start <= 284 && _end >= 288u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 292 && _end > 288 {
                    assert ! (_start <= 288 && _end >= 292u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(288) as usize;
                    let end =
                        (_end.saturating_sub(288) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 296 && _end > 292 {
                    assert ! (_start <= 292 && _end >= 296u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(292) as usize;
                    let end =
                        (_end.saturating_sub(292) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 300 && _end > 296 {
                    assert ! (_start <= 296 && _end >= 300u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(296) as usize;
                    let end =
                        (_end.saturating_sub(296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 304 && _end > 300 {
                    assert ! (_start <= 300 && _end >= 304u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(300) as usize;
                    let end =
                        (_end.saturating_sub(300) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 308 && _end > 304 {
                    assert ! (_start <= 304 && _end >= 308u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(304) as usize;
                    let end =
                        (_end.saturating_sub(304) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 312 && _end > 308 {
                    assert ! (_start <= 308 && _end >= 312u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(308) as usize;
                    let end =
                        (_end.saturating_sub(308) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 316 && _end > 312 {
                    assert ! (_start <= 312 && _end >= 316u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(312) as usize;
                    let end =
                        (_end.saturating_sub(312) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 320 && _end > 316 {
                    assert ! (_start <= 316 && _end >= 320u64 , "partial write for EGU0 EVENTS_TRIGGERED[%s] not implemented" ,);
                    let start = _start.saturating_sub(316) as usize;
                    let end =
                        (_end.saturating_sub(316) as usize).min(start + 4);
                    self.0.lock().unwrap().write_egu0_events_triggeredn(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_egu0_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_egu0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_egu0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40014000 {
    fn read_egu0_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered3()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered4()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered5()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered6()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered7()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered8()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered9()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered10()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered11()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered12()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered13()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered14()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_inten_triggered15()?)
                << 15u32;
        Ok(_value)
    }
    fn write_egu0_inten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_inten_triggered15((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_egu0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered3()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered4()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered5()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered6()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered7()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered8()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered9()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered10()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered11()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered12()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered13()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered14()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenset_triggered15()?)
                << 15u32;
        Ok(_value)
    }
    fn write_egu0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenset_triggered15((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_egu0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered1()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered2()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered3()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered4()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered5()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered6()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered7()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered8()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered9()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered10()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered11()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered12()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered13()?)
                << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered14()?)
                << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_egu0_intenclr_triggered15()?)
                << 15u32;
        Ok(_value)
    }
    fn write_egu0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_egu0_intenclr_triggered15((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4001A000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4001A000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073848320;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (64..=87, 65..=88) => {
                if _start < 68 && _end > 64 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 72 && _end > 68 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 76 && _end > 72 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 80 && _end > 76 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 84 && _end > 80 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 88 && _end > 84 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (320..=343, 321..=344) => {
                if _start < 324 && _end > 320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_events_comparen(0)?
                        .to_ne_bytes();
                    if _start <= 320 && _end > 320 {
                        _buf[(320 - _start) as usize] = _value[0];
                    }
                    if _start <= 321 && _end > 321 {
                        _buf[(321 - _start) as usize] = _value[1];
                    }
                    if _start <= 322 && _end > 322 {
                        _buf[(322 - _start) as usize] = _value[2];
                    }
                    if _start <= 323 && _end > 323 {
                        _buf[(323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 328 && _end > 324 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_events_comparen(1)?
                        .to_ne_bytes();
                    if _start <= 324 && _end > 324 {
                        _buf[(324 - _start) as usize] = _value[0];
                    }
                    if _start <= 325 && _end > 325 {
                        _buf[(325 - _start) as usize] = _value[1];
                    }
                    if _start <= 326 && _end > 326 {
                        _buf[(326 - _start) as usize] = _value[2];
                    }
                    if _start <= 327 && _end > 327 {
                        _buf[(327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 332 && _end > 328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_events_comparen(2)?
                        .to_ne_bytes();
                    if _start <= 328 && _end > 328 {
                        _buf[(328 - _start) as usize] = _value[0];
                    }
                    if _start <= 329 && _end > 329 {
                        _buf[(329 - _start) as usize] = _value[1];
                    }
                    if _start <= 330 && _end > 330 {
                        _buf[(330 - _start) as usize] = _value[2];
                    }
                    if _start <= 331 && _end > 331 {
                        _buf[(331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 336 && _end > 332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_events_comparen(3)?
                        .to_ne_bytes();
                    if _start <= 332 && _end > 332 {
                        _buf[(332 - _start) as usize] = _value[0];
                    }
                    if _start <= 333 && _end > 333 {
                        _buf[(333 - _start) as usize] = _value[1];
                    }
                    if _start <= 334 && _end > 334 {
                        _buf[(334 - _start) as usize] = _value[2];
                    }
                    if _start <= 335 && _end > 335 {
                        _buf[(335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_events_comparen(4)?
                        .to_ne_bytes();
                    if _start <= 336 && _end > 336 {
                        _buf[(336 - _start) as usize] = _value[0];
                    }
                    if _start <= 337 && _end > 337 {
                        _buf[(337 - _start) as usize] = _value[1];
                    }
                    if _start <= 338 && _end > 338 {
                        _buf[(338 - _start) as usize] = _value[2];
                    }
                    if _start <= 339 && _end > 339 {
                        _buf[(339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 344 && _end > 340 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_events_comparen(5)?
                        .to_ne_bytes();
                    if _start <= 340 && _end > 340 {
                        _buf[(340 - _start) as usize] = _value[0];
                    }
                    if _start <= 341 && _end > 341 {
                        _buf[(341 - _start) as usize] = _value[1];
                    }
                    if _start <= 342 && _end > 342 {
                        _buf[(342 - _start) as usize] = _value[2];
                    }
                    if _start <= 343 && _end > 343 {
                        _buf[(343 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_timer3_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _value = self.read_timer3_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_timer3_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_timer3_mode()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_timer3_bitmode()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_timer3_prescaler()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1367, 1345..=1368) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_ccn(0)?
                        .to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_ccn(1)?
                        .to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_ccn(2)?
                        .to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_ccn(3)?
                        .to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_ccn(4)?
                        .to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_timer3_ccn(5)?
                        .to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073848320;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for TIMER3 TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for TIMER3 TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for TIMER3 TASKS_COUNT not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_count(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12 && _end >= 16u64,
                        "partial write for TIMER3 TASKS_CLEAR not implemented",
                    );
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_clear(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert ! (_start <= 16 && _end >= 20u64 , "partial write for TIMER3 TASKS_SHUTDOWN not implemented" ,);
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_shutdown(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (64..=87, 65..=88) => {
                if _start < 68 && _end > 64 {
                    assert ! (_start <= 64 && _end >= 68u64 , "partial write for TIMER3 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(64) as usize;
                    let end = (_end.saturating_sub(64) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_capturen(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 72 && _end > 68 {
                    assert ! (_start <= 68 && _end >= 72u64 , "partial write for TIMER3 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(68) as usize;
                    let end = (_end.saturating_sub(68) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_capturen(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 76 && _end > 72 {
                    assert ! (_start <= 72 && _end >= 76u64 , "partial write for TIMER3 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(72) as usize;
                    let end = (_end.saturating_sub(72) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_capturen(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 80 && _end > 76 {
                    assert ! (_start <= 76 && _end >= 80u64 , "partial write for TIMER3 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(76) as usize;
                    let end = (_end.saturating_sub(76) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_capturen(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 84 && _end > 80 {
                    assert ! (_start <= 80 && _end >= 84u64 , "partial write for TIMER3 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(80) as usize;
                    let end = (_end.saturating_sub(80) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_capturen(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 88 && _end > 84 {
                    assert ! (_start <= 84 && _end >= 88u64 , "partial write for TIMER3 TASKS_CAPTURE[%s] not implemented" ,);
                    let start = _start.saturating_sub(84) as usize;
                    let end = (_end.saturating_sub(84) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_tasks_capturen(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (320..=343, 321..=344) => {
                if _start < 324 && _end > 320 {
                    assert ! (_start <= 320 && _end >= 324u64 , "partial write for TIMER3 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(320) as usize;
                    let end =
                        (_end.saturating_sub(320) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_events_comparen(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 328 && _end > 324 {
                    assert ! (_start <= 324 && _end >= 328u64 , "partial write for TIMER3 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(324) as usize;
                    let end =
                        (_end.saturating_sub(324) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_events_comparen(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 332 && _end > 328 {
                    assert ! (_start <= 328 && _end >= 332u64 , "partial write for TIMER3 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(328) as usize;
                    let end =
                        (_end.saturating_sub(328) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_events_comparen(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 336 && _end > 332 {
                    assert ! (_start <= 332 && _end >= 336u64 , "partial write for TIMER3 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(332) as usize;
                    let end =
                        (_end.saturating_sub(332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_events_comparen(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 340 && _end > 336 {
                    assert ! (_start <= 336 && _end >= 340u64 , "partial write for TIMER3 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(336) as usize;
                    let end =
                        (_end.saturating_sub(336) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_events_comparen(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 344 && _end > 340 {
                    assert ! (_start <= 340 && _end >= 344u64 , "partial write for TIMER3 EVENTS_COMPARE[%s] not implemented" ,);
                    let start = _start.saturating_sub(340) as usize;
                    let end =
                        (_end.saturating_sub(340) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_events_comparen(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_timer3_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_timer3_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_timer3_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_timer3_mode(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_timer3_bitmode(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_timer3_prescaler(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1367, 1345..=1368) => {
                if _start < 1348 && _end > 1344 {
                    assert!(
                        _start <= 1344 && _end >= 1348u64,
                        "partial write for TIMER3 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1344) as usize;
                    let end =
                        (_end.saturating_sub(1344) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_ccn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1352 && _end > 1348 {
                    assert!(
                        _start <= 1348 && _end >= 1352u64,
                        "partial write for TIMER3 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1348) as usize;
                    let end =
                        (_end.saturating_sub(1348) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_ccn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1356 && _end > 1352 {
                    assert!(
                        _start <= 1352 && _end >= 1356u64,
                        "partial write for TIMER3 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1352) as usize;
                    let end =
                        (_end.saturating_sub(1352) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_ccn(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1360 && _end > 1356 {
                    assert!(
                        _start <= 1356 && _end >= 1360u64,
                        "partial write for TIMER3 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1356) as usize;
                    let end =
                        (_end.saturating_sub(1356) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_ccn(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1364 && _end > 1360 {
                    assert!(
                        _start <= 1360 && _end >= 1364u64,
                        "partial write for TIMER3 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1360) as usize;
                    let end =
                        (_end.saturating_sub(1360) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_ccn(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1368 && _end > 1364 {
                    assert!(
                        _start <= 1364 && _end >= 1368u64,
                        "partial write for TIMER3 CC[%s] not implemented",
                    );
                    let start = _start.saturating_sub(1364) as usize;
                    let end =
                        (_end.saturating_sub(1364) as usize).min(start + 4);
                    self.0.lock().unwrap().write_timer3_ccn(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4001A000 {
    fn read_timer3_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare0_clear()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare1_clear()?,
        ) << 1u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare2_clear()?,
        ) << 2u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare3_clear()?,
        ) << 3u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare4_clear()?,
        ) << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare5_clear()?,
        ) << 5u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare0_stop()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare1_stop()?,
        ) << 9u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare2_stop()?,
        ) << 10u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare3_stop()?,
        ) << 11u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare4_stop()?,
        ) << 12u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_shorts_compare5_stop()?,
        ) << 13u32;
        Ok(_value)
    }
    fn write_timer3_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare0_clear(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare1_clear(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare2_clear(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare3_clear(
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare4_clear(
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare5_clear(
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare0_stop(
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare1_stop(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare2_stop(
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare3_stop(
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare4_stop(
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_timer3_shorts_compare5_stop(
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_timer3_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenset_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenset_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenset_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenset_compare3()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenset_compare4()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenset_compare5()?)
                << 21u32;
        Ok(_value)
    }
    fn write_timer3_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenset_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenset_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenset_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenset_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenset_compare4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenset_compare5((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_timer3_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenclr_compare0()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenclr_compare1()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenclr_compare2()?)
                << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenclr_compare3()?)
                << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenclr_compare4()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_intenclr_compare5()?)
                << 21u32;
        Ok(_value)
    }
    fn write_timer3_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenclr_compare0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenclr_compare1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenclr_compare2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenclr_compare3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenclr_compare4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_intenclr_compare5((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_timer3_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_mode_mode()?) << 0u32;
        Ok(_value)
    }
    fn write_timer3_mode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_mode_mode((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_timer3_bitmode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_timer3_bitmode_bitmode()?)
                << 0u32;
        Ok(_value)
    }
    fn write_timer3_bitmode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_bitmode_bitmode((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_timer3_prescaler(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_timer3_prescaler_prescaler()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_timer3_prescaler(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_timer3_prescaler_prescaler((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4001C000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4001C000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073856512;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=19, 5..=20) => {
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (260..=287, 261..=288) => {
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_events_stopped()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_events_seqstartedn(0)?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_events_seqstartedn(1)?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_events_seqendn(0)?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_events_seqendn(1)?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_events_pwmperiodend()?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_events_loopsdone()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _value = self.read_pwm0_shorts()?.to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_pwm0_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self.read_pwm0_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_pwm0_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_pwm0_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_pwm0_mode()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_pwm0_countertop()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_pwm0_prescaler()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_pwm0_decoder()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_pwm0_loop()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1312..=1327, 1313..=1328) => {
                if _start < 1316 && _end > 1312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_seqn_ptr(0)?
                        .to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_pwm0_seqn_cnt(0)?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_pwm0_seqn_refresh(0)?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _value = self.read_pwm0_seqn_enddelay(0)?.to_ne_bytes();
                    if _start <= 1324 && _end > 1324 {
                        _buf[(1324 - _start) as usize] = _value[0];
                    }
                    if _start <= 1325 && _end > 1325 {
                        _buf[(1325 - _start) as usize] = _value[1];
                    }
                    if _start <= 1326 && _end > 1326 {
                        _buf[(1326 - _start) as usize] = _value[2];
                    }
                    if _start <= 1327 && _end > 1327 {
                        _buf[(1327 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pwm0_seqn_ptr(1)?
                        .to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_pwm0_seqn_cnt(1)?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self.read_pwm0_seqn_refresh(1)?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self.read_pwm0_seqn_enddelay(1)?.to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1376..=1391, 1377..=1392) => {
                if _start < 1380 && _end > 1376 {
                    let _value = self.read_pwm0_psel_outn(0)?.to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1384 && _end > 1380 {
                    let _value = self.read_pwm0_psel_outn(1)?.to_ne_bytes();
                    if _start <= 1380 && _end > 1380 {
                        _buf[(1380 - _start) as usize] = _value[0];
                    }
                    if _start <= 1381 && _end > 1381 {
                        _buf[(1381 - _start) as usize] = _value[1];
                    }
                    if _start <= 1382 && _end > 1382 {
                        _buf[(1382 - _start) as usize] = _value[2];
                    }
                    if _start <= 1383 && _end > 1383 {
                        _buf[(1383 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1388 && _end > 1384 {
                    let _value = self.read_pwm0_psel_outn(2)?.to_ne_bytes();
                    if _start <= 1384 && _end > 1384 {
                        _buf[(1384 - _start) as usize] = _value[0];
                    }
                    if _start <= 1385 && _end > 1385 {
                        _buf[(1385 - _start) as usize] = _value[1];
                    }
                    if _start <= 1386 && _end > 1386 {
                        _buf[(1386 - _start) as usize] = _value[2];
                    }
                    if _start <= 1387 && _end > 1387 {
                        _buf[(1387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1392 && _end > 1388 {
                    let _value = self.read_pwm0_psel_outn(3)?.to_ne_bytes();
                    if _start <= 1388 && _end > 1388 {
                        _buf[(1388 - _start) as usize] = _value[0];
                    }
                    if _start <= 1389 && _end > 1389 {
                        _buf[(1389 - _start) as usize] = _value[1];
                    }
                    if _start <= 1390 && _end > 1390 {
                        _buf[(1390 - _start) as usize] = _value[2];
                    }
                    if _start <= 1391 && _end > 1391 {
                        _buf[(1391 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073856512;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=19, 5..=20) => {
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for PWM0 TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert ! (_start <= 8 && _end >= 12u64 , "partial write for PWM0 TASKS_SEQSTART[%s] not implemented" ,);
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_tasks_seqstartn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert ! (_start <= 12 && _end >= 16u64 , "partial write for PWM0 TASKS_SEQSTART[%s] not implemented" ,);
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_tasks_seqstartn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16 && _end >= 20u64,
                        "partial write for PWM0 TASKS_NEXTSTEP not implemented",
                    );
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_tasks_nextstep(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (260..=287, 261..=288) => {
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for PWM0 EVENTS_STOPPED not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_events_stopped(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert ! (_start <= 264 && _end >= 268u64 , "partial write for PWM0 EVENTS_SEQSTARTED[%s] not implemented" ,);
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_events_seqstartedn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert ! (_start <= 268 && _end >= 272u64 , "partial write for PWM0 EVENTS_SEQSTARTED[%s] not implemented" ,);
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_events_seqstartedn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert ! (_start <= 272 && _end >= 276u64 , "partial write for PWM0 EVENTS_SEQEND[%s] not implemented" ,);
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_events_seqendn(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert ! (_start <= 276 && _end >= 280u64 , "partial write for PWM0 EVENTS_SEQEND[%s] not implemented" ,);
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_events_seqendn(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert ! (_start <= 280 && _end >= 284u64 , "partial write for PWM0 EVENTS_PWMPERIODEND not implemented" ,);
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_events_pwmperiodend(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert ! (_start <= 284 && _end >= 288u64 , "partial write for PWM0 EVENTS_LOOPSDONE not implemented" ,);
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_events_loopsdone(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let offset = _start.saturating_sub(512);
                    let start = 512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 512) - offset) as usize;
                    self.write_pwm0_shorts(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_pwm0_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_pwm0_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_pwm0_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_pwm0_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_pwm0_mode(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_pwm0_countertop(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_pwm0_prescaler(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_pwm0_decoder(offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_pwm0_loop(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1312..=1327, 1313..=1328) => {
                if _start < 1316 && _end > 1312 {
                    assert!(
                        _start <= 1312 && _end >= 1316u64,
                        "partial write for PWM0 PTR not implemented",
                    );
                    let start = _start.saturating_sub(1312) as usize;
                    let end =
                        (_end.saturating_sub(1312) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_seqn_ptr(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_pwm0_seqn_cnt(0, offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = _start.saturating_sub(1320);
                    let start = 1320u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1320) - offset) as usize;
                    self.write_pwm0_seqn_refresh(0, offset, &_buf[start..end])?;
                }
                if _start < 1328 && _end > 1324 {
                    let offset = _start.saturating_sub(1324);
                    let start = 1324u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1324) - offset) as usize;
                    self.write_pwm0_seqn_enddelay(
                        0,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1348 && _end > 1344 {
                    assert!(
                        _start <= 1344 && _end >= 1348u64,
                        "partial write for PWM0 PTR not implemented",
                    );
                    let start = _start.saturating_sub(1344) as usize;
                    let end =
                        (_end.saturating_sub(1344) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pwm0_seqn_ptr(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1352 && _end > 1348 {
                    let offset = _start.saturating_sub(1348);
                    let start = 1348u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1348) - offset) as usize;
                    self.write_pwm0_seqn_cnt(1, offset, &_buf[start..end])?;
                }
                if _start < 1356 && _end > 1352 {
                    let offset = _start.saturating_sub(1352);
                    let start = 1352u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1352) - offset) as usize;
                    self.write_pwm0_seqn_refresh(1, offset, &_buf[start..end])?;
                }
                if _start < 1360 && _end > 1356 {
                    let offset = _start.saturating_sub(1356);
                    let start = 1356u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1356) - offset) as usize;
                    self.write_pwm0_seqn_enddelay(
                        1,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (1376..=1391, 1377..=1392) => {
                if _start < 1380 && _end > 1376 {
                    let offset = _start.saturating_sub(1376);
                    let start = 1376u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1376) - offset) as usize;
                    self.write_pwm0_psel_outn(0, offset, &_buf[start..end])?;
                }
                if _start < 1384 && _end > 1380 {
                    let offset = _start.saturating_sub(1380);
                    let start = 1380u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1380) - offset) as usize;
                    self.write_pwm0_psel_outn(1, offset, &_buf[start..end])?;
                }
                if _start < 1388 && _end > 1384 {
                    let offset = _start.saturating_sub(1384);
                    let start = 1384u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1384) - offset) as usize;
                    self.write_pwm0_psel_outn(2, offset, &_buf[start..end])?;
                }
                if _start < 1392 && _end > 1388 {
                    let offset = _start.saturating_sub(1388);
                    let start = 1388u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1388) - offset) as usize;
                    self.write_pwm0_psel_outn(3, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4001C000 {
    fn read_pwm0_shorts(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_shorts_seqend0_stop()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_shorts_seqend1_stop()?)
                << 1u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_pwm0_shorts_loopsdone_seqstart0()?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_pwm0_shorts_loopsdone_seqstart1()?,
        ) << 3u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_pwm0_shorts_loopsdone_stop()?,
        ) << 4u32;
        Ok(_value)
    }
    fn write_pwm0_shorts(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_shorts_seqend0_stop((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_shorts_seqend1_stop((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_shorts_loopsdone_seqstart0(
                    (_value[_i] >> 2) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_shorts_loopsdone_seqstart1(
                    (_value[_i] >> 3) & 1 != 0,
                )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_shorts_loopsdone_stop((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pwm0_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_pwm0_inten_stopped()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_inten_seqstarted0()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_inten_seqstarted1()?)
                << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_pwm0_inten_seqend0()?)
            << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_pwm0_inten_seqend1()?)
            << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_inten_pwmperiodend()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_inten_loopsdone()?)
                << 7u32;
        Ok(_value)
    }
    fn write_pwm0_inten(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_inten_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_inten_seqstarted0((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_inten_seqstarted1((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_inten_seqend0((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_inten_seqend1((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_inten_pwmperiodend((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_inten_loopsdone((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pwm0_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenset_stopped()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenset_seqstarted0()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenset_seqstarted1()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenset_seqend0()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenset_seqend1()?)
                << 5u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_pwm0_intenset_pwmperiodend()?,
        ) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenset_loopsdone()?)
                << 7u32;
        Ok(_value)
    }
    fn write_pwm0_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenset_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenset_seqstarted0((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenset_seqstarted1((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenset_seqend0((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenset_seqend1((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenset_pwmperiodend((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenset_loopsdone((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pwm0_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenclr_stopped()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenclr_seqstarted0()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenclr_seqstarted1()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenclr_seqend0()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenclr_seqend1()?)
                << 5u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_pwm0_intenclr_pwmperiodend()?,
        ) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_intenclr_loopsdone()?)
                << 7u32;
        Ok(_value)
    }
    fn write_pwm0_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenclr_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenclr_seqstarted0((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenclr_seqstarted1((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenclr_seqend0((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenclr_seqend1((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenclr_pwmperiodend((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_intenclr_loopsdone((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pwm0_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_pwm0_enable_enable()?)
            << 0u32;
        Ok(_value)
    }
    fn write_pwm0_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_enable_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pwm0_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_mode_updown()?) << 0u32;
        Ok(_value)
    }
    fn write_pwm0_mode(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_mode_updown((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pwm0_countertop(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_pwm0_countertop_countertop()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_pwm0_countertop(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 127u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_pwm0_countertop_countertop(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_pwm0_prescaler(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_prescaler_prescaler()?)
                << 0u32;
        Ok(_value)
    }
    fn write_pwm0_prescaler(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_prescaler_prescaler((_value[_i] >> 0) & 7u8)?;
        }
        Ok(())
    }
    fn read_pwm0_decoder(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_decoder_load()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_decoder_mode()?) << 8u32;
        Ok(_value)
    }
    fn write_pwm0_decoder(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_decoder_load((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_decoder_mode((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pwm0_loop(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_loop_cnt()?) << 0u32;
        Ok(_value)
    }
    fn write_pwm0_loop(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_pwm0_loop_cnt(_value)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_pwm0_seqn_cnt(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_seqn_cnt_cnt(_dim)?)
                << 0u32;
        Ok(_value)
    }
    fn write_pwm0_seqn_cnt(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 127u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_pwm0_seqn_cnt_cnt(_dim, _extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_pwm0_seqn_refresh(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_seqn_refresh_cnt(_dim)?)
                << 0u32;
        Ok(_value)
    }
    fn write_pwm0_seqn_refresh(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0
                .lock()
                .unwrap()
                .write_pwm0_seqn_refresh_cnt(_dim, _value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_pwm0_seqn_enddelay(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_pwm0_seqn_enddelay_cnt(_dim)?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_pwm0_seqn_enddelay(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0
                .lock()
                .unwrap()
                .write_pwm0_seqn_enddelay_cnt(_dim, _value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_pwm0_psel_outn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_pwm0_psel_outn_pin(_dim)?)
                << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_pwm0_psel_outn_connect(_dim)?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_pwm0_psel_outn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pwm0_psel_outn_pin(_dim, (_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_pwm0_psel_outn_connect(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4001D000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4001D000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073860608;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pdm_events_started()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pdm_events_stopped()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pdm_events_end()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_pdm_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self.read_pdm_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_pdm_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_pdm_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pdm_pdmclkctrl()?
                        .to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_pdm_mode()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1304..=1311, 1305..=1312) => {
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_pdm_gainl()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_pdm_gainr()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1351, 1345..=1352) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_pdm_psel_clk()?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self.read_pdm_psel_din()?.to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1376..=1383, 1377..=1384) => {
                if _start < 1380 && _end > 1376 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_pdm_sample_ptr()?
                        .to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1384 && _end > 1380 {
                    let _value = self.read_pdm_sample_maxcnt()?.to_ne_bytes();
                    if _start <= 1380 && _end > 1380 {
                        _buf[(1380 - _start) as usize] = _value[0];
                    }
                    if _start <= 1381 && _end > 1381 {
                        _buf[(1381 - _start) as usize] = _value[1];
                    }
                    if _start <= 1382 && _end > 1382 {
                        _buf[(1382 - _start) as usize] = _value[2];
                    }
                    if _start <= 1383 && _end > 1383 {
                        _buf[(1383 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073860608;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for PDM TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pdm_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for PDM TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pdm_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for PDM EVENTS_STARTED not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pdm_events_started(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for PDM EVENTS_STOPPED not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pdm_events_stopped(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for PDM EVENTS_END not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pdm_events_end(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_pdm_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_pdm_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_pdm_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_pdm_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    assert!(
                        _start <= 1284 && _end >= 1288u64,
                        "partial write for PDM PDMCLKCTRL not implemented",
                    );
                    let start = _start.saturating_sub(1284) as usize;
                    let end =
                        (_end.saturating_sub(1284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pdm_pdmclkctrl(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_pdm_mode(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1304..=1311, 1305..=1312) => {
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_pdm_gainl(offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_pdm_gainr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1351, 1345..=1352) => {
                if _start < 1348 && _end > 1344 {
                    let offset = _start.saturating_sub(1344);
                    let start = 1344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1344) - offset) as usize;
                    self.write_pdm_psel_clk(offset, &_buf[start..end])?;
                }
                if _start < 1352 && _end > 1348 {
                    let offset = _start.saturating_sub(1348);
                    let start = 1348u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1348) - offset) as usize;
                    self.write_pdm_psel_din(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1376..=1383, 1377..=1384) => {
                if _start < 1380 && _end > 1376 {
                    assert!(
                        _start <= 1376 && _end >= 1380u64,
                        "partial write for PDM PTR not implemented",
                    );
                    let start = _start.saturating_sub(1376) as usize;
                    let end =
                        (_end.saturating_sub(1376) as usize).min(start + 4);
                    self.0.lock().unwrap().write_pdm_sample_ptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1384 && _end > 1380 {
                    let offset = _start.saturating_sub(1380);
                    let start = 1380u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1380) - offset) as usize;
                    self.write_pdm_sample_maxcnt(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4001D000 {
    fn read_pdm_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_inten_started()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_inten_stopped()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_inten_end()?) << 2u32;
        Ok(_value)
    }
    fn write_pdm_inten(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_inten_started((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_inten_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_inten_end((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pdm_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_intenset_started()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_intenset_stopped()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_intenset_end()?) << 2u32;
        Ok(_value)
    }
    fn write_pdm_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_intenset_started((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_intenset_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_intenset_end((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pdm_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_intenclr_started()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_intenclr_stopped()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_intenclr_end()?) << 2u32;
        Ok(_value)
    }
    fn write_pdm_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_intenclr_started((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_intenclr_stopped((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_intenclr_end((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pdm_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_enable_enable()?) << 0u32;
        Ok(_value)
    }
    fn write_pdm_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_enable_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pdm_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_pdm_mode_operation()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_mode_edge()?) << 1u32;
        Ok(_value)
    }
    fn write_pdm_mode(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_mode_operation((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_mode_edge((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pdm_gainl(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_gainl_gainl()?) << 0u32;
        Ok(_value)
    }
    fn write_pdm_gainl(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_gainl_gainl((_value[_i] >> 0) & 127u8)?;
        }
        Ok(())
    }
    fn read_pdm_gainr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_gainr_gainr()?) << 0u32;
        Ok(_value)
    }
    fn write_pdm_gainr(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_gainr_gainr((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_pdm_psel_clk(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_psel_clk_pin()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_psel_clk_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_pdm_psel_clk(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_psel_clk_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_psel_clk_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pdm_psel_din(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_psel_din_pin()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_pdm_psel_din_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_pdm_psel_din(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_psel_din_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_pdm_psel_din_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_pdm_sample_maxcnt(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_pdm_sample_maxcnt_buffsize()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_pdm_sample_maxcnt(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 127u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_pdm_sample_maxcnt_buffsize(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4001E000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4001E000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073864704;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_nvmc_ready()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1284..=1303, 1285..=1304) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_nvmc_config()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvmc_erasepage()?
                        .to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_nvmc_eraseall()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvmc_erasepcr0()?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_nvmc_eraseuicr()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1347, 1345..=1348) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self.read_nvmc_icachecnf()?.to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1352..=1359, 1353..=1360) => {
                if _start < 1356 && _end > 1352 {
                    let _value =
                        self.0.lock().unwrap().read_nvmc_ihit()?.to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value =
                        self.0.lock().unwrap().read_nvmc_imiss()?.to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073864704;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1284..=1303, 1285..=1304) => {
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_nvmc_config(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    assert!(
                        _start <= 1288 && _end >= 1292u64,
                        "partial write for NVMC ERASEPAGE not implemented",
                    );
                    let start = _start.saturating_sub(1288) as usize;
                    let end =
                        (_end.saturating_sub(1288) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvmc_erasepage(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_nvmc_eraseall(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296 && _end >= 1300u64,
                        "partial write for NVMC ERASEPCR0 not implemented",
                    );
                    let start = _start.saturating_sub(1296) as usize;
                    let end =
                        (_end.saturating_sub(1296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvmc_erasepcr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_nvmc_eraseuicr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1344..=1347, 1345..=1348) => {
                if _start < 1348 && _end > 1344 {
                    let offset = _start.saturating_sub(1344);
                    let start = 1344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1344) - offset) as usize;
                    self.write_nvmc_icachecnf(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1352..=1359, 1353..=1360) => {
                if _start < 1356 && _end > 1352 {
                    assert!(
                        _start <= 1352 && _end >= 1356u64,
                        "partial write for NVMC IHIT not implemented",
                    );
                    let start = _start.saturating_sub(1352) as usize;
                    let end =
                        (_end.saturating_sub(1352) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvmc_ihit(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1360 && _end > 1356 {
                    assert!(
                        _start <= 1356 && _end >= 1360u64,
                        "partial write for NVMC IMISS not implemented",
                    );
                    let start = _start.saturating_sub(1356) as usize;
                    let end =
                        (_end.saturating_sub(1356) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvmc_imiss(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4001E000 {
    fn read_nvmc_ready(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_ready_ready()?) << 0u32;
        Ok(_value)
    }
    fn read_nvmc_config(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_config_wen()?) << 0u32;
        Ok(_value)
    }
    fn write_nvmc_config(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvmc_config_wen((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_nvmc_eraseall(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_eraseall_eraseall()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvmc_eraseall(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvmc_eraseall_eraseall((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_nvmc_eraseuicr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_eraseuicr_eraseuicr()?)
                << 0u32;
        Ok(_value)
    }
    fn write_nvmc_eraseuicr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvmc_eraseuicr_eraseuicr((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_nvmc_icachecnf(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvmc_icachecnf_cacheen()?)
                << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_nvmc_icachecnf_cacheprofen()?,
        ) << 8u32;
        Ok(_value)
    }
    fn write_nvmc_icachecnf(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvmc_icachecnf_cacheen((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvmc_icachecnf_cacheprofen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x4001F000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x4001F000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073868800;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=47, 1..=48) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 20 && _end > 16 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 28 && _end > 24 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 36 && _end > 32 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 44 && _end > 40 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 16 && _end > 12 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 24 && _end > 20 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 32 && _end > 28 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 40 && _end > 36 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 48 && _end > 44 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_ppi_chen()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_ppi_chenset()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_ppi_chenclr()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1455, 1297..=1456) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(0)?
                        .to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(1)?
                        .to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(2)?
                        .to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(3)?
                        .to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(4)?
                        .to_ne_bytes();
                    if _start <= 1328 && _end > 1328 {
                        _buf[(1328 - _start) as usize] = _value[0];
                    }
                    if _start <= 1329 && _end > 1329 {
                        _buf[(1329 - _start) as usize] = _value[1];
                    }
                    if _start <= 1330 && _end > 1330 {
                        _buf[(1330 - _start) as usize] = _value[2];
                    }
                    if _start <= 1331 && _end > 1331 {
                        _buf[(1331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(5)?
                        .to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1348 && _end > 1344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(6)?
                        .to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(7)?
                        .to_ne_bytes();
                    if _start <= 1352 && _end > 1352 {
                        _buf[(1352 - _start) as usize] = _value[0];
                    }
                    if _start <= 1353 && _end > 1353 {
                        _buf[(1353 - _start) as usize] = _value[1];
                    }
                    if _start <= 1354 && _end > 1354 {
                        _buf[(1354 - _start) as usize] = _value[2];
                    }
                    if _start <= 1355 && _end > 1355 {
                        _buf[(1355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(8)?
                        .to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1372 && _end > 1368 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(9)?
                        .to_ne_bytes();
                    if _start <= 1368 && _end > 1368 {
                        _buf[(1368 - _start) as usize] = _value[0];
                    }
                    if _start <= 1369 && _end > 1369 {
                        _buf[(1369 - _start) as usize] = _value[1];
                    }
                    if _start <= 1370 && _end > 1370 {
                        _buf[(1370 - _start) as usize] = _value[2];
                    }
                    if _start <= 1371 && _end > 1371 {
                        _buf[(1371 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1380 && _end > 1376 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(10)?
                        .to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1388 && _end > 1384 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(11)?
                        .to_ne_bytes();
                    if _start <= 1384 && _end > 1384 {
                        _buf[(1384 - _start) as usize] = _value[0];
                    }
                    if _start <= 1385 && _end > 1385 {
                        _buf[(1385 - _start) as usize] = _value[1];
                    }
                    if _start <= 1386 && _end > 1386 {
                        _buf[(1386 - _start) as usize] = _value[2];
                    }
                    if _start <= 1387 && _end > 1387 {
                        _buf[(1387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1396 && _end > 1392 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(12)?
                        .to_ne_bytes();
                    if _start <= 1392 && _end > 1392 {
                        _buf[(1392 - _start) as usize] = _value[0];
                    }
                    if _start <= 1393 && _end > 1393 {
                        _buf[(1393 - _start) as usize] = _value[1];
                    }
                    if _start <= 1394 && _end > 1394 {
                        _buf[(1394 - _start) as usize] = _value[2];
                    }
                    if _start <= 1395 && _end > 1395 {
                        _buf[(1395 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1404 && _end > 1400 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(13)?
                        .to_ne_bytes();
                    if _start <= 1400 && _end > 1400 {
                        _buf[(1400 - _start) as usize] = _value[0];
                    }
                    if _start <= 1401 && _end > 1401 {
                        _buf[(1401 - _start) as usize] = _value[1];
                    }
                    if _start <= 1402 && _end > 1402 {
                        _buf[(1402 - _start) as usize] = _value[2];
                    }
                    if _start <= 1403 && _end > 1403 {
                        _buf[(1403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1412 && _end > 1408 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(14)?
                        .to_ne_bytes();
                    if _start <= 1408 && _end > 1408 {
                        _buf[(1408 - _start) as usize] = _value[0];
                    }
                    if _start <= 1409 && _end > 1409 {
                        _buf[(1409 - _start) as usize] = _value[1];
                    }
                    if _start <= 1410 && _end > 1410 {
                        _buf[(1410 - _start) as usize] = _value[2];
                    }
                    if _start <= 1411 && _end > 1411 {
                        _buf[(1411 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1420 && _end > 1416 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(15)?
                        .to_ne_bytes();
                    if _start <= 1416 && _end > 1416 {
                        _buf[(1416 - _start) as usize] = _value[0];
                    }
                    if _start <= 1417 && _end > 1417 {
                        _buf[(1417 - _start) as usize] = _value[1];
                    }
                    if _start <= 1418 && _end > 1418 {
                        _buf[(1418 - _start) as usize] = _value[2];
                    }
                    if _start <= 1419 && _end > 1419 {
                        _buf[(1419 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1428 && _end > 1424 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(16)?
                        .to_ne_bytes();
                    if _start <= 1424 && _end > 1424 {
                        _buf[(1424 - _start) as usize] = _value[0];
                    }
                    if _start <= 1425 && _end > 1425 {
                        _buf[(1425 - _start) as usize] = _value[1];
                    }
                    if _start <= 1426 && _end > 1426 {
                        _buf[(1426 - _start) as usize] = _value[2];
                    }
                    if _start <= 1427 && _end > 1427 {
                        _buf[(1427 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1436 && _end > 1432 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(17)?
                        .to_ne_bytes();
                    if _start <= 1432 && _end > 1432 {
                        _buf[(1432 - _start) as usize] = _value[0];
                    }
                    if _start <= 1433 && _end > 1433 {
                        _buf[(1433 - _start) as usize] = _value[1];
                    }
                    if _start <= 1434 && _end > 1434 {
                        _buf[(1434 - _start) as usize] = _value[2];
                    }
                    if _start <= 1435 && _end > 1435 {
                        _buf[(1435 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1444 && _end > 1440 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(18)?
                        .to_ne_bytes();
                    if _start <= 1440 && _end > 1440 {
                        _buf[(1440 - _start) as usize] = _value[0];
                    }
                    if _start <= 1441 && _end > 1441 {
                        _buf[(1441 - _start) as usize] = _value[1];
                    }
                    if _start <= 1442 && _end > 1442 {
                        _buf[(1442 - _start) as usize] = _value[2];
                    }
                    if _start <= 1443 && _end > 1443 {
                        _buf[(1443 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1452 && _end > 1448 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_eep(19)?
                        .to_ne_bytes();
                    if _start <= 1448 && _end > 1448 {
                        _buf[(1448 - _start) as usize] = _value[0];
                    }
                    if _start <= 1449 && _end > 1449 {
                        _buf[(1449 - _start) as usize] = _value[1];
                    }
                    if _start <= 1450 && _end > 1450 {
                        _buf[(1450 - _start) as usize] = _value[2];
                    }
                    if _start <= 1451 && _end > 1451 {
                        _buf[(1451 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(0)?
                        .to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(1)?
                        .to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(2)?
                        .to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(3)?
                        .to_ne_bytes();
                    if _start <= 1324 && _end > 1324 {
                        _buf[(1324 - _start) as usize] = _value[0];
                    }
                    if _start <= 1325 && _end > 1325 {
                        _buf[(1325 - _start) as usize] = _value[1];
                    }
                    if _start <= 1326 && _end > 1326 {
                        _buf[(1326 - _start) as usize] = _value[2];
                    }
                    if _start <= 1327 && _end > 1327 {
                        _buf[(1327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(4)?
                        .to_ne_bytes();
                    if _start <= 1332 && _end > 1332 {
                        _buf[(1332 - _start) as usize] = _value[0];
                    }
                    if _start <= 1333 && _end > 1333 {
                        _buf[(1333 - _start) as usize] = _value[1];
                    }
                    if _start <= 1334 && _end > 1334 {
                        _buf[(1334 - _start) as usize] = _value[2];
                    }
                    if _start <= 1335 && _end > 1335 {
                        _buf[(1335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(5)?
                        .to_ne_bytes();
                    if _start <= 1340 && _end > 1340 {
                        _buf[(1340 - _start) as usize] = _value[0];
                    }
                    if _start <= 1341 && _end > 1341 {
                        _buf[(1341 - _start) as usize] = _value[1];
                    }
                    if _start <= 1342 && _end > 1342 {
                        _buf[(1342 - _start) as usize] = _value[2];
                    }
                    if _start <= 1343 && _end > 1343 {
                        _buf[(1343 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(6)?
                        .to_ne_bytes();
                    if _start <= 1348 && _end > 1348 {
                        _buf[(1348 - _start) as usize] = _value[0];
                    }
                    if _start <= 1349 && _end > 1349 {
                        _buf[(1349 - _start) as usize] = _value[1];
                    }
                    if _start <= 1350 && _end > 1350 {
                        _buf[(1350 - _start) as usize] = _value[2];
                    }
                    if _start <= 1351 && _end > 1351 {
                        _buf[(1351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(7)?
                        .to_ne_bytes();
                    if _start <= 1356 && _end > 1356 {
                        _buf[(1356 - _start) as usize] = _value[0];
                    }
                    if _start <= 1357 && _end > 1357 {
                        _buf[(1357 - _start) as usize] = _value[1];
                    }
                    if _start <= 1358 && _end > 1358 {
                        _buf[(1358 - _start) as usize] = _value[2];
                    }
                    if _start <= 1359 && _end > 1359 {
                        _buf[(1359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(8)?
                        .to_ne_bytes();
                    if _start <= 1364 && _end > 1364 {
                        _buf[(1364 - _start) as usize] = _value[0];
                    }
                    if _start <= 1365 && _end > 1365 {
                        _buf[(1365 - _start) as usize] = _value[1];
                    }
                    if _start <= 1366 && _end > 1366 {
                        _buf[(1366 - _start) as usize] = _value[2];
                    }
                    if _start <= 1367 && _end > 1367 {
                        _buf[(1367 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1376 && _end > 1372 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(9)?
                        .to_ne_bytes();
                    if _start <= 1372 && _end > 1372 {
                        _buf[(1372 - _start) as usize] = _value[0];
                    }
                    if _start <= 1373 && _end > 1373 {
                        _buf[(1373 - _start) as usize] = _value[1];
                    }
                    if _start <= 1374 && _end > 1374 {
                        _buf[(1374 - _start) as usize] = _value[2];
                    }
                    if _start <= 1375 && _end > 1375 {
                        _buf[(1375 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1384 && _end > 1380 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(10)?
                        .to_ne_bytes();
                    if _start <= 1380 && _end > 1380 {
                        _buf[(1380 - _start) as usize] = _value[0];
                    }
                    if _start <= 1381 && _end > 1381 {
                        _buf[(1381 - _start) as usize] = _value[1];
                    }
                    if _start <= 1382 && _end > 1382 {
                        _buf[(1382 - _start) as usize] = _value[2];
                    }
                    if _start <= 1383 && _end > 1383 {
                        _buf[(1383 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1392 && _end > 1388 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(11)?
                        .to_ne_bytes();
                    if _start <= 1388 && _end > 1388 {
                        _buf[(1388 - _start) as usize] = _value[0];
                    }
                    if _start <= 1389 && _end > 1389 {
                        _buf[(1389 - _start) as usize] = _value[1];
                    }
                    if _start <= 1390 && _end > 1390 {
                        _buf[(1390 - _start) as usize] = _value[2];
                    }
                    if _start <= 1391 && _end > 1391 {
                        _buf[(1391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1400 && _end > 1396 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(12)?
                        .to_ne_bytes();
                    if _start <= 1396 && _end > 1396 {
                        _buf[(1396 - _start) as usize] = _value[0];
                    }
                    if _start <= 1397 && _end > 1397 {
                        _buf[(1397 - _start) as usize] = _value[1];
                    }
                    if _start <= 1398 && _end > 1398 {
                        _buf[(1398 - _start) as usize] = _value[2];
                    }
                    if _start <= 1399 && _end > 1399 {
                        _buf[(1399 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1408 && _end > 1404 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(13)?
                        .to_ne_bytes();
                    if _start <= 1404 && _end > 1404 {
                        _buf[(1404 - _start) as usize] = _value[0];
                    }
                    if _start <= 1405 && _end > 1405 {
                        _buf[(1405 - _start) as usize] = _value[1];
                    }
                    if _start <= 1406 && _end > 1406 {
                        _buf[(1406 - _start) as usize] = _value[2];
                    }
                    if _start <= 1407 && _end > 1407 {
                        _buf[(1407 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1416 && _end > 1412 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(14)?
                        .to_ne_bytes();
                    if _start <= 1412 && _end > 1412 {
                        _buf[(1412 - _start) as usize] = _value[0];
                    }
                    if _start <= 1413 && _end > 1413 {
                        _buf[(1413 - _start) as usize] = _value[1];
                    }
                    if _start <= 1414 && _end > 1414 {
                        _buf[(1414 - _start) as usize] = _value[2];
                    }
                    if _start <= 1415 && _end > 1415 {
                        _buf[(1415 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1424 && _end > 1420 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(15)?
                        .to_ne_bytes();
                    if _start <= 1420 && _end > 1420 {
                        _buf[(1420 - _start) as usize] = _value[0];
                    }
                    if _start <= 1421 && _end > 1421 {
                        _buf[(1421 - _start) as usize] = _value[1];
                    }
                    if _start <= 1422 && _end > 1422 {
                        _buf[(1422 - _start) as usize] = _value[2];
                    }
                    if _start <= 1423 && _end > 1423 {
                        _buf[(1423 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1432 && _end > 1428 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(16)?
                        .to_ne_bytes();
                    if _start <= 1428 && _end > 1428 {
                        _buf[(1428 - _start) as usize] = _value[0];
                    }
                    if _start <= 1429 && _end > 1429 {
                        _buf[(1429 - _start) as usize] = _value[1];
                    }
                    if _start <= 1430 && _end > 1430 {
                        _buf[(1430 - _start) as usize] = _value[2];
                    }
                    if _start <= 1431 && _end > 1431 {
                        _buf[(1431 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1440 && _end > 1436 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(17)?
                        .to_ne_bytes();
                    if _start <= 1436 && _end > 1436 {
                        _buf[(1436 - _start) as usize] = _value[0];
                    }
                    if _start <= 1437 && _end > 1437 {
                        _buf[(1437 - _start) as usize] = _value[1];
                    }
                    if _start <= 1438 && _end > 1438 {
                        _buf[(1438 - _start) as usize] = _value[2];
                    }
                    if _start <= 1439 && _end > 1439 {
                        _buf[(1439 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1448 && _end > 1444 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(18)?
                        .to_ne_bytes();
                    if _start <= 1444 && _end > 1444 {
                        _buf[(1444 - _start) as usize] = _value[0];
                    }
                    if _start <= 1445 && _end > 1445 {
                        _buf[(1445 - _start) as usize] = _value[1];
                    }
                    if _start <= 1446 && _end > 1446 {
                        _buf[(1446 - _start) as usize] = _value[2];
                    }
                    if _start <= 1447 && _end > 1447 {
                        _buf[(1447 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1456 && _end > 1452 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_chn_tep(19)?
                        .to_ne_bytes();
                    if _start <= 1452 && _end > 1452 {
                        _buf[(1452 - _start) as usize] = _value[0];
                    }
                    if _start <= 1453 && _end > 1453 {
                        _buf[(1453 - _start) as usize] = _value[1];
                    }
                    if _start <= 1454 && _end > 1454 {
                        _buf[(1454 - _start) as usize] = _value[2];
                    }
                    if _start <= 1455 && _end > 1455 {
                        _buf[(1455 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (2048..=2071, 2049..=2072) => {
                if _start < 2052 && _end > 2048 {
                    let _value = self.read_ppi_chgn(0)?.to_ne_bytes();
                    if _start <= 2048 && _end > 2048 {
                        _buf[(2048 - _start) as usize] = _value[0];
                    }
                    if _start <= 2049 && _end > 2049 {
                        _buf[(2049 - _start) as usize] = _value[1];
                    }
                    if _start <= 2050 && _end > 2050 {
                        _buf[(2050 - _start) as usize] = _value[2];
                    }
                    if _start <= 2051 && _end > 2051 {
                        _buf[(2051 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2056 && _end > 2052 {
                    let _value = self.read_ppi_chgn(1)?.to_ne_bytes();
                    if _start <= 2052 && _end > 2052 {
                        _buf[(2052 - _start) as usize] = _value[0];
                    }
                    if _start <= 2053 && _end > 2053 {
                        _buf[(2053 - _start) as usize] = _value[1];
                    }
                    if _start <= 2054 && _end > 2054 {
                        _buf[(2054 - _start) as usize] = _value[2];
                    }
                    if _start <= 2055 && _end > 2055 {
                        _buf[(2055 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2060 && _end > 2056 {
                    let _value = self.read_ppi_chgn(2)?.to_ne_bytes();
                    if _start <= 2056 && _end > 2056 {
                        _buf[(2056 - _start) as usize] = _value[0];
                    }
                    if _start <= 2057 && _end > 2057 {
                        _buf[(2057 - _start) as usize] = _value[1];
                    }
                    if _start <= 2058 && _end > 2058 {
                        _buf[(2058 - _start) as usize] = _value[2];
                    }
                    if _start <= 2059 && _end > 2059 {
                        _buf[(2059 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2064 && _end > 2060 {
                    let _value = self.read_ppi_chgn(3)?.to_ne_bytes();
                    if _start <= 2060 && _end > 2060 {
                        _buf[(2060 - _start) as usize] = _value[0];
                    }
                    if _start <= 2061 && _end > 2061 {
                        _buf[(2061 - _start) as usize] = _value[1];
                    }
                    if _start <= 2062 && _end > 2062 {
                        _buf[(2062 - _start) as usize] = _value[2];
                    }
                    if _start <= 2063 && _end > 2063 {
                        _buf[(2063 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2068 && _end > 2064 {
                    let _value = self.read_ppi_chgn(4)?.to_ne_bytes();
                    if _start <= 2064 && _end > 2064 {
                        _buf[(2064 - _start) as usize] = _value[0];
                    }
                    if _start <= 2065 && _end > 2065 {
                        _buf[(2065 - _start) as usize] = _value[1];
                    }
                    if _start <= 2066 && _end > 2066 {
                        _buf[(2066 - _start) as usize] = _value[2];
                    }
                    if _start <= 2067 && _end > 2067 {
                        _buf[(2067 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2072 && _end > 2068 {
                    let _value = self.read_ppi_chgn(5)?.to_ne_bytes();
                    if _start <= 2068 && _end > 2068 {
                        _buf[(2068 - _start) as usize] = _value[0];
                    }
                    if _start <= 2069 && _end > 2069 {
                        _buf[(2069 - _start) as usize] = _value[1];
                    }
                    if _start <= 2070 && _end > 2070 {
                        _buf[(2070 - _start) as usize] = _value[2];
                    }
                    if _start <= 2071 && _end > 2071 {
                        _buf[(2071 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (2320..=2447, 2321..=2448) => {
                if _start < 2324 && _end > 2320 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(0)?
                        .to_ne_bytes();
                    if _start <= 2320 && _end > 2320 {
                        _buf[(2320 - _start) as usize] = _value[0];
                    }
                    if _start <= 2321 && _end > 2321 {
                        _buf[(2321 - _start) as usize] = _value[1];
                    }
                    if _start <= 2322 && _end > 2322 {
                        _buf[(2322 - _start) as usize] = _value[2];
                    }
                    if _start <= 2323 && _end > 2323 {
                        _buf[(2323 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2328 && _end > 2324 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(1)?
                        .to_ne_bytes();
                    if _start <= 2324 && _end > 2324 {
                        _buf[(2324 - _start) as usize] = _value[0];
                    }
                    if _start <= 2325 && _end > 2325 {
                        _buf[(2325 - _start) as usize] = _value[1];
                    }
                    if _start <= 2326 && _end > 2326 {
                        _buf[(2326 - _start) as usize] = _value[2];
                    }
                    if _start <= 2327 && _end > 2327 {
                        _buf[(2327 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2332 && _end > 2328 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(2)?
                        .to_ne_bytes();
                    if _start <= 2328 && _end > 2328 {
                        _buf[(2328 - _start) as usize] = _value[0];
                    }
                    if _start <= 2329 && _end > 2329 {
                        _buf[(2329 - _start) as usize] = _value[1];
                    }
                    if _start <= 2330 && _end > 2330 {
                        _buf[(2330 - _start) as usize] = _value[2];
                    }
                    if _start <= 2331 && _end > 2331 {
                        _buf[(2331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2336 && _end > 2332 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(3)?
                        .to_ne_bytes();
                    if _start <= 2332 && _end > 2332 {
                        _buf[(2332 - _start) as usize] = _value[0];
                    }
                    if _start <= 2333 && _end > 2333 {
                        _buf[(2333 - _start) as usize] = _value[1];
                    }
                    if _start <= 2334 && _end > 2334 {
                        _buf[(2334 - _start) as usize] = _value[2];
                    }
                    if _start <= 2335 && _end > 2335 {
                        _buf[(2335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2340 && _end > 2336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(4)?
                        .to_ne_bytes();
                    if _start <= 2336 && _end > 2336 {
                        _buf[(2336 - _start) as usize] = _value[0];
                    }
                    if _start <= 2337 && _end > 2337 {
                        _buf[(2337 - _start) as usize] = _value[1];
                    }
                    if _start <= 2338 && _end > 2338 {
                        _buf[(2338 - _start) as usize] = _value[2];
                    }
                    if _start <= 2339 && _end > 2339 {
                        _buf[(2339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2344 && _end > 2340 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(5)?
                        .to_ne_bytes();
                    if _start <= 2340 && _end > 2340 {
                        _buf[(2340 - _start) as usize] = _value[0];
                    }
                    if _start <= 2341 && _end > 2341 {
                        _buf[(2341 - _start) as usize] = _value[1];
                    }
                    if _start <= 2342 && _end > 2342 {
                        _buf[(2342 - _start) as usize] = _value[2];
                    }
                    if _start <= 2343 && _end > 2343 {
                        _buf[(2343 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2348 && _end > 2344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(6)?
                        .to_ne_bytes();
                    if _start <= 2344 && _end > 2344 {
                        _buf[(2344 - _start) as usize] = _value[0];
                    }
                    if _start <= 2345 && _end > 2345 {
                        _buf[(2345 - _start) as usize] = _value[1];
                    }
                    if _start <= 2346 && _end > 2346 {
                        _buf[(2346 - _start) as usize] = _value[2];
                    }
                    if _start <= 2347 && _end > 2347 {
                        _buf[(2347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2352 && _end > 2348 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(7)?
                        .to_ne_bytes();
                    if _start <= 2348 && _end > 2348 {
                        _buf[(2348 - _start) as usize] = _value[0];
                    }
                    if _start <= 2349 && _end > 2349 {
                        _buf[(2349 - _start) as usize] = _value[1];
                    }
                    if _start <= 2350 && _end > 2350 {
                        _buf[(2350 - _start) as usize] = _value[2];
                    }
                    if _start <= 2351 && _end > 2351 {
                        _buf[(2351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2356 && _end > 2352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(8)?
                        .to_ne_bytes();
                    if _start <= 2352 && _end > 2352 {
                        _buf[(2352 - _start) as usize] = _value[0];
                    }
                    if _start <= 2353 && _end > 2353 {
                        _buf[(2353 - _start) as usize] = _value[1];
                    }
                    if _start <= 2354 && _end > 2354 {
                        _buf[(2354 - _start) as usize] = _value[2];
                    }
                    if _start <= 2355 && _end > 2355 {
                        _buf[(2355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2360 && _end > 2356 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(9)?
                        .to_ne_bytes();
                    if _start <= 2356 && _end > 2356 {
                        _buf[(2356 - _start) as usize] = _value[0];
                    }
                    if _start <= 2357 && _end > 2357 {
                        _buf[(2357 - _start) as usize] = _value[1];
                    }
                    if _start <= 2358 && _end > 2358 {
                        _buf[(2358 - _start) as usize] = _value[2];
                    }
                    if _start <= 2359 && _end > 2359 {
                        _buf[(2359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2364 && _end > 2360 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(10)?
                        .to_ne_bytes();
                    if _start <= 2360 && _end > 2360 {
                        _buf[(2360 - _start) as usize] = _value[0];
                    }
                    if _start <= 2361 && _end > 2361 {
                        _buf[(2361 - _start) as usize] = _value[1];
                    }
                    if _start <= 2362 && _end > 2362 {
                        _buf[(2362 - _start) as usize] = _value[2];
                    }
                    if _start <= 2363 && _end > 2363 {
                        _buf[(2363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2368 && _end > 2364 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(11)?
                        .to_ne_bytes();
                    if _start <= 2364 && _end > 2364 {
                        _buf[(2364 - _start) as usize] = _value[0];
                    }
                    if _start <= 2365 && _end > 2365 {
                        _buf[(2365 - _start) as usize] = _value[1];
                    }
                    if _start <= 2366 && _end > 2366 {
                        _buf[(2366 - _start) as usize] = _value[2];
                    }
                    if _start <= 2367 && _end > 2367 {
                        _buf[(2367 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2372 && _end > 2368 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(12)?
                        .to_ne_bytes();
                    if _start <= 2368 && _end > 2368 {
                        _buf[(2368 - _start) as usize] = _value[0];
                    }
                    if _start <= 2369 && _end > 2369 {
                        _buf[(2369 - _start) as usize] = _value[1];
                    }
                    if _start <= 2370 && _end > 2370 {
                        _buf[(2370 - _start) as usize] = _value[2];
                    }
                    if _start <= 2371 && _end > 2371 {
                        _buf[(2371 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2376 && _end > 2372 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(13)?
                        .to_ne_bytes();
                    if _start <= 2372 && _end > 2372 {
                        _buf[(2372 - _start) as usize] = _value[0];
                    }
                    if _start <= 2373 && _end > 2373 {
                        _buf[(2373 - _start) as usize] = _value[1];
                    }
                    if _start <= 2374 && _end > 2374 {
                        _buf[(2374 - _start) as usize] = _value[2];
                    }
                    if _start <= 2375 && _end > 2375 {
                        _buf[(2375 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2380 && _end > 2376 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(14)?
                        .to_ne_bytes();
                    if _start <= 2376 && _end > 2376 {
                        _buf[(2376 - _start) as usize] = _value[0];
                    }
                    if _start <= 2377 && _end > 2377 {
                        _buf[(2377 - _start) as usize] = _value[1];
                    }
                    if _start <= 2378 && _end > 2378 {
                        _buf[(2378 - _start) as usize] = _value[2];
                    }
                    if _start <= 2379 && _end > 2379 {
                        _buf[(2379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2384 && _end > 2380 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(15)?
                        .to_ne_bytes();
                    if _start <= 2380 && _end > 2380 {
                        _buf[(2380 - _start) as usize] = _value[0];
                    }
                    if _start <= 2381 && _end > 2381 {
                        _buf[(2381 - _start) as usize] = _value[1];
                    }
                    if _start <= 2382 && _end > 2382 {
                        _buf[(2382 - _start) as usize] = _value[2];
                    }
                    if _start <= 2383 && _end > 2383 {
                        _buf[(2383 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2388 && _end > 2384 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(16)?
                        .to_ne_bytes();
                    if _start <= 2384 && _end > 2384 {
                        _buf[(2384 - _start) as usize] = _value[0];
                    }
                    if _start <= 2385 && _end > 2385 {
                        _buf[(2385 - _start) as usize] = _value[1];
                    }
                    if _start <= 2386 && _end > 2386 {
                        _buf[(2386 - _start) as usize] = _value[2];
                    }
                    if _start <= 2387 && _end > 2387 {
                        _buf[(2387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2392 && _end > 2388 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(17)?
                        .to_ne_bytes();
                    if _start <= 2388 && _end > 2388 {
                        _buf[(2388 - _start) as usize] = _value[0];
                    }
                    if _start <= 2389 && _end > 2389 {
                        _buf[(2389 - _start) as usize] = _value[1];
                    }
                    if _start <= 2390 && _end > 2390 {
                        _buf[(2390 - _start) as usize] = _value[2];
                    }
                    if _start <= 2391 && _end > 2391 {
                        _buf[(2391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2396 && _end > 2392 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(18)?
                        .to_ne_bytes();
                    if _start <= 2392 && _end > 2392 {
                        _buf[(2392 - _start) as usize] = _value[0];
                    }
                    if _start <= 2393 && _end > 2393 {
                        _buf[(2393 - _start) as usize] = _value[1];
                    }
                    if _start <= 2394 && _end > 2394 {
                        _buf[(2394 - _start) as usize] = _value[2];
                    }
                    if _start <= 2395 && _end > 2395 {
                        _buf[(2395 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2400 && _end > 2396 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(19)?
                        .to_ne_bytes();
                    if _start <= 2396 && _end > 2396 {
                        _buf[(2396 - _start) as usize] = _value[0];
                    }
                    if _start <= 2397 && _end > 2397 {
                        _buf[(2397 - _start) as usize] = _value[1];
                    }
                    if _start <= 2398 && _end > 2398 {
                        _buf[(2398 - _start) as usize] = _value[2];
                    }
                    if _start <= 2399 && _end > 2399 {
                        _buf[(2399 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2404 && _end > 2400 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(20)?
                        .to_ne_bytes();
                    if _start <= 2400 && _end > 2400 {
                        _buf[(2400 - _start) as usize] = _value[0];
                    }
                    if _start <= 2401 && _end > 2401 {
                        _buf[(2401 - _start) as usize] = _value[1];
                    }
                    if _start <= 2402 && _end > 2402 {
                        _buf[(2402 - _start) as usize] = _value[2];
                    }
                    if _start <= 2403 && _end > 2403 {
                        _buf[(2403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2408 && _end > 2404 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(21)?
                        .to_ne_bytes();
                    if _start <= 2404 && _end > 2404 {
                        _buf[(2404 - _start) as usize] = _value[0];
                    }
                    if _start <= 2405 && _end > 2405 {
                        _buf[(2405 - _start) as usize] = _value[1];
                    }
                    if _start <= 2406 && _end > 2406 {
                        _buf[(2406 - _start) as usize] = _value[2];
                    }
                    if _start <= 2407 && _end > 2407 {
                        _buf[(2407 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2412 && _end > 2408 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(22)?
                        .to_ne_bytes();
                    if _start <= 2408 && _end > 2408 {
                        _buf[(2408 - _start) as usize] = _value[0];
                    }
                    if _start <= 2409 && _end > 2409 {
                        _buf[(2409 - _start) as usize] = _value[1];
                    }
                    if _start <= 2410 && _end > 2410 {
                        _buf[(2410 - _start) as usize] = _value[2];
                    }
                    if _start <= 2411 && _end > 2411 {
                        _buf[(2411 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2416 && _end > 2412 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(23)?
                        .to_ne_bytes();
                    if _start <= 2412 && _end > 2412 {
                        _buf[(2412 - _start) as usize] = _value[0];
                    }
                    if _start <= 2413 && _end > 2413 {
                        _buf[(2413 - _start) as usize] = _value[1];
                    }
                    if _start <= 2414 && _end > 2414 {
                        _buf[(2414 - _start) as usize] = _value[2];
                    }
                    if _start <= 2415 && _end > 2415 {
                        _buf[(2415 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2420 && _end > 2416 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(24)?
                        .to_ne_bytes();
                    if _start <= 2416 && _end > 2416 {
                        _buf[(2416 - _start) as usize] = _value[0];
                    }
                    if _start <= 2417 && _end > 2417 {
                        _buf[(2417 - _start) as usize] = _value[1];
                    }
                    if _start <= 2418 && _end > 2418 {
                        _buf[(2418 - _start) as usize] = _value[2];
                    }
                    if _start <= 2419 && _end > 2419 {
                        _buf[(2419 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2424 && _end > 2420 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(25)?
                        .to_ne_bytes();
                    if _start <= 2420 && _end > 2420 {
                        _buf[(2420 - _start) as usize] = _value[0];
                    }
                    if _start <= 2421 && _end > 2421 {
                        _buf[(2421 - _start) as usize] = _value[1];
                    }
                    if _start <= 2422 && _end > 2422 {
                        _buf[(2422 - _start) as usize] = _value[2];
                    }
                    if _start <= 2423 && _end > 2423 {
                        _buf[(2423 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2428 && _end > 2424 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(26)?
                        .to_ne_bytes();
                    if _start <= 2424 && _end > 2424 {
                        _buf[(2424 - _start) as usize] = _value[0];
                    }
                    if _start <= 2425 && _end > 2425 {
                        _buf[(2425 - _start) as usize] = _value[1];
                    }
                    if _start <= 2426 && _end > 2426 {
                        _buf[(2426 - _start) as usize] = _value[2];
                    }
                    if _start <= 2427 && _end > 2427 {
                        _buf[(2427 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2432 && _end > 2428 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(27)?
                        .to_ne_bytes();
                    if _start <= 2428 && _end > 2428 {
                        _buf[(2428 - _start) as usize] = _value[0];
                    }
                    if _start <= 2429 && _end > 2429 {
                        _buf[(2429 - _start) as usize] = _value[1];
                    }
                    if _start <= 2430 && _end > 2430 {
                        _buf[(2430 - _start) as usize] = _value[2];
                    }
                    if _start <= 2431 && _end > 2431 {
                        _buf[(2431 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2436 && _end > 2432 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(28)?
                        .to_ne_bytes();
                    if _start <= 2432 && _end > 2432 {
                        _buf[(2432 - _start) as usize] = _value[0];
                    }
                    if _start <= 2433 && _end > 2433 {
                        _buf[(2433 - _start) as usize] = _value[1];
                    }
                    if _start <= 2434 && _end > 2434 {
                        _buf[(2434 - _start) as usize] = _value[2];
                    }
                    if _start <= 2435 && _end > 2435 {
                        _buf[(2435 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2440 && _end > 2436 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(29)?
                        .to_ne_bytes();
                    if _start <= 2436 && _end > 2436 {
                        _buf[(2436 - _start) as usize] = _value[0];
                    }
                    if _start <= 2437 && _end > 2437 {
                        _buf[(2437 - _start) as usize] = _value[1];
                    }
                    if _start <= 2438 && _end > 2438 {
                        _buf[(2438 - _start) as usize] = _value[2];
                    }
                    if _start <= 2439 && _end > 2439 {
                        _buf[(2439 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2444 && _end > 2440 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(30)?
                        .to_ne_bytes();
                    if _start <= 2440 && _end > 2440 {
                        _buf[(2440 - _start) as usize] = _value[0];
                    }
                    if _start <= 2441 && _end > 2441 {
                        _buf[(2441 - _start) as usize] = _value[1];
                    }
                    if _start <= 2442 && _end > 2442 {
                        _buf[(2442 - _start) as usize] = _value[2];
                    }
                    if _start <= 2443 && _end > 2443 {
                        _buf[(2443 - _start) as usize] = _value[3];
                    }
                }
                if _start < 2448 && _end > 2444 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_ppi_forkn_tep(31)?
                        .to_ne_bytes();
                    if _start <= 2444 && _end > 2444 {
                        _buf[(2444 - _start) as usize] = _value[0];
                    }
                    if _start <= 2445 && _end > 2445 {
                        _buf[(2445 - _start) as usize] = _value[1];
                    }
                    if _start <= 2446 && _end > 2446 {
                        _buf[(2446 - _start) as usize] = _value[2];
                    }
                    if _start <= 2447 && _end > 2447 {
                        _buf[(2447 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073868800;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=47, 1..=48) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_en(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 12 && _end > 8 {
                    assert!(
                        _start <= 8 && _end >= 12u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(8) as usize;
                    let end = (_end.saturating_sub(8) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_en(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 20 && _end > 16 {
                    assert!(
                        _start <= 16 && _end >= 20u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(16) as usize;
                    let end = (_end.saturating_sub(16) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_en(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 28 && _end > 24 {
                    assert!(
                        _start <= 24 && _end >= 28u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(24) as usize;
                    let end = (_end.saturating_sub(24) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_en(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 36 && _end > 32 {
                    assert!(
                        _start <= 32 && _end >= 36u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(32) as usize;
                    let end = (_end.saturating_sub(32) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_en(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 44 && _end > 40 {
                    assert!(
                        _start <= 40 && _end >= 44u64,
                        "partial write for PPI EN not implemented",
                    );
                    let start = _start.saturating_sub(40) as usize;
                    let end = (_end.saturating_sub(40) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_en(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_dis(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 16 && _end > 12 {
                    assert!(
                        _start <= 12 && _end >= 16u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(12) as usize;
                    let end = (_end.saturating_sub(12) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_dis(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 24 && _end > 20 {
                    assert!(
                        _start <= 20 && _end >= 24u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(20) as usize;
                    let end = (_end.saturating_sub(20) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_dis(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 32 && _end > 28 {
                    assert!(
                        _start <= 28 && _end >= 32u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(28) as usize;
                    let end = (_end.saturating_sub(28) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_dis(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 40 && _end > 36 {
                    assert!(
                        _start <= 36 && _end >= 40u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(36) as usize;
                    let end = (_end.saturating_sub(36) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_dis(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 48 && _end > 44 {
                    assert!(
                        _start <= 44 && _end >= 48u64,
                        "partial write for PPI DIS not implemented",
                    );
                    let start = _start.saturating_sub(44) as usize;
                    let end = (_end.saturating_sub(44) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_tasks_chgn_dis(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_ppi_chen(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_ppi_chenset(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_ppi_chenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1296..=1455, 1297..=1456) => {
                if _start < 1300 && _end > 1296 {
                    assert!(
                        _start <= 1296 && _end >= 1300u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1296) as usize;
                    let end =
                        (_end.saturating_sub(1296) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1308 && _end > 1304 {
                    assert!(
                        _start <= 1304 && _end >= 1308u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1304) as usize;
                    let end =
                        (_end.saturating_sub(1304) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1316 && _end > 1312 {
                    assert!(
                        _start <= 1312 && _end >= 1316u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1312) as usize;
                    let end =
                        (_end.saturating_sub(1312) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1324 && _end > 1320 {
                    assert!(
                        _start <= 1320 && _end >= 1324u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1320) as usize;
                    let end =
                        (_end.saturating_sub(1320) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1332 && _end > 1328 {
                    assert!(
                        _start <= 1328 && _end >= 1332u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1328) as usize;
                    let end =
                        (_end.saturating_sub(1328) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1340 && _end > 1336 {
                    assert!(
                        _start <= 1336 && _end >= 1340u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1336) as usize;
                    let end =
                        (_end.saturating_sub(1336) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1348 && _end > 1344 {
                    assert!(
                        _start <= 1344 && _end >= 1348u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1344) as usize;
                    let end =
                        (_end.saturating_sub(1344) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1356 && _end > 1352 {
                    assert!(
                        _start <= 1352 && _end >= 1356u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1352) as usize;
                    let end =
                        (_end.saturating_sub(1352) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1364 && _end > 1360 {
                    assert!(
                        _start <= 1360 && _end >= 1364u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1360) as usize;
                    let end =
                        (_end.saturating_sub(1360) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1372 && _end > 1368 {
                    assert!(
                        _start <= 1368 && _end >= 1372u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1368) as usize;
                    let end =
                        (_end.saturating_sub(1368) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1380 && _end > 1376 {
                    assert!(
                        _start <= 1376 && _end >= 1380u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1376) as usize;
                    let end =
                        (_end.saturating_sub(1376) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1388 && _end > 1384 {
                    assert!(
                        _start <= 1384 && _end >= 1388u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1384) as usize;
                    let end =
                        (_end.saturating_sub(1384) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1396 && _end > 1392 {
                    assert!(
                        _start <= 1392 && _end >= 1396u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1392) as usize;
                    let end =
                        (_end.saturating_sub(1392) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1404 && _end > 1400 {
                    assert!(
                        _start <= 1400 && _end >= 1404u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1400) as usize;
                    let end =
                        (_end.saturating_sub(1400) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1412 && _end > 1408 {
                    assert!(
                        _start <= 1408 && _end >= 1412u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1408) as usize;
                    let end =
                        (_end.saturating_sub(1408) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1420 && _end > 1416 {
                    assert!(
                        _start <= 1416 && _end >= 1420u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1416) as usize;
                    let end =
                        (_end.saturating_sub(1416) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1428 && _end > 1424 {
                    assert!(
                        _start <= 1424 && _end >= 1428u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1424) as usize;
                    let end =
                        (_end.saturating_sub(1424) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        16,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1436 && _end > 1432 {
                    assert!(
                        _start <= 1432 && _end >= 1436u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1432) as usize;
                    let end =
                        (_end.saturating_sub(1432) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        17,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1444 && _end > 1440 {
                    assert!(
                        _start <= 1440 && _end >= 1444u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1440) as usize;
                    let end =
                        (_end.saturating_sub(1440) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        18,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1452 && _end > 1448 {
                    assert!(
                        _start <= 1448 && _end >= 1452u64,
                        "partial write for PPI EEP not implemented",
                    );
                    let start = _start.saturating_sub(1448) as usize;
                    let end =
                        (_end.saturating_sub(1448) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_eep(
                        19,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    assert!(
                        _start <= 1300 && _end >= 1304u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1300) as usize;
                    let end =
                        (_end.saturating_sub(1300) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1312 && _end > 1308 {
                    assert!(
                        _start <= 1308 && _end >= 1312u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1308) as usize;
                    let end =
                        (_end.saturating_sub(1308) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1320 && _end > 1316 {
                    assert!(
                        _start <= 1316 && _end >= 1320u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1316) as usize;
                    let end =
                        (_end.saturating_sub(1316) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1328 && _end > 1324 {
                    assert!(
                        _start <= 1324 && _end >= 1328u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1324) as usize;
                    let end =
                        (_end.saturating_sub(1324) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1336 && _end > 1332 {
                    assert!(
                        _start <= 1332 && _end >= 1336u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1332) as usize;
                    let end =
                        (_end.saturating_sub(1332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1344 && _end > 1340 {
                    assert!(
                        _start <= 1340 && _end >= 1344u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1340) as usize;
                    let end =
                        (_end.saturating_sub(1340) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1352 && _end > 1348 {
                    assert!(
                        _start <= 1348 && _end >= 1352u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1348) as usize;
                    let end =
                        (_end.saturating_sub(1348) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1360 && _end > 1356 {
                    assert!(
                        _start <= 1356 && _end >= 1360u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1356) as usize;
                    let end =
                        (_end.saturating_sub(1356) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1368 && _end > 1364 {
                    assert!(
                        _start <= 1364 && _end >= 1368u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1364) as usize;
                    let end =
                        (_end.saturating_sub(1364) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1376 && _end > 1372 {
                    assert!(
                        _start <= 1372 && _end >= 1376u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1372) as usize;
                    let end =
                        (_end.saturating_sub(1372) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1384 && _end > 1380 {
                    assert!(
                        _start <= 1380 && _end >= 1384u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1380) as usize;
                    let end =
                        (_end.saturating_sub(1380) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1392 && _end > 1388 {
                    assert!(
                        _start <= 1388 && _end >= 1392u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1388) as usize;
                    let end =
                        (_end.saturating_sub(1388) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1400 && _end > 1396 {
                    assert!(
                        _start <= 1396 && _end >= 1400u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1396) as usize;
                    let end =
                        (_end.saturating_sub(1396) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1408 && _end > 1404 {
                    assert!(
                        _start <= 1404 && _end >= 1408u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1404) as usize;
                    let end =
                        (_end.saturating_sub(1404) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1416 && _end > 1412 {
                    assert!(
                        _start <= 1412 && _end >= 1416u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1412) as usize;
                    let end =
                        (_end.saturating_sub(1412) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1424 && _end > 1420 {
                    assert!(
                        _start <= 1420 && _end >= 1424u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1420) as usize;
                    let end =
                        (_end.saturating_sub(1420) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1432 && _end > 1428 {
                    assert!(
                        _start <= 1428 && _end >= 1432u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1428) as usize;
                    let end =
                        (_end.saturating_sub(1428) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        16,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1440 && _end > 1436 {
                    assert!(
                        _start <= 1436 && _end >= 1440u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1436) as usize;
                    let end =
                        (_end.saturating_sub(1436) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        17,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1448 && _end > 1444 {
                    assert!(
                        _start <= 1444 && _end >= 1448u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1444) as usize;
                    let end =
                        (_end.saturating_sub(1444) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        18,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1456 && _end > 1452 {
                    assert!(
                        _start <= 1452 && _end >= 1456u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(1452) as usize;
                    let end =
                        (_end.saturating_sub(1452) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_chn_tep(
                        19,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (2048..=2071, 2049..=2072) => {
                if _start < 2052 && _end > 2048 {
                    let offset = _start.saturating_sub(2048);
                    let start = 2048u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2048) - offset) as usize;
                    self.write_ppi_chgn(0, offset, &_buf[start..end])?;
                }
                if _start < 2056 && _end > 2052 {
                    let offset = _start.saturating_sub(2052);
                    let start = 2052u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2052) - offset) as usize;
                    self.write_ppi_chgn(1, offset, &_buf[start..end])?;
                }
                if _start < 2060 && _end > 2056 {
                    let offset = _start.saturating_sub(2056);
                    let start = 2056u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2056) - offset) as usize;
                    self.write_ppi_chgn(2, offset, &_buf[start..end])?;
                }
                if _start < 2064 && _end > 2060 {
                    let offset = _start.saturating_sub(2060);
                    let start = 2060u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2060) - offset) as usize;
                    self.write_ppi_chgn(3, offset, &_buf[start..end])?;
                }
                if _start < 2068 && _end > 2064 {
                    let offset = _start.saturating_sub(2064);
                    let start = 2064u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2064) - offset) as usize;
                    self.write_ppi_chgn(4, offset, &_buf[start..end])?;
                }
                if _start < 2072 && _end > 2068 {
                    let offset = _start.saturating_sub(2068);
                    let start = 2068u64.saturating_sub(_start) as usize;
                    let end = ((_end - 2068) - offset) as usize;
                    self.write_ppi_chgn(5, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (2320..=2447, 2321..=2448) => {
                if _start < 2324 && _end > 2320 {
                    assert!(
                        _start <= 2320 && _end >= 2324u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2320) as usize;
                    let end =
                        (_end.saturating_sub(2320) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2328 && _end > 2324 {
                    assert!(
                        _start <= 2324 && _end >= 2328u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2324) as usize;
                    let end =
                        (_end.saturating_sub(2324) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2332 && _end > 2328 {
                    assert!(
                        _start <= 2328 && _end >= 2332u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2328) as usize;
                    let end =
                        (_end.saturating_sub(2328) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2336 && _end > 2332 {
                    assert!(
                        _start <= 2332 && _end >= 2336u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2332) as usize;
                    let end =
                        (_end.saturating_sub(2332) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2340 && _end > 2336 {
                    assert!(
                        _start <= 2336 && _end >= 2340u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2336) as usize;
                    let end =
                        (_end.saturating_sub(2336) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        4,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2344 && _end > 2340 {
                    assert!(
                        _start <= 2340 && _end >= 2344u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2340) as usize;
                    let end =
                        (_end.saturating_sub(2340) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        5,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2348 && _end > 2344 {
                    assert!(
                        _start <= 2344 && _end >= 2348u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2344) as usize;
                    let end =
                        (_end.saturating_sub(2344) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        6,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2352 && _end > 2348 {
                    assert!(
                        _start <= 2348 && _end >= 2352u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2348) as usize;
                    let end =
                        (_end.saturating_sub(2348) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        7,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2356 && _end > 2352 {
                    assert!(
                        _start <= 2352 && _end >= 2356u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2352) as usize;
                    let end =
                        (_end.saturating_sub(2352) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        8,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2360 && _end > 2356 {
                    assert!(
                        _start <= 2356 && _end >= 2360u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2356) as usize;
                    let end =
                        (_end.saturating_sub(2356) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        9,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2364 && _end > 2360 {
                    assert!(
                        _start <= 2360 && _end >= 2364u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2360) as usize;
                    let end =
                        (_end.saturating_sub(2360) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        10,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2368 && _end > 2364 {
                    assert!(
                        _start <= 2364 && _end >= 2368u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2364) as usize;
                    let end =
                        (_end.saturating_sub(2364) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        11,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2372 && _end > 2368 {
                    assert!(
                        _start <= 2368 && _end >= 2372u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2368) as usize;
                    let end =
                        (_end.saturating_sub(2368) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        12,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2376 && _end > 2372 {
                    assert!(
                        _start <= 2372 && _end >= 2376u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2372) as usize;
                    let end =
                        (_end.saturating_sub(2372) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        13,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2380 && _end > 2376 {
                    assert!(
                        _start <= 2376 && _end >= 2380u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2376) as usize;
                    let end =
                        (_end.saturating_sub(2376) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        14,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2384 && _end > 2380 {
                    assert!(
                        _start <= 2380 && _end >= 2384u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2380) as usize;
                    let end =
                        (_end.saturating_sub(2380) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        15,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2388 && _end > 2384 {
                    assert!(
                        _start <= 2384 && _end >= 2388u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2384) as usize;
                    let end =
                        (_end.saturating_sub(2384) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        16,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2392 && _end > 2388 {
                    assert!(
                        _start <= 2388 && _end >= 2392u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2388) as usize;
                    let end =
                        (_end.saturating_sub(2388) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        17,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2396 && _end > 2392 {
                    assert!(
                        _start <= 2392 && _end >= 2396u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2392) as usize;
                    let end =
                        (_end.saturating_sub(2392) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        18,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2400 && _end > 2396 {
                    assert!(
                        _start <= 2396 && _end >= 2400u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2396) as usize;
                    let end =
                        (_end.saturating_sub(2396) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        19,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2404 && _end > 2400 {
                    assert!(
                        _start <= 2400 && _end >= 2404u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2400) as usize;
                    let end =
                        (_end.saturating_sub(2400) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        20,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2408 && _end > 2404 {
                    assert!(
                        _start <= 2404 && _end >= 2408u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2404) as usize;
                    let end =
                        (_end.saturating_sub(2404) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        21,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2412 && _end > 2408 {
                    assert!(
                        _start <= 2408 && _end >= 2412u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2408) as usize;
                    let end =
                        (_end.saturating_sub(2408) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        22,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2416 && _end > 2412 {
                    assert!(
                        _start <= 2412 && _end >= 2416u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2412) as usize;
                    let end =
                        (_end.saturating_sub(2412) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        23,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2420 && _end > 2416 {
                    assert!(
                        _start <= 2416 && _end >= 2420u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2416) as usize;
                    let end =
                        (_end.saturating_sub(2416) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        24,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2424 && _end > 2420 {
                    assert!(
                        _start <= 2420 && _end >= 2424u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2420) as usize;
                    let end =
                        (_end.saturating_sub(2420) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        25,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2428 && _end > 2424 {
                    assert!(
                        _start <= 2424 && _end >= 2428u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2424) as usize;
                    let end =
                        (_end.saturating_sub(2424) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        26,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2432 && _end > 2428 {
                    assert!(
                        _start <= 2428 && _end >= 2432u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2428) as usize;
                    let end =
                        (_end.saturating_sub(2428) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        27,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2436 && _end > 2432 {
                    assert!(
                        _start <= 2432 && _end >= 2436u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2432) as usize;
                    let end =
                        (_end.saturating_sub(2432) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        28,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2440 && _end > 2436 {
                    assert!(
                        _start <= 2436 && _end >= 2440u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2436) as usize;
                    let end =
                        (_end.saturating_sub(2436) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        29,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2444 && _end > 2440 {
                    assert!(
                        _start <= 2440 && _end >= 2444u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2440) as usize;
                    let end =
                        (_end.saturating_sub(2440) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        30,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 2448 && _end > 2444 {
                    assert!(
                        _start <= 2444 && _end >= 2448u64,
                        "partial write for PPI TEP not implemented",
                    );
                    let start = _start.saturating_sub(2444) as usize;
                    let end =
                        (_end.saturating_sub(2444) as usize).min(start + 4);
                    self.0.lock().unwrap().write_ppi_forkn_tep(
                        31,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x4001F000 {
    fn read_ppi_chen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chen_ch31()?) << 31u32;
        Ok(_value)
    }
    fn write_ppi_chen(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chen_ch31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ppi_chenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenset_ch31()?) << 31u32;
        Ok(_value)
    }
    fn write_ppi_chenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenset_ch31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ppi_chenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chenclr_ch31()?) << 31u32;
        Ok(_value)
    }
    fn write_ppi_chenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chenclr_ch31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_ppi_chgn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch0(_dim)?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch1(_dim)?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch2(_dim)?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch3(_dim)?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch4(_dim)?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch5(_dim)?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch6(_dim)?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch7(_dim)?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch8(_dim)?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_ppi_chgn_ch9(_dim)?) << 9u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch10(_dim)?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch11(_dim)?)
            << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch12(_dim)?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch13(_dim)?)
            << 13u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch14(_dim)?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch15(_dim)?)
            << 15u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch16(_dim)?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch17(_dim)?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch18(_dim)?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch19(_dim)?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch20(_dim)?)
            << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch21(_dim)?)
            << 21u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch22(_dim)?)
            << 22u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch23(_dim)?)
            << 23u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch24(_dim)?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch25(_dim)?)
            << 25u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch26(_dim)?)
            << 26u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch27(_dim)?)
            << 27u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch28(_dim)?)
            << 28u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch29(_dim)?)
            << 29u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch30(_dim)?)
            << 30u32;
        _value |= u32::from(self.0.lock().unwrap().read_ppi_chgn_ch31(_dim)?)
            << 31u32;
        Ok(_value)
    }
    fn write_ppi_chgn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch0(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch1(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch2(_dim, (_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch3(_dim, (_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch4(_dim, (_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch5(_dim, (_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch6(_dim, (_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch7(_dim, (_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch8(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch9(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch10(_dim, (_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch11(_dim, (_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch12(_dim, (_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch13(_dim, (_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch14(_dim, (_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch15(_dim, (_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch16(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch17(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch18(_dim, (_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch19(_dim, (_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch20(_dim, (_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch21(_dim, (_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch22(_dim, (_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch23(_dim, (_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch24(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch25(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch26(_dim, (_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch27(_dim, (_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch28(_dim, (_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch29(_dim, (_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch30(_dim, (_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_ppi_chgn_ch31(_dim, (_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40020000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40020000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073872896;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_regionn_wa(0)?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_regionn_wa(1)?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_regionn_wa(2)?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_regionn_wa(3)?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_regionn_ra(0)?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_regionn_ra(1)?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_regionn_ra(2)?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_regionn_ra(3)?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (352..=367, 353..=368) => {
                if _start < 356 && _end > 352 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_pregionn_wa(0)?
                        .to_ne_bytes();
                    if _start <= 352 && _end > 352 {
                        _buf[(352 - _start) as usize] = _value[0];
                    }
                    if _start <= 353 && _end > 353 {
                        _buf[(353 - _start) as usize] = _value[1];
                    }
                    if _start <= 354 && _end > 354 {
                        _buf[(354 - _start) as usize] = _value[2];
                    }
                    if _start <= 355 && _end > 355 {
                        _buf[(355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 364 && _end > 360 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_pregionn_wa(1)?
                        .to_ne_bytes();
                    if _start <= 360 && _end > 360 {
                        _buf[(360 - _start) as usize] = _value[0];
                    }
                    if _start <= 361 && _end > 361 {
                        _buf[(361 - _start) as usize] = _value[1];
                    }
                    if _start <= 362 && _end > 362 {
                        _buf[(362 - _start) as usize] = _value[2];
                    }
                    if _start <= 363 && _end > 363 {
                        _buf[(363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 360 && _end > 356 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_pregionn_ra(0)?
                        .to_ne_bytes();
                    if _start <= 356 && _end > 356 {
                        _buf[(356 - _start) as usize] = _value[0];
                    }
                    if _start <= 357 && _end > 357 {
                        _buf[(357 - _start) as usize] = _value[1];
                    }
                    if _start <= 358 && _end > 358 {
                        _buf[(358 - _start) as usize] = _value[2];
                    }
                    if _start <= 359 && _end > 359 {
                        _buf[(359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 368 && _end > 364 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_events_pregionn_ra(1)?
                        .to_ne_bytes();
                    if _start <= 364 && _end > 364 {
                        _buf[(364 - _start) as usize] = _value[0];
                    }
                    if _start <= 365 && _end > 365 {
                        _buf[(365 - _start) as usize] = _value[1];
                    }
                    if _start <= 366 && _end > 366 {
                        _buf[(366 - _start) as usize] = _value[2];
                    }
                    if _start <= 367 && _end > 367 {
                        _buf[(367 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_mwu_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self.read_mwu_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_mwu_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (800..=811, 801..=812) => {
                if _start < 804 && _end > 800 {
                    let _value = self.read_mwu_nmien()?.to_ne_bytes();
                    if _start <= 800 && _end > 800 {
                        _buf[(800 - _start) as usize] = _value[0];
                    }
                    if _start <= 801 && _end > 801 {
                        _buf[(801 - _start) as usize] = _value[1];
                    }
                    if _start <= 802 && _end > 802 {
                        _buf[(802 - _start) as usize] = _value[2];
                    }
                    if _start <= 803 && _end > 803 {
                        _buf[(803 - _start) as usize] = _value[3];
                    }
                }
                if _start < 808 && _end > 804 {
                    let _value = self.read_mwu_nmienset()?.to_ne_bytes();
                    if _start <= 804 && _end > 804 {
                        _buf[(804 - _start) as usize] = _value[0];
                    }
                    if _start <= 805 && _end > 805 {
                        _buf[(805 - _start) as usize] = _value[1];
                    }
                    if _start <= 806 && _end > 806 {
                        _buf[(806 - _start) as usize] = _value[2];
                    }
                    if _start <= 807 && _end > 807 {
                        _buf[(807 - _start) as usize] = _value[3];
                    }
                }
                if _start < 812 && _end > 808 {
                    let _value = self.read_mwu_nmienclr()?.to_ne_bytes();
                    if _start <= 808 && _end > 808 {
                        _buf[(808 - _start) as usize] = _value[0];
                    }
                    if _start <= 809 && _end > 809 {
                        _buf[(809 - _start) as usize] = _value[1];
                    }
                    if _start <= 810 && _end > 810 {
                        _buf[(810 - _start) as usize] = _value[2];
                    }
                    if _start <= 811 && _end > 811 {
                        _buf[(811 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1039, 1025..=1040) => {
                if _start < 1028 && _end > 1024 {
                    let _value =
                        self.read_mwu_perregionn_substatwa(0)?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1036 && _end > 1032 {
                    let _value =
                        self.read_mwu_perregionn_substatwa(1)?.to_ne_bytes();
                    if _start <= 1032 && _end > 1032 {
                        _buf[(1032 - _start) as usize] = _value[0];
                    }
                    if _start <= 1033 && _end > 1033 {
                        _buf[(1033 - _start) as usize] = _value[1];
                    }
                    if _start <= 1034 && _end > 1034 {
                        _buf[(1034 - _start) as usize] = _value[2];
                    }
                    if _start <= 1035 && _end > 1035 {
                        _buf[(1035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1032 && _end > 1028 {
                    let _value =
                        self.read_mwu_perregionn_substatra(0)?.to_ne_bytes();
                    if _start <= 1028 && _end > 1028 {
                        _buf[(1028 - _start) as usize] = _value[0];
                    }
                    if _start <= 1029 && _end > 1029 {
                        _buf[(1029 - _start) as usize] = _value[1];
                    }
                    if _start <= 1030 && _end > 1030 {
                        _buf[(1030 - _start) as usize] = _value[2];
                    }
                    if _start <= 1031 && _end > 1031 {
                        _buf[(1031 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _value =
                        self.read_mwu_perregionn_substatra(1)?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1296..=1307, 1297..=1308) => {
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_mwu_regionen()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_mwu_regionenset()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_mwu_regionenclr()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1536..=1543, 1537..=1544) => {
                if _start < 1540 && _end > 1536 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_regionn_start(0)?
                        .to_ne_bytes();
                    if _start <= 1536 && _end > 1536 {
                        _buf[(1536 - _start) as usize] = _value[0];
                    }
                    if _start <= 1537 && _end > 1537 {
                        _buf[(1537 - _start) as usize] = _value[1];
                    }
                    if _start <= 1538 && _end > 1538 {
                        _buf[(1538 - _start) as usize] = _value[2];
                    }
                    if _start <= 1539 && _end > 1539 {
                        _buf[(1539 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1544 && _end > 1540 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_regionn_end(0)?
                        .to_ne_bytes();
                    if _start <= 1540 && _end > 1540 {
                        _buf[(1540 - _start) as usize] = _value[0];
                    }
                    if _start <= 1541 && _end > 1541 {
                        _buf[(1541 - _start) as usize] = _value[1];
                    }
                    if _start <= 1542 && _end > 1542 {
                        _buf[(1542 - _start) as usize] = _value[2];
                    }
                    if _start <= 1543 && _end > 1543 {
                        _buf[(1543 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1552..=1559, 1553..=1560) => {
                if _start < 1556 && _end > 1552 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_regionn_start(1)?
                        .to_ne_bytes();
                    if _start <= 1552 && _end > 1552 {
                        _buf[(1552 - _start) as usize] = _value[0];
                    }
                    if _start <= 1553 && _end > 1553 {
                        _buf[(1553 - _start) as usize] = _value[1];
                    }
                    if _start <= 1554 && _end > 1554 {
                        _buf[(1554 - _start) as usize] = _value[2];
                    }
                    if _start <= 1555 && _end > 1555 {
                        _buf[(1555 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1560 && _end > 1556 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_regionn_end(1)?
                        .to_ne_bytes();
                    if _start <= 1556 && _end > 1556 {
                        _buf[(1556 - _start) as usize] = _value[0];
                    }
                    if _start <= 1557 && _end > 1557 {
                        _buf[(1557 - _start) as usize] = _value[1];
                    }
                    if _start <= 1558 && _end > 1558 {
                        _buf[(1558 - _start) as usize] = _value[2];
                    }
                    if _start <= 1559 && _end > 1559 {
                        _buf[(1559 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1568..=1575, 1569..=1576) => {
                if _start < 1572 && _end > 1568 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_regionn_start(2)?
                        .to_ne_bytes();
                    if _start <= 1568 && _end > 1568 {
                        _buf[(1568 - _start) as usize] = _value[0];
                    }
                    if _start <= 1569 && _end > 1569 {
                        _buf[(1569 - _start) as usize] = _value[1];
                    }
                    if _start <= 1570 && _end > 1570 {
                        _buf[(1570 - _start) as usize] = _value[2];
                    }
                    if _start <= 1571 && _end > 1571 {
                        _buf[(1571 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1576 && _end > 1572 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_regionn_end(2)?
                        .to_ne_bytes();
                    if _start <= 1572 && _end > 1572 {
                        _buf[(1572 - _start) as usize] = _value[0];
                    }
                    if _start <= 1573 && _end > 1573 {
                        _buf[(1573 - _start) as usize] = _value[1];
                    }
                    if _start <= 1574 && _end > 1574 {
                        _buf[(1574 - _start) as usize] = _value[2];
                    }
                    if _start <= 1575 && _end > 1575 {
                        _buf[(1575 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1584..=1591, 1585..=1592) => {
                if _start < 1588 && _end > 1584 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_regionn_start(3)?
                        .to_ne_bytes();
                    if _start <= 1584 && _end > 1584 {
                        _buf[(1584 - _start) as usize] = _value[0];
                    }
                    if _start <= 1585 && _end > 1585 {
                        _buf[(1585 - _start) as usize] = _value[1];
                    }
                    if _start <= 1586 && _end > 1586 {
                        _buf[(1586 - _start) as usize] = _value[2];
                    }
                    if _start <= 1587 && _end > 1587 {
                        _buf[(1587 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1592 && _end > 1588 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_regionn_end(3)?
                        .to_ne_bytes();
                    if _start <= 1588 && _end > 1588 {
                        _buf[(1588 - _start) as usize] = _value[0];
                    }
                    if _start <= 1589 && _end > 1589 {
                        _buf[(1589 - _start) as usize] = _value[1];
                    }
                    if _start <= 1590 && _end > 1590 {
                        _buf[(1590 - _start) as usize] = _value[2];
                    }
                    if _start <= 1591 && _end > 1591 {
                        _buf[(1591 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1728..=1739, 1729..=1740) => {
                if _start < 1732 && _end > 1728 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_pregionn_start(0)?
                        .to_ne_bytes();
                    if _start <= 1728 && _end > 1728 {
                        _buf[(1728 - _start) as usize] = _value[0];
                    }
                    if _start <= 1729 && _end > 1729 {
                        _buf[(1729 - _start) as usize] = _value[1];
                    }
                    if _start <= 1730 && _end > 1730 {
                        _buf[(1730 - _start) as usize] = _value[2];
                    }
                    if _start <= 1731 && _end > 1731 {
                        _buf[(1731 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1736 && _end > 1732 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_pregionn_end(0)?
                        .to_ne_bytes();
                    if _start <= 1732 && _end > 1732 {
                        _buf[(1732 - _start) as usize] = _value[0];
                    }
                    if _start <= 1733 && _end > 1733 {
                        _buf[(1733 - _start) as usize] = _value[1];
                    }
                    if _start <= 1734 && _end > 1734 {
                        _buf[(1734 - _start) as usize] = _value[2];
                    }
                    if _start <= 1735 && _end > 1735 {
                        _buf[(1735 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1740 && _end > 1736 {
                    let _value = self.read_mwu_pregionn_subs(0)?.to_ne_bytes();
                    if _start <= 1736 && _end > 1736 {
                        _buf[(1736 - _start) as usize] = _value[0];
                    }
                    if _start <= 1737 && _end > 1737 {
                        _buf[(1737 - _start) as usize] = _value[1];
                    }
                    if _start <= 1738 && _end > 1738 {
                        _buf[(1738 - _start) as usize] = _value[2];
                    }
                    if _start <= 1739 && _end > 1739 {
                        _buf[(1739 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1744..=1755, 1745..=1756) => {
                if _start < 1748 && _end > 1744 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_pregionn_start(1)?
                        .to_ne_bytes();
                    if _start <= 1744 && _end > 1744 {
                        _buf[(1744 - _start) as usize] = _value[0];
                    }
                    if _start <= 1745 && _end > 1745 {
                        _buf[(1745 - _start) as usize] = _value[1];
                    }
                    if _start <= 1746 && _end > 1746 {
                        _buf[(1746 - _start) as usize] = _value[2];
                    }
                    if _start <= 1747 && _end > 1747 {
                        _buf[(1747 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1752 && _end > 1748 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_mwu_pregionn_end(1)?
                        .to_ne_bytes();
                    if _start <= 1748 && _end > 1748 {
                        _buf[(1748 - _start) as usize] = _value[0];
                    }
                    if _start <= 1749 && _end > 1749 {
                        _buf[(1749 - _start) as usize] = _value[1];
                    }
                    if _start <= 1750 && _end > 1750 {
                        _buf[(1750 - _start) as usize] = _value[2];
                    }
                    if _start <= 1751 && _end > 1751 {
                        _buf[(1751 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1756 && _end > 1752 {
                    let _value = self.read_mwu_pregionn_subs(1)?.to_ne_bytes();
                    if _start <= 1752 && _end > 1752 {
                        _buf[(1752 - _start) as usize] = _value[0];
                    }
                    if _start <= 1753 && _end > 1753 {
                        _buf[(1753 - _start) as usize] = _value[1];
                    }
                    if _start <= 1754 && _end > 1754 {
                        _buf[(1754 - _start) as usize] = _value[2];
                    }
                    if _start <= 1755 && _end > 1755 {
                        _buf[(1755 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073872896;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for MWU WA not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_regionn_wa(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for MWU WA not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_regionn_wa(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272 && _end >= 276u64,
                        "partial write for MWU WA not implemented",
                    );
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_regionn_wa(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert!(
                        _start <= 280 && _end >= 284u64,
                        "partial write for MWU WA not implemented",
                    );
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_regionn_wa(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for MWU RA not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_regionn_ra(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268 && _end >= 272u64,
                        "partial write for MWU RA not implemented",
                    );
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_regionn_ra(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert!(
                        _start <= 276 && _end >= 280u64,
                        "partial write for MWU RA not implemented",
                    );
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_regionn_ra(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284 && _end >= 288u64,
                        "partial write for MWU RA not implemented",
                    );
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_regionn_ra(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (352..=367, 353..=368) => {
                if _start < 356 && _end > 352 {
                    assert!(
                        _start <= 352 && _end >= 356u64,
                        "partial write for MWU WA not implemented",
                    );
                    let start = _start.saturating_sub(352) as usize;
                    let end =
                        (_end.saturating_sub(352) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_pregionn_wa(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 364 && _end > 360 {
                    assert!(
                        _start <= 360 && _end >= 364u64,
                        "partial write for MWU WA not implemented",
                    );
                    let start = _start.saturating_sub(360) as usize;
                    let end =
                        (_end.saturating_sub(360) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_pregionn_wa(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 360 && _end > 356 {
                    assert!(
                        _start <= 356 && _end >= 360u64,
                        "partial write for MWU RA not implemented",
                    );
                    let start = _start.saturating_sub(356) as usize;
                    let end =
                        (_end.saturating_sub(356) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_pregionn_ra(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 368 && _end > 364 {
                    assert!(
                        _start <= 364 && _end >= 368u64,
                        "partial write for MWU RA not implemented",
                    );
                    let start = _start.saturating_sub(364) as usize;
                    let end =
                        (_end.saturating_sub(364) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_events_pregionn_ra(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_mwu_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_mwu_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_mwu_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (800..=811, 801..=812) => {
                if _start < 804 && _end > 800 {
                    let offset = _start.saturating_sub(800);
                    let start = 800u64.saturating_sub(_start) as usize;
                    let end = ((_end - 800) - offset) as usize;
                    self.write_mwu_nmien(offset, &_buf[start..end])?;
                }
                if _start < 808 && _end > 804 {
                    let offset = _start.saturating_sub(804);
                    let start = 804u64.saturating_sub(_start) as usize;
                    let end = ((_end - 804) - offset) as usize;
                    self.write_mwu_nmienset(offset, &_buf[start..end])?;
                }
                if _start < 812 && _end > 808 {
                    let offset = _start.saturating_sub(808);
                    let start = 808u64.saturating_sub(_start) as usize;
                    let end = ((_end - 808) - offset) as usize;
                    self.write_mwu_nmienclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1024..=1039, 1025..=1040) => {
                if _start < 1028 && _end > 1024 {
                    let offset = _start.saturating_sub(1024);
                    let start = 1024u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1024) - offset) as usize;
                    self.write_mwu_perregionn_substatwa(
                        0,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1036 && _end > 1032 {
                    let offset = _start.saturating_sub(1032);
                    let start = 1032u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1032) - offset) as usize;
                    self.write_mwu_perregionn_substatwa(
                        1,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1032 && _end > 1028 {
                    let offset = _start.saturating_sub(1028);
                    let start = 1028u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1028) - offset) as usize;
                    self.write_mwu_perregionn_substatra(
                        0,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                if _start < 1040 && _end > 1036 {
                    let offset = _start.saturating_sub(1036);
                    let start = 1036u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1036) - offset) as usize;
                    self.write_mwu_perregionn_substatra(
                        1,
                        offset,
                        &_buf[start..end],
                    )?;
                }
                Ok(())
            }
            (1296..=1307, 1297..=1308) => {
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_mwu_regionen(offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_mwu_regionenset(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_mwu_regionenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1536..=1543, 1537..=1544) => {
                if _start < 1540 && _end > 1536 {
                    assert!(
                        _start <= 1536 && _end >= 1540u64,
                        "partial write for MWU START not implemented",
                    );
                    let start = _start.saturating_sub(1536) as usize;
                    let end =
                        (_end.saturating_sub(1536) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_regionn_start(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1544 && _end > 1540 {
                    assert!(
                        _start <= 1540 && _end >= 1544u64,
                        "partial write for MWU END not implemented",
                    );
                    let start = _start.saturating_sub(1540) as usize;
                    let end =
                        (_end.saturating_sub(1540) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_regionn_end(
                        0,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1552..=1559, 1553..=1560) => {
                if _start < 1556 && _end > 1552 {
                    assert!(
                        _start <= 1552 && _end >= 1556u64,
                        "partial write for MWU START not implemented",
                    );
                    let start = _start.saturating_sub(1552) as usize;
                    let end =
                        (_end.saturating_sub(1552) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_regionn_start(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1560 && _end > 1556 {
                    assert!(
                        _start <= 1556 && _end >= 1560u64,
                        "partial write for MWU END not implemented",
                    );
                    let start = _start.saturating_sub(1556) as usize;
                    let end =
                        (_end.saturating_sub(1556) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_regionn_end(
                        1,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1568..=1575, 1569..=1576) => {
                if _start < 1572 && _end > 1568 {
                    assert!(
                        _start <= 1568 && _end >= 1572u64,
                        "partial write for MWU START not implemented",
                    );
                    let start = _start.saturating_sub(1568) as usize;
                    let end =
                        (_end.saturating_sub(1568) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_regionn_start(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1576 && _end > 1572 {
                    assert!(
                        _start <= 1572 && _end >= 1576u64,
                        "partial write for MWU END not implemented",
                    );
                    let start = _start.saturating_sub(1572) as usize;
                    let end =
                        (_end.saturating_sub(1572) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_regionn_end(
                        2,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1584..=1591, 1585..=1592) => {
                if _start < 1588 && _end > 1584 {
                    assert!(
                        _start <= 1584 && _end >= 1588u64,
                        "partial write for MWU START not implemented",
                    );
                    let start = _start.saturating_sub(1584) as usize;
                    let end =
                        (_end.saturating_sub(1584) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_regionn_start(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1592 && _end > 1588 {
                    assert!(
                        _start <= 1588 && _end >= 1592u64,
                        "partial write for MWU END not implemented",
                    );
                    let start = _start.saturating_sub(1588) as usize;
                    let end =
                        (_end.saturating_sub(1588) as usize).min(start + 4);
                    self.0.lock().unwrap().write_mwu_regionn_end(
                        3,
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1728..=1739, 1729..=1740) => {
                if _start < 1732 && _end > 1728 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1736 && _end > 1732 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1740 && _end > 1736 {
                    let offset = _start.saturating_sub(1736);
                    let start = 1736u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1736) - offset) as usize;
                    self.write_mwu_pregionn_subs(0, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1744..=1755, 1745..=1756) => {
                if _start < 1748 && _end > 1744 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1752 && _end > 1748 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1756 && _end > 1752 {
                    let offset = _start.saturating_sub(1752);
                    let start = 1752u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1752) - offset) as usize;
                    self.write_mwu_pregionn_subs(1, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40020000 {
    fn read_mwu_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_inten_region0wa()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_inten_region0ra()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_inten_region1wa()?)
            << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_inten_region1ra()?)
            << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_inten_region2wa()?)
            << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_inten_region2ra()?)
            << 5u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_inten_region3wa()?)
            << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_inten_region3ra()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_inten_pregion0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_inten_pregion0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_inten_pregion1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_inten_pregion1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_inten(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_region0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_region0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_region1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_region1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_region2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_region2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_region3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_region3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_pregion0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_pregion0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_pregion1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_inten_pregion1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_region0wa()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_region0ra()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_region1wa()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_region1ra()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_region2wa()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_region2ra()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_region3wa()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_region3ra()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_pregion0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_pregion0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_pregion1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenset_pregion1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_region0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_region0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_region1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_region1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_region2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_region2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_region3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_region3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_pregion0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_pregion0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_pregion1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenset_pregion1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_region0wa()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_region0ra()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_region1wa()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_region1ra()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_region2wa()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_region2ra()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_region3wa()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_region3ra()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_pregion0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_pregion0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_pregion1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_intenclr_pregion1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_region0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_region0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_region1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_region1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_region2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_region2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_region3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_region3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_pregion0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_pregion0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_pregion1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_intenclr_pregion1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_nmien(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_nmien_region0wa()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_nmien_region0ra()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_nmien_region1wa()?)
            << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_nmien_region1ra()?)
            << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_nmien_region2wa()?)
            << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_nmien_region2ra()?)
            << 5u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_nmien_region3wa()?)
            << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_nmien_region3ra()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmien_pregion0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmien_pregion0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmien_pregion1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmien_pregion1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_nmien(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_region0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_region0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_region1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_region1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_region2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_region2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_region3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_region3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_pregion0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_pregion0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_pregion1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmien_pregion1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_nmienset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_region0wa()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_region0ra()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_region1wa()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_region1ra()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_region2wa()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_region2ra()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_region3wa()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_region3ra()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_pregion0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_pregion0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_pregion1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienset_pregion1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_nmienset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_region0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_region0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_region1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_region1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_region2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_region2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_region3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_region3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_pregion0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_pregion0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_pregion1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienset_pregion1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_nmienclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_region0wa()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_region0ra()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_region1wa()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_region1ra()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_region2wa()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_region2ra()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_region3wa()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_region3ra()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_pregion0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_pregion0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_pregion1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_nmienclr_pregion1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_nmienclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_region0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_region0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_region1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_region1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_region2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_region2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_region3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_region3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_pregion0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_pregion0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_pregion1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_nmienclr_pregion1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_perregionn_substatwa(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr0(_dim)?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr1(_dim)?,
        ) << 1u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr2(_dim)?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr3(_dim)?,
        ) << 3u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr4(_dim)?,
        ) << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr5(_dim)?,
        ) << 5u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr6(_dim)?,
        ) << 6u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr7(_dim)?,
        ) << 7u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr8(_dim)?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr9(_dim)?,
        ) << 9u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr10(_dim)?,
        ) << 10u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr11(_dim)?,
        ) << 11u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr12(_dim)?,
        ) << 12u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr13(_dim)?,
        ) << 13u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr14(_dim)?,
        ) << 14u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr15(_dim)?,
        ) << 15u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr16(_dim)?,
        ) << 16u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr17(_dim)?,
        ) << 17u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr18(_dim)?,
        ) << 18u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr19(_dim)?,
        ) << 19u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr20(_dim)?,
        ) << 20u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr21(_dim)?,
        ) << 21u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr22(_dim)?,
        ) << 22u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr23(_dim)?,
        ) << 23u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr24(_dim)?,
        ) << 24u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr25(_dim)?,
        ) << 25u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr26(_dim)?,
        ) << 26u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr27(_dim)?,
        ) << 27u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr28(_dim)?,
        ) << 28u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr29(_dim)?,
        ) << 29u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr30(_dim)?,
        ) << 30u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatwa_sr31(_dim)?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_mwu_perregionn_substatwa(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr0(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr1(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr2(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr3(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr4(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr5(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr6(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr7(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr8(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr9(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr10(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr11(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr12(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr13(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr14(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr15(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr16(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr17(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr18(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr19(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr20(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr21(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr22(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr23(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr24(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr25(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr26(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr27(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr28(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr29(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr30(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatwa_sr31(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_mwu_perregionn_substatra(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr0(_dim)?,
        ) << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr1(_dim)?,
        ) << 1u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr2(_dim)?,
        ) << 2u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr3(_dim)?,
        ) << 3u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr4(_dim)?,
        ) << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr5(_dim)?,
        ) << 5u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr6(_dim)?,
        ) << 6u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr7(_dim)?,
        ) << 7u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr8(_dim)?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr9(_dim)?,
        ) << 9u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr10(_dim)?,
        ) << 10u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr11(_dim)?,
        ) << 11u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr12(_dim)?,
        ) << 12u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr13(_dim)?,
        ) << 13u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr14(_dim)?,
        ) << 14u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr15(_dim)?,
        ) << 15u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr16(_dim)?,
        ) << 16u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr17(_dim)?,
        ) << 17u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr18(_dim)?,
        ) << 18u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr19(_dim)?,
        ) << 19u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr20(_dim)?,
        ) << 20u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr21(_dim)?,
        ) << 21u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr22(_dim)?,
        ) << 22u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr23(_dim)?,
        ) << 23u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr24(_dim)?,
        ) << 24u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr25(_dim)?,
        ) << 25u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr26(_dim)?,
        ) << 26u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr27(_dim)?,
        ) << 27u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr28(_dim)?,
        ) << 28u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr29(_dim)?,
        ) << 29u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr30(_dim)?,
        ) << 30u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_mwu_perregionn_substatra_sr31(_dim)?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_mwu_perregionn_substatra(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr0(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr1(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr2(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr3(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr4(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr5(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr6(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr7(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr8(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr9(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr10(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr11(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr12(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr13(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr14(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr15(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr16(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr17(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr18(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr19(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr20(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr21(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr22(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr23(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr24(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr25(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr26(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr27(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr28(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr29(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr30(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_perregionn_substatra_sr31(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
    fn read_mwu_regionen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_regionen_rgn0wa()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_regionen_rgn0ra()?)
            << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_regionen_rgn1wa()?)
            << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_regionen_rgn1ra()?)
            << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_regionen_rgn2wa()?)
            << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_regionen_rgn2ra()?)
            << 5u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_regionen_rgn3wa()?)
            << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_mwu_regionen_rgn3ra()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionen_prgn0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionen_prgn0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionen_prgn1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionen_prgn1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_regionen(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_rgn0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_rgn0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_rgn1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_rgn1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_rgn2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_rgn2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_rgn3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_rgn3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_prgn0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_prgn0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_prgn1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionen_prgn1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_regionenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_rgn0wa()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_rgn0ra()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_rgn1wa()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_rgn1ra()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_rgn2wa()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_rgn2ra()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_rgn3wa()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_rgn3ra()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_prgn0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_prgn0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_prgn1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenset_prgn1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_regionenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_rgn0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_rgn0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_rgn1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_rgn1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_rgn2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_rgn2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_rgn3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_rgn3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_prgn0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_prgn0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_prgn1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenset_prgn1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_regionenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_rgn0wa()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_rgn0ra()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_rgn1wa()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_rgn1ra()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_rgn2wa()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_rgn2ra()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_rgn3wa()?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_rgn3ra()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_prgn0wa()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_prgn0ra()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_prgn1wa()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_regionenclr_prgn1ra()?)
                << 27u32;
        Ok(_value)
    }
    fn write_mwu_regionenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_rgn0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_rgn0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_rgn1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_rgn1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_rgn2wa((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_rgn2ra((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_rgn3wa((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_rgn3ra((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_prgn0wa((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_prgn0ra((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_prgn1wa((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mwu_regionenclr_prgn1ra((_value[_i] >> 3) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mwu_pregionn_subs(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr0(_dim)?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr1(_dim)?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr2(_dim)?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr3(_dim)?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr4(_dim)?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr5(_dim)?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr6(_dim)?)
                << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr7(_dim)?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr8(_dim)?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mwu_pregionn_subs_sr9(_dim)?)
                << 9u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr10(_dim)?,
        ) << 10u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr11(_dim)?,
        ) << 11u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr12(_dim)?,
        ) << 12u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr13(_dim)?,
        ) << 13u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr14(_dim)?,
        ) << 14u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr15(_dim)?,
        ) << 15u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr16(_dim)?,
        ) << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr17(_dim)?,
        ) << 17u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr18(_dim)?,
        ) << 18u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr19(_dim)?,
        ) << 19u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr20(_dim)?,
        ) << 20u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr21(_dim)?,
        ) << 21u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr22(_dim)?,
        ) << 22u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr23(_dim)?,
        ) << 23u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr24(_dim)?,
        ) << 24u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr25(_dim)?,
        ) << 25u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr26(_dim)?,
        ) << 26u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr27(_dim)?,
        ) << 27u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr28(_dim)?,
        ) << 28u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr29(_dim)?,
        ) << 29u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr30(_dim)?,
        ) << 30u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_mwu_pregionn_subs_sr31(_dim)?,
        ) << 31u32;
        Ok(_value)
    }
    fn write_mwu_pregionn_subs(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr0(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr1(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr2(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr3(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr4(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr5(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr6(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr7(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr8(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr9(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr10(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr11(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr12(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr13(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr14(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr15(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr16(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr17(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr18(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr19(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr20(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr21(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr22(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr23(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr24(
                _dim,
                (_value[_i] >> 0) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr25(
                _dim,
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr26(
                _dim,
                (_value[_i] >> 2) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr27(
                _dim,
                (_value[_i] >> 3) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr28(
                _dim,
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr29(
                _dim,
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr30(
                _dim,
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0.lock().unwrap().write_mwu_pregionn_subs_sr31(
                _dim,
                (_value[_i] >> 7) & 1 != 0,
            )?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40025000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40025000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073893376;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_i2s_events_rxptrupd()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_i2s_events_stopped()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (276..=279, 277..=280) => {
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_i2s_events_txptrupd()?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _value = self.read_i2s_inten()?.to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self.read_i2s_intenset()?.to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self.read_i2s_intenclr()?.to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let _value = self.read_i2s_enable()?.to_ne_bytes();
                    if _start <= 1280 && _end > 1280 {
                        _buf[(1280 - _start) as usize] = _value[0];
                    }
                    if _start <= 1281 && _end > 1281 {
                        _buf[(1281 - _start) as usize] = _value[1];
                    }
                    if _start <= 1282 && _end > 1282 {
                        _buf[(1282 - _start) as usize] = _value[2];
                    }
                    if _start <= 1283 && _end > 1283 {
                        _buf[(1283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_i2s_config_mode()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_i2s_config_rxen()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_i2s_config_txen()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_i2s_config_mcken()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_i2s_config_mckfreq()?
                        .to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_i2s_config_ratio()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_i2s_config_swidth()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_i2s_config_align()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_i2s_config_format()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _value = self.read_i2s_config_channels()?.to_ne_bytes();
                    if _start <= 1320 && _end > 1320 {
                        _buf[(1320 - _start) as usize] = _value[0];
                    }
                    if _start <= 1321 && _end > 1321 {
                        _buf[(1321 - _start) as usize] = _value[1];
                    }
                    if _start <= 1322 && _end > 1322 {
                        _buf[(1322 - _start) as usize] = _value[2];
                    }
                    if _start <= 1323 && _end > 1323 {
                        _buf[(1323 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_i2s_rxd_ptr()?
                        .to_ne_bytes();
                    if _start <= 1336 && _end > 1336 {
                        _buf[(1336 - _start) as usize] = _value[0];
                    }
                    if _start <= 1337 && _end > 1337 {
                        _buf[(1337 - _start) as usize] = _value[1];
                    }
                    if _start <= 1338 && _end > 1338 {
                        _buf[(1338 - _start) as usize] = _value[2];
                    }
                    if _start <= 1339 && _end > 1339 {
                        _buf[(1339 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1344..=1347, 1345..=1348) => {
                if _start < 1348 && _end > 1344 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_i2s_txd_ptr()?
                        .to_ne_bytes();
                    if _start <= 1344 && _end > 1344 {
                        _buf[(1344 - _start) as usize] = _value[0];
                    }
                    if _start <= 1345 && _end > 1345 {
                        _buf[(1345 - _start) as usize] = _value[1];
                    }
                    if _start <= 1346 && _end > 1346 {
                        _buf[(1346 - _start) as usize] = _value[2];
                    }
                    if _start <= 1347 && _end > 1347 {
                        _buf[(1347 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1360..=1363, 1361..=1364) => {
                if _start < 1364 && _end > 1360 {
                    let _value = self.read_i2s_rxtxd_maxcnt()?.to_ne_bytes();
                    if _start <= 1360 && _end > 1360 {
                        _buf[(1360 - _start) as usize] = _value[0];
                    }
                    if _start <= 1361 && _end > 1361 {
                        _buf[(1361 - _start) as usize] = _value[1];
                    }
                    if _start <= 1362 && _end > 1362 {
                        _buf[(1362 - _start) as usize] = _value[2];
                    }
                    if _start <= 1363 && _end > 1363 {
                        _buf[(1363 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1376..=1395, 1377..=1396) => {
                if _start < 1380 && _end > 1376 {
                    let _value = self.read_i2s_psel_mck()?.to_ne_bytes();
                    if _start <= 1376 && _end > 1376 {
                        _buf[(1376 - _start) as usize] = _value[0];
                    }
                    if _start <= 1377 && _end > 1377 {
                        _buf[(1377 - _start) as usize] = _value[1];
                    }
                    if _start <= 1378 && _end > 1378 {
                        _buf[(1378 - _start) as usize] = _value[2];
                    }
                    if _start <= 1379 && _end > 1379 {
                        _buf[(1379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1384 && _end > 1380 {
                    let _value = self.read_i2s_psel_sck()?.to_ne_bytes();
                    if _start <= 1380 && _end > 1380 {
                        _buf[(1380 - _start) as usize] = _value[0];
                    }
                    if _start <= 1381 && _end > 1381 {
                        _buf[(1381 - _start) as usize] = _value[1];
                    }
                    if _start <= 1382 && _end > 1382 {
                        _buf[(1382 - _start) as usize] = _value[2];
                    }
                    if _start <= 1383 && _end > 1383 {
                        _buf[(1383 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1388 && _end > 1384 {
                    let _value = self.read_i2s_psel_lrck()?.to_ne_bytes();
                    if _start <= 1384 && _end > 1384 {
                        _buf[(1384 - _start) as usize] = _value[0];
                    }
                    if _start <= 1385 && _end > 1385 {
                        _buf[(1385 - _start) as usize] = _value[1];
                    }
                    if _start <= 1386 && _end > 1386 {
                        _buf[(1386 - _start) as usize] = _value[2];
                    }
                    if _start <= 1387 && _end > 1387 {
                        _buf[(1387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1392 && _end > 1388 {
                    let _value = self.read_i2s_psel_sdin()?.to_ne_bytes();
                    if _start <= 1388 && _end > 1388 {
                        _buf[(1388 - _start) as usize] = _value[0];
                    }
                    if _start <= 1389 && _end > 1389 {
                        _buf[(1389 - _start) as usize] = _value[1];
                    }
                    if _start <= 1390 && _end > 1390 {
                        _buf[(1390 - _start) as usize] = _value[2];
                    }
                    if _start <= 1391 && _end > 1391 {
                        _buf[(1391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1396 && _end > 1392 {
                    let _value = self.read_i2s_psel_sdout()?.to_ne_bytes();
                    if _start <= 1392 && _end > 1392 {
                        _buf[(1392 - _start) as usize] = _value[0];
                    }
                    if _start <= 1393 && _end > 1393 {
                        _buf[(1393 - _start) as usize] = _value[1];
                    }
                    if _start <= 1394 && _end > 1394 {
                        _buf[(1394 - _start) as usize] = _value[2];
                    }
                    if _start <= 1395 && _end > 1395 {
                        _buf[(1395 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073893376;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    assert!(
                        _start <= 0 && _end >= 4u64,
                        "partial write for I2S TASKS_START not implemented",
                    );
                    let start = _start.saturating_sub(0) as usize;
                    let end = (_end.saturating_sub(0) as usize).min(start + 4);
                    self.0.lock().unwrap().write_i2s_tasks_start(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 8 && _end > 4 {
                    assert!(
                        _start <= 4 && _end >= 8u64,
                        "partial write for I2S TASKS_STOP not implemented",
                    );
                    let start = _start.saturating_sub(4) as usize;
                    let end = (_end.saturating_sub(4) as usize).min(start + 4);
                    self.0.lock().unwrap().write_i2s_tasks_stop(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for I2S EVENTS_RXPTRUPD not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_i2s_events_rxptrupd(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for I2S EVENTS_STOPPED not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_i2s_events_stopped(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (276..=279, 277..=280) => {
                if _start < 280 && _end > 276 {
                    assert!(
                        _start <= 276 && _end >= 280u64,
                        "partial write for I2S EVENTS_TXPTRUPD not implemented",
                    );
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_i2s_events_txptrupd(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let offset = _start.saturating_sub(768);
                    let start = 768u64.saturating_sub(_start) as usize;
                    let end = ((_end - 768) - offset) as usize;
                    self.write_i2s_inten(offset, &_buf[start..end])?;
                }
                if _start < 776 && _end > 772 {
                    let offset = _start.saturating_sub(772);
                    let start = 772u64.saturating_sub(_start) as usize;
                    let end = ((_end - 772) - offset) as usize;
                    self.write_i2s_intenset(offset, &_buf[start..end])?;
                }
                if _start < 780 && _end > 776 {
                    let offset = _start.saturating_sub(776);
                    let start = 776u64.saturating_sub(_start) as usize;
                    let end = ((_end - 776) - offset) as usize;
                    self.write_i2s_intenclr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let offset = _start.saturating_sub(1280);
                    let start = 1280u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1280) - offset) as usize;
                    self.write_i2s_enable(offset, &_buf[start..end])?;
                }
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_i2s_config_mode(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_i2s_config_rxen(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_i2s_config_txen(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    let offset = _start.saturating_sub(1296);
                    let start = 1296u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1296) - offset) as usize;
                    self.write_i2s_config_mcken(offset, &_buf[start..end])?;
                }
                if _start < 1304 && _end > 1300 {
                    assert!(
                        _start <= 1300 && _end >= 1304u64,
                        "partial write for I2S MCKFREQ not implemented",
                    );
                    let start = _start.saturating_sub(1300) as usize;
                    let end =
                        (_end.saturating_sub(1300) as usize).min(start + 4);
                    self.0.lock().unwrap().write_i2s_config_mckfreq(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_i2s_config_ratio(offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_i2s_config_swidth(offset, &_buf[start..end])?;
                }
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_i2s_config_align(offset, &_buf[start..end])?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_i2s_config_format(offset, &_buf[start..end])?;
                }
                if _start < 1324 && _end > 1320 {
                    let offset = _start.saturating_sub(1320);
                    let start = 1320u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1320) - offset) as usize;
                    self.write_i2s_config_channels(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    assert!(
                        _start <= 1336 && _end >= 1340u64,
                        "partial write for I2S PTR not implemented",
                    );
                    let start = _start.saturating_sub(1336) as usize;
                    let end =
                        (_end.saturating_sub(1336) as usize).min(start + 4);
                    self.0.lock().unwrap().write_i2s_rxd_ptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1344..=1347, 1345..=1348) => {
                if _start < 1348 && _end > 1344 {
                    assert!(
                        _start <= 1344 && _end >= 1348u64,
                        "partial write for I2S PTR not implemented",
                    );
                    let start = _start.saturating_sub(1344) as usize;
                    let end =
                        (_end.saturating_sub(1344) as usize).min(start + 4);
                    self.0.lock().unwrap().write_i2s_txd_ptr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1360..=1363, 1361..=1364) => {
                if _start < 1364 && _end > 1360 {
                    let offset = _start.saturating_sub(1360);
                    let start = 1360u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1360) - offset) as usize;
                    self.write_i2s_rxtxd_maxcnt(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1376..=1395, 1377..=1396) => {
                if _start < 1380 && _end > 1376 {
                    let offset = _start.saturating_sub(1376);
                    let start = 1376u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1376) - offset) as usize;
                    self.write_i2s_psel_mck(offset, &_buf[start..end])?;
                }
                if _start < 1384 && _end > 1380 {
                    let offset = _start.saturating_sub(1380);
                    let start = 1380u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1380) - offset) as usize;
                    self.write_i2s_psel_sck(offset, &_buf[start..end])?;
                }
                if _start < 1388 && _end > 1384 {
                    let offset = _start.saturating_sub(1384);
                    let start = 1384u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1384) - offset) as usize;
                    self.write_i2s_psel_lrck(offset, &_buf[start..end])?;
                }
                if _start < 1392 && _end > 1388 {
                    let offset = _start.saturating_sub(1388);
                    let start = 1388u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1388) - offset) as usize;
                    self.write_i2s_psel_sdin(offset, &_buf[start..end])?;
                }
                if _start < 1396 && _end > 1392 {
                    let offset = _start.saturating_sub(1392);
                    let start = 1392u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1392) - offset) as usize;
                    self.write_i2s_psel_sdout(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40025000 {
    fn read_i2s_inten(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_i2s_inten_rxptrupd()?)
            << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_inten_stopped()?) << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_i2s_inten_txptrupd()?)
            << 5u32;
        Ok(_value)
    }
    fn write_i2s_inten(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_inten_rxptrupd((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_inten_stopped((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_inten_txptrupd((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_intenset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_intenset_rxptrupd()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_intenset_stopped()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_intenset_txptrupd()?)
                << 5u32;
        Ok(_value)
    }
    fn write_i2s_intenset(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_intenset_rxptrupd((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_intenset_stopped((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_intenset_txptrupd((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_intenclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_intenclr_rxptrupd()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_intenclr_stopped()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_intenclr_txptrupd()?)
                << 5u32;
        Ok(_value)
    }
    fn write_i2s_intenclr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_intenclr_rxptrupd((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_intenclr_stopped((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_intenclr_txptrupd((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_enable(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_enable_enable()?) << 0u32;
        Ok(_value)
    }
    fn write_i2s_enable(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_enable_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_config_mode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_config_mode_mode()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_mode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_mode_mode((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_config_rxen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_config_rxen_rxen()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_rxen(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_rxen_rxen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_config_txen(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_config_txen_txen()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_txen(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_txen_txen((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_config_mcken(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_config_mcken_mcken()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_mcken(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_mcken_mcken((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_config_ratio(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_config_ratio_ratio()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_ratio(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_ratio_ratio((_value[_i] >> 0) & 15u8)?;
        }
        Ok(())
    }
    fn read_i2s_config_swidth(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_config_swidth_swidth()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_swidth(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_swidth_swidth((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_i2s_config_align(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_config_align_align()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_align(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_align_align((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_config_format(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_config_format_format()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_format(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_format_format((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_config_channels(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_i2s_config_channels_channels()?,
        ) << 0u32;
        Ok(_value)
    }
    fn write_i2s_config_channels(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_config_channels_channels((_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
    fn read_i2s_rxtxd_maxcnt(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_rxtxd_maxcnt_maxcnt()?)
                << 0u32;
        Ok(_value)
    }
    fn write_i2s_rxtxd_maxcnt(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 63u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_i2s_rxtxd_maxcnt_maxcnt(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_i2s_psel_mck(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_mck_pin()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_mck_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_i2s_psel_mck(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_mck_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_mck_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_psel_sck(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_sck_pin()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_sck_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_i2s_psel_sck(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_sck_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_sck_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_psel_lrck(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_lrck_pin()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_lrck_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_i2s_psel_lrck(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_lrck_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_lrck_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_psel_sdin(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_sdin_pin()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_sdin_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_i2s_psel_sdin(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_sdin_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_sdin_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_i2s_psel_sdout(&self) -> MemResult<u32> {
        let mut _value = 2147483616;
        _value |= u32::from(self.0.lock().unwrap().read_i2s_psel_sdout_pin()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_i2s_psel_sdout_connect()?)
                << 31u32;
        Ok(_value)
    }
    fn write_i2s_psel_sdout(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_sdout_pin((_value[_i] >> 0) & 31u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_i2s_psel_sdout_connect((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0x40026000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x40026000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1073897472;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    let _value =
                        self.0.lock().unwrap().read_fpu_unused()?.to_ne_bytes();
                    if _start <= 0 && _end > 0 {
                        _buf[(0 - _start) as usize] = _value[0];
                    }
                    if _start <= 1 && _end > 1 {
                        _buf[(1 - _start) as usize] = _value[1];
                    }
                    if _start <= 2 && _end > 2 {
                        _buf[(2 - _start) as usize] = _value[2];
                    }
                    if _start <= 3 && _end > 3 {
                        _buf[(3 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1073897472;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => return Err(MemError::WriteViolation),
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x40026000 {}
pub(crate) struct PeripheralPage0x50000000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0x50000000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 1342177280;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1284..=1319, 1285..=1320) => {
                if _start < 1288 && _end > 1284 {
                    let _value = self.read_p0_out()?.to_ne_bytes();
                    if _start <= 1284 && _end > 1284 {
                        _buf[(1284 - _start) as usize] = _value[0];
                    }
                    if _start <= 1285 && _end > 1285 {
                        _buf[(1285 - _start) as usize] = _value[1];
                    }
                    if _start <= 1286 && _end > 1286 {
                        _buf[(1286 - _start) as usize] = _value[2];
                    }
                    if _start <= 1287 && _end > 1287 {
                        _buf[(1287 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _value = self.read_p0_outset()?.to_ne_bytes();
                    if _start <= 1288 && _end > 1288 {
                        _buf[(1288 - _start) as usize] = _value[0];
                    }
                    if _start <= 1289 && _end > 1289 {
                        _buf[(1289 - _start) as usize] = _value[1];
                    }
                    if _start <= 1290 && _end > 1290 {
                        _buf[(1290 - _start) as usize] = _value[2];
                    }
                    if _start <= 1291 && _end > 1291 {
                        _buf[(1291 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _value = self.read_p0_outclr()?.to_ne_bytes();
                    if _start <= 1292 && _end > 1292 {
                        _buf[(1292 - _start) as usize] = _value[0];
                    }
                    if _start <= 1293 && _end > 1293 {
                        _buf[(1293 - _start) as usize] = _value[1];
                    }
                    if _start <= 1294 && _end > 1294 {
                        _buf[(1294 - _start) as usize] = _value[2];
                    }
                    if _start <= 1295 && _end > 1295 {
                        _buf[(1295 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _value = self.read_p0_in()?.to_ne_bytes();
                    if _start <= 1296 && _end > 1296 {
                        _buf[(1296 - _start) as usize] = _value[0];
                    }
                    if _start <= 1297 && _end > 1297 {
                        _buf[(1297 - _start) as usize] = _value[1];
                    }
                    if _start <= 1298 && _end > 1298 {
                        _buf[(1298 - _start) as usize] = _value[2];
                    }
                    if _start <= 1299 && _end > 1299 {
                        _buf[(1299 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _value = self.read_p0_dir()?.to_ne_bytes();
                    if _start <= 1300 && _end > 1300 {
                        _buf[(1300 - _start) as usize] = _value[0];
                    }
                    if _start <= 1301 && _end > 1301 {
                        _buf[(1301 - _start) as usize] = _value[1];
                    }
                    if _start <= 1302 && _end > 1302 {
                        _buf[(1302 - _start) as usize] = _value[2];
                    }
                    if _start <= 1303 && _end > 1303 {
                        _buf[(1303 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _value = self.read_p0_dirset()?.to_ne_bytes();
                    if _start <= 1304 && _end > 1304 {
                        _buf[(1304 - _start) as usize] = _value[0];
                    }
                    if _start <= 1305 && _end > 1305 {
                        _buf[(1305 - _start) as usize] = _value[1];
                    }
                    if _start <= 1306 && _end > 1306 {
                        _buf[(1306 - _start) as usize] = _value[2];
                    }
                    if _start <= 1307 && _end > 1307 {
                        _buf[(1307 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _value = self.read_p0_dirclr()?.to_ne_bytes();
                    if _start <= 1308 && _end > 1308 {
                        _buf[(1308 - _start) as usize] = _value[0];
                    }
                    if _start <= 1309 && _end > 1309 {
                        _buf[(1309 - _start) as usize] = _value[1];
                    }
                    if _start <= 1310 && _end > 1310 {
                        _buf[(1310 - _start) as usize] = _value[2];
                    }
                    if _start <= 1311 && _end > 1311 {
                        _buf[(1311 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _value = self.read_p0_latch()?.to_ne_bytes();
                    if _start <= 1312 && _end > 1312 {
                        _buf[(1312 - _start) as usize] = _value[0];
                    }
                    if _start <= 1313 && _end > 1313 {
                        _buf[(1313 - _start) as usize] = _value[1];
                    }
                    if _start <= 1314 && _end > 1314 {
                        _buf[(1314 - _start) as usize] = _value[2];
                    }
                    if _start <= 1315 && _end > 1315 {
                        _buf[(1315 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _value = self.read_p0_detectmode()?.to_ne_bytes();
                    if _start <= 1316 && _end > 1316 {
                        _buf[(1316 - _start) as usize] = _value[0];
                    }
                    if _start <= 1317 && _end > 1317 {
                        _buf[(1317 - _start) as usize] = _value[1];
                    }
                    if _start <= 1318 && _end > 1318 {
                        _buf[(1318 - _start) as usize] = _value[2];
                    }
                    if _start <= 1319 && _end > 1319 {
                        _buf[(1319 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1792..=1919, 1793..=1920) => {
                if _start < 1796 && _end > 1792 {
                    let _value = self.read_p0_pin_cnfn(0)?.to_ne_bytes();
                    if _start <= 1792 && _end > 1792 {
                        _buf[(1792 - _start) as usize] = _value[0];
                    }
                    if _start <= 1793 && _end > 1793 {
                        _buf[(1793 - _start) as usize] = _value[1];
                    }
                    if _start <= 1794 && _end > 1794 {
                        _buf[(1794 - _start) as usize] = _value[2];
                    }
                    if _start <= 1795 && _end > 1795 {
                        _buf[(1795 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1800 && _end > 1796 {
                    let _value = self.read_p0_pin_cnfn(1)?.to_ne_bytes();
                    if _start <= 1796 && _end > 1796 {
                        _buf[(1796 - _start) as usize] = _value[0];
                    }
                    if _start <= 1797 && _end > 1797 {
                        _buf[(1797 - _start) as usize] = _value[1];
                    }
                    if _start <= 1798 && _end > 1798 {
                        _buf[(1798 - _start) as usize] = _value[2];
                    }
                    if _start <= 1799 && _end > 1799 {
                        _buf[(1799 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1804 && _end > 1800 {
                    let _value = self.read_p0_pin_cnfn(2)?.to_ne_bytes();
                    if _start <= 1800 && _end > 1800 {
                        _buf[(1800 - _start) as usize] = _value[0];
                    }
                    if _start <= 1801 && _end > 1801 {
                        _buf[(1801 - _start) as usize] = _value[1];
                    }
                    if _start <= 1802 && _end > 1802 {
                        _buf[(1802 - _start) as usize] = _value[2];
                    }
                    if _start <= 1803 && _end > 1803 {
                        _buf[(1803 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1808 && _end > 1804 {
                    let _value = self.read_p0_pin_cnfn(3)?.to_ne_bytes();
                    if _start <= 1804 && _end > 1804 {
                        _buf[(1804 - _start) as usize] = _value[0];
                    }
                    if _start <= 1805 && _end > 1805 {
                        _buf[(1805 - _start) as usize] = _value[1];
                    }
                    if _start <= 1806 && _end > 1806 {
                        _buf[(1806 - _start) as usize] = _value[2];
                    }
                    if _start <= 1807 && _end > 1807 {
                        _buf[(1807 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1812 && _end > 1808 {
                    let _value = self.read_p0_pin_cnfn(4)?.to_ne_bytes();
                    if _start <= 1808 && _end > 1808 {
                        _buf[(1808 - _start) as usize] = _value[0];
                    }
                    if _start <= 1809 && _end > 1809 {
                        _buf[(1809 - _start) as usize] = _value[1];
                    }
                    if _start <= 1810 && _end > 1810 {
                        _buf[(1810 - _start) as usize] = _value[2];
                    }
                    if _start <= 1811 && _end > 1811 {
                        _buf[(1811 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1816 && _end > 1812 {
                    let _value = self.read_p0_pin_cnfn(5)?.to_ne_bytes();
                    if _start <= 1812 && _end > 1812 {
                        _buf[(1812 - _start) as usize] = _value[0];
                    }
                    if _start <= 1813 && _end > 1813 {
                        _buf[(1813 - _start) as usize] = _value[1];
                    }
                    if _start <= 1814 && _end > 1814 {
                        _buf[(1814 - _start) as usize] = _value[2];
                    }
                    if _start <= 1815 && _end > 1815 {
                        _buf[(1815 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1820 && _end > 1816 {
                    let _value = self.read_p0_pin_cnfn(6)?.to_ne_bytes();
                    if _start <= 1816 && _end > 1816 {
                        _buf[(1816 - _start) as usize] = _value[0];
                    }
                    if _start <= 1817 && _end > 1817 {
                        _buf[(1817 - _start) as usize] = _value[1];
                    }
                    if _start <= 1818 && _end > 1818 {
                        _buf[(1818 - _start) as usize] = _value[2];
                    }
                    if _start <= 1819 && _end > 1819 {
                        _buf[(1819 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1824 && _end > 1820 {
                    let _value = self.read_p0_pin_cnfn(7)?.to_ne_bytes();
                    if _start <= 1820 && _end > 1820 {
                        _buf[(1820 - _start) as usize] = _value[0];
                    }
                    if _start <= 1821 && _end > 1821 {
                        _buf[(1821 - _start) as usize] = _value[1];
                    }
                    if _start <= 1822 && _end > 1822 {
                        _buf[(1822 - _start) as usize] = _value[2];
                    }
                    if _start <= 1823 && _end > 1823 {
                        _buf[(1823 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1828 && _end > 1824 {
                    let _value = self.read_p0_pin_cnfn(8)?.to_ne_bytes();
                    if _start <= 1824 && _end > 1824 {
                        _buf[(1824 - _start) as usize] = _value[0];
                    }
                    if _start <= 1825 && _end > 1825 {
                        _buf[(1825 - _start) as usize] = _value[1];
                    }
                    if _start <= 1826 && _end > 1826 {
                        _buf[(1826 - _start) as usize] = _value[2];
                    }
                    if _start <= 1827 && _end > 1827 {
                        _buf[(1827 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1832 && _end > 1828 {
                    let _value = self.read_p0_pin_cnfn(9)?.to_ne_bytes();
                    if _start <= 1828 && _end > 1828 {
                        _buf[(1828 - _start) as usize] = _value[0];
                    }
                    if _start <= 1829 && _end > 1829 {
                        _buf[(1829 - _start) as usize] = _value[1];
                    }
                    if _start <= 1830 && _end > 1830 {
                        _buf[(1830 - _start) as usize] = _value[2];
                    }
                    if _start <= 1831 && _end > 1831 {
                        _buf[(1831 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1836 && _end > 1832 {
                    let _value = self.read_p0_pin_cnfn(10)?.to_ne_bytes();
                    if _start <= 1832 && _end > 1832 {
                        _buf[(1832 - _start) as usize] = _value[0];
                    }
                    if _start <= 1833 && _end > 1833 {
                        _buf[(1833 - _start) as usize] = _value[1];
                    }
                    if _start <= 1834 && _end > 1834 {
                        _buf[(1834 - _start) as usize] = _value[2];
                    }
                    if _start <= 1835 && _end > 1835 {
                        _buf[(1835 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1840 && _end > 1836 {
                    let _value = self.read_p0_pin_cnfn(11)?.to_ne_bytes();
                    if _start <= 1836 && _end > 1836 {
                        _buf[(1836 - _start) as usize] = _value[0];
                    }
                    if _start <= 1837 && _end > 1837 {
                        _buf[(1837 - _start) as usize] = _value[1];
                    }
                    if _start <= 1838 && _end > 1838 {
                        _buf[(1838 - _start) as usize] = _value[2];
                    }
                    if _start <= 1839 && _end > 1839 {
                        _buf[(1839 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1844 && _end > 1840 {
                    let _value = self.read_p0_pin_cnfn(12)?.to_ne_bytes();
                    if _start <= 1840 && _end > 1840 {
                        _buf[(1840 - _start) as usize] = _value[0];
                    }
                    if _start <= 1841 && _end > 1841 {
                        _buf[(1841 - _start) as usize] = _value[1];
                    }
                    if _start <= 1842 && _end > 1842 {
                        _buf[(1842 - _start) as usize] = _value[2];
                    }
                    if _start <= 1843 && _end > 1843 {
                        _buf[(1843 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1848 && _end > 1844 {
                    let _value = self.read_p0_pin_cnfn(13)?.to_ne_bytes();
                    if _start <= 1844 && _end > 1844 {
                        _buf[(1844 - _start) as usize] = _value[0];
                    }
                    if _start <= 1845 && _end > 1845 {
                        _buf[(1845 - _start) as usize] = _value[1];
                    }
                    if _start <= 1846 && _end > 1846 {
                        _buf[(1846 - _start) as usize] = _value[2];
                    }
                    if _start <= 1847 && _end > 1847 {
                        _buf[(1847 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1852 && _end > 1848 {
                    let _value = self.read_p0_pin_cnfn(14)?.to_ne_bytes();
                    if _start <= 1848 && _end > 1848 {
                        _buf[(1848 - _start) as usize] = _value[0];
                    }
                    if _start <= 1849 && _end > 1849 {
                        _buf[(1849 - _start) as usize] = _value[1];
                    }
                    if _start <= 1850 && _end > 1850 {
                        _buf[(1850 - _start) as usize] = _value[2];
                    }
                    if _start <= 1851 && _end > 1851 {
                        _buf[(1851 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1856 && _end > 1852 {
                    let _value = self.read_p0_pin_cnfn(15)?.to_ne_bytes();
                    if _start <= 1852 && _end > 1852 {
                        _buf[(1852 - _start) as usize] = _value[0];
                    }
                    if _start <= 1853 && _end > 1853 {
                        _buf[(1853 - _start) as usize] = _value[1];
                    }
                    if _start <= 1854 && _end > 1854 {
                        _buf[(1854 - _start) as usize] = _value[2];
                    }
                    if _start <= 1855 && _end > 1855 {
                        _buf[(1855 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1860 && _end > 1856 {
                    let _value = self.read_p0_pin_cnfn(16)?.to_ne_bytes();
                    if _start <= 1856 && _end > 1856 {
                        _buf[(1856 - _start) as usize] = _value[0];
                    }
                    if _start <= 1857 && _end > 1857 {
                        _buf[(1857 - _start) as usize] = _value[1];
                    }
                    if _start <= 1858 && _end > 1858 {
                        _buf[(1858 - _start) as usize] = _value[2];
                    }
                    if _start <= 1859 && _end > 1859 {
                        _buf[(1859 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1864 && _end > 1860 {
                    let _value = self.read_p0_pin_cnfn(17)?.to_ne_bytes();
                    if _start <= 1860 && _end > 1860 {
                        _buf[(1860 - _start) as usize] = _value[0];
                    }
                    if _start <= 1861 && _end > 1861 {
                        _buf[(1861 - _start) as usize] = _value[1];
                    }
                    if _start <= 1862 && _end > 1862 {
                        _buf[(1862 - _start) as usize] = _value[2];
                    }
                    if _start <= 1863 && _end > 1863 {
                        _buf[(1863 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1868 && _end > 1864 {
                    let _value = self.read_p0_pin_cnfn(18)?.to_ne_bytes();
                    if _start <= 1864 && _end > 1864 {
                        _buf[(1864 - _start) as usize] = _value[0];
                    }
                    if _start <= 1865 && _end > 1865 {
                        _buf[(1865 - _start) as usize] = _value[1];
                    }
                    if _start <= 1866 && _end > 1866 {
                        _buf[(1866 - _start) as usize] = _value[2];
                    }
                    if _start <= 1867 && _end > 1867 {
                        _buf[(1867 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1872 && _end > 1868 {
                    let _value = self.read_p0_pin_cnfn(19)?.to_ne_bytes();
                    if _start <= 1868 && _end > 1868 {
                        _buf[(1868 - _start) as usize] = _value[0];
                    }
                    if _start <= 1869 && _end > 1869 {
                        _buf[(1869 - _start) as usize] = _value[1];
                    }
                    if _start <= 1870 && _end > 1870 {
                        _buf[(1870 - _start) as usize] = _value[2];
                    }
                    if _start <= 1871 && _end > 1871 {
                        _buf[(1871 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1876 && _end > 1872 {
                    let _value = self.read_p0_pin_cnfn(20)?.to_ne_bytes();
                    if _start <= 1872 && _end > 1872 {
                        _buf[(1872 - _start) as usize] = _value[0];
                    }
                    if _start <= 1873 && _end > 1873 {
                        _buf[(1873 - _start) as usize] = _value[1];
                    }
                    if _start <= 1874 && _end > 1874 {
                        _buf[(1874 - _start) as usize] = _value[2];
                    }
                    if _start <= 1875 && _end > 1875 {
                        _buf[(1875 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1880 && _end > 1876 {
                    let _value = self.read_p0_pin_cnfn(21)?.to_ne_bytes();
                    if _start <= 1876 && _end > 1876 {
                        _buf[(1876 - _start) as usize] = _value[0];
                    }
                    if _start <= 1877 && _end > 1877 {
                        _buf[(1877 - _start) as usize] = _value[1];
                    }
                    if _start <= 1878 && _end > 1878 {
                        _buf[(1878 - _start) as usize] = _value[2];
                    }
                    if _start <= 1879 && _end > 1879 {
                        _buf[(1879 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1884 && _end > 1880 {
                    let _value = self.read_p0_pin_cnfn(22)?.to_ne_bytes();
                    if _start <= 1880 && _end > 1880 {
                        _buf[(1880 - _start) as usize] = _value[0];
                    }
                    if _start <= 1881 && _end > 1881 {
                        _buf[(1881 - _start) as usize] = _value[1];
                    }
                    if _start <= 1882 && _end > 1882 {
                        _buf[(1882 - _start) as usize] = _value[2];
                    }
                    if _start <= 1883 && _end > 1883 {
                        _buf[(1883 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1888 && _end > 1884 {
                    let _value = self.read_p0_pin_cnfn(23)?.to_ne_bytes();
                    if _start <= 1884 && _end > 1884 {
                        _buf[(1884 - _start) as usize] = _value[0];
                    }
                    if _start <= 1885 && _end > 1885 {
                        _buf[(1885 - _start) as usize] = _value[1];
                    }
                    if _start <= 1886 && _end > 1886 {
                        _buf[(1886 - _start) as usize] = _value[2];
                    }
                    if _start <= 1887 && _end > 1887 {
                        _buf[(1887 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1892 && _end > 1888 {
                    let _value = self.read_p0_pin_cnfn(24)?.to_ne_bytes();
                    if _start <= 1888 && _end > 1888 {
                        _buf[(1888 - _start) as usize] = _value[0];
                    }
                    if _start <= 1889 && _end > 1889 {
                        _buf[(1889 - _start) as usize] = _value[1];
                    }
                    if _start <= 1890 && _end > 1890 {
                        _buf[(1890 - _start) as usize] = _value[2];
                    }
                    if _start <= 1891 && _end > 1891 {
                        _buf[(1891 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1896 && _end > 1892 {
                    let _value = self.read_p0_pin_cnfn(25)?.to_ne_bytes();
                    if _start <= 1892 && _end > 1892 {
                        _buf[(1892 - _start) as usize] = _value[0];
                    }
                    if _start <= 1893 && _end > 1893 {
                        _buf[(1893 - _start) as usize] = _value[1];
                    }
                    if _start <= 1894 && _end > 1894 {
                        _buf[(1894 - _start) as usize] = _value[2];
                    }
                    if _start <= 1895 && _end > 1895 {
                        _buf[(1895 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1900 && _end > 1896 {
                    let _value = self.read_p0_pin_cnfn(26)?.to_ne_bytes();
                    if _start <= 1896 && _end > 1896 {
                        _buf[(1896 - _start) as usize] = _value[0];
                    }
                    if _start <= 1897 && _end > 1897 {
                        _buf[(1897 - _start) as usize] = _value[1];
                    }
                    if _start <= 1898 && _end > 1898 {
                        _buf[(1898 - _start) as usize] = _value[2];
                    }
                    if _start <= 1899 && _end > 1899 {
                        _buf[(1899 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1904 && _end > 1900 {
                    let _value = self.read_p0_pin_cnfn(27)?.to_ne_bytes();
                    if _start <= 1900 && _end > 1900 {
                        _buf[(1900 - _start) as usize] = _value[0];
                    }
                    if _start <= 1901 && _end > 1901 {
                        _buf[(1901 - _start) as usize] = _value[1];
                    }
                    if _start <= 1902 && _end > 1902 {
                        _buf[(1902 - _start) as usize] = _value[2];
                    }
                    if _start <= 1903 && _end > 1903 {
                        _buf[(1903 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1908 && _end > 1904 {
                    let _value = self.read_p0_pin_cnfn(28)?.to_ne_bytes();
                    if _start <= 1904 && _end > 1904 {
                        _buf[(1904 - _start) as usize] = _value[0];
                    }
                    if _start <= 1905 && _end > 1905 {
                        _buf[(1905 - _start) as usize] = _value[1];
                    }
                    if _start <= 1906 && _end > 1906 {
                        _buf[(1906 - _start) as usize] = _value[2];
                    }
                    if _start <= 1907 && _end > 1907 {
                        _buf[(1907 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1912 && _end > 1908 {
                    let _value = self.read_p0_pin_cnfn(29)?.to_ne_bytes();
                    if _start <= 1908 && _end > 1908 {
                        _buf[(1908 - _start) as usize] = _value[0];
                    }
                    if _start <= 1909 && _end > 1909 {
                        _buf[(1909 - _start) as usize] = _value[1];
                    }
                    if _start <= 1910 && _end > 1910 {
                        _buf[(1910 - _start) as usize] = _value[2];
                    }
                    if _start <= 1911 && _end > 1911 {
                        _buf[(1911 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1916 && _end > 1912 {
                    let _value = self.read_p0_pin_cnfn(30)?.to_ne_bytes();
                    if _start <= 1912 && _end > 1912 {
                        _buf[(1912 - _start) as usize] = _value[0];
                    }
                    if _start <= 1913 && _end > 1913 {
                        _buf[(1913 - _start) as usize] = _value[1];
                    }
                    if _start <= 1914 && _end > 1914 {
                        _buf[(1914 - _start) as usize] = _value[2];
                    }
                    if _start <= 1915 && _end > 1915 {
                        _buf[(1915 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1920 && _end > 1916 {
                    let _value = self.read_p0_pin_cnfn(31)?.to_ne_bytes();
                    if _start <= 1916 && _end > 1916 {
                        _buf[(1916 - _start) as usize] = _value[0];
                    }
                    if _start <= 1917 && _end > 1917 {
                        _buf[(1917 - _start) as usize] = _value[1];
                    }
                    if _start <= 1918 && _end > 1918 {
                        _buf[(1918 - _start) as usize] = _value[2];
                    }
                    if _start <= 1919 && _end > 1919 {
                        _buf[(1919 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 1342177280;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1284..=1319, 1285..=1320) => {
                if _start < 1288 && _end > 1284 {
                    let offset = _start.saturating_sub(1284);
                    let start = 1284u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1284) - offset) as usize;
                    self.write_p0_out(offset, &_buf[start..end])?;
                }
                if _start < 1292 && _end > 1288 {
                    let offset = _start.saturating_sub(1288);
                    let start = 1288u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1288) - offset) as usize;
                    self.write_p0_outset(offset, &_buf[start..end])?;
                }
                if _start < 1296 && _end > 1292 {
                    let offset = _start.saturating_sub(1292);
                    let start = 1292u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1292) - offset) as usize;
                    self.write_p0_outclr(offset, &_buf[start..end])?;
                }
                if _start < 1300 && _end > 1296 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 1304 && _end > 1300 {
                    let offset = _start.saturating_sub(1300);
                    let start = 1300u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1300) - offset) as usize;
                    self.write_p0_dir(offset, &_buf[start..end])?;
                }
                if _start < 1308 && _end > 1304 {
                    let offset = _start.saturating_sub(1304);
                    let start = 1304u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1304) - offset) as usize;
                    self.write_p0_dirset(offset, &_buf[start..end])?;
                }
                if _start < 1312 && _end > 1308 {
                    let offset = _start.saturating_sub(1308);
                    let start = 1308u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1308) - offset) as usize;
                    self.write_p0_dirclr(offset, &_buf[start..end])?;
                }
                if _start < 1316 && _end > 1312 {
                    let offset = _start.saturating_sub(1312);
                    let start = 1312u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1312) - offset) as usize;
                    self.write_p0_latch(offset, &_buf[start..end])?;
                }
                if _start < 1320 && _end > 1316 {
                    let offset = _start.saturating_sub(1316);
                    let start = 1316u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1316) - offset) as usize;
                    self.write_p0_detectmode(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (1792..=1919, 1793..=1920) => {
                if _start < 1796 && _end > 1792 {
                    let offset = _start.saturating_sub(1792);
                    let start = 1792u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1792) - offset) as usize;
                    self.write_p0_pin_cnfn(0, offset, &_buf[start..end])?;
                }
                if _start < 1800 && _end > 1796 {
                    let offset = _start.saturating_sub(1796);
                    let start = 1796u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1796) - offset) as usize;
                    self.write_p0_pin_cnfn(1, offset, &_buf[start..end])?;
                }
                if _start < 1804 && _end > 1800 {
                    let offset = _start.saturating_sub(1800);
                    let start = 1800u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1800) - offset) as usize;
                    self.write_p0_pin_cnfn(2, offset, &_buf[start..end])?;
                }
                if _start < 1808 && _end > 1804 {
                    let offset = _start.saturating_sub(1804);
                    let start = 1804u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1804) - offset) as usize;
                    self.write_p0_pin_cnfn(3, offset, &_buf[start..end])?;
                }
                if _start < 1812 && _end > 1808 {
                    let offset = _start.saturating_sub(1808);
                    let start = 1808u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1808) - offset) as usize;
                    self.write_p0_pin_cnfn(4, offset, &_buf[start..end])?;
                }
                if _start < 1816 && _end > 1812 {
                    let offset = _start.saturating_sub(1812);
                    let start = 1812u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1812) - offset) as usize;
                    self.write_p0_pin_cnfn(5, offset, &_buf[start..end])?;
                }
                if _start < 1820 && _end > 1816 {
                    let offset = _start.saturating_sub(1816);
                    let start = 1816u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1816) - offset) as usize;
                    self.write_p0_pin_cnfn(6, offset, &_buf[start..end])?;
                }
                if _start < 1824 && _end > 1820 {
                    let offset = _start.saturating_sub(1820);
                    let start = 1820u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1820) - offset) as usize;
                    self.write_p0_pin_cnfn(7, offset, &_buf[start..end])?;
                }
                if _start < 1828 && _end > 1824 {
                    let offset = _start.saturating_sub(1824);
                    let start = 1824u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1824) - offset) as usize;
                    self.write_p0_pin_cnfn(8, offset, &_buf[start..end])?;
                }
                if _start < 1832 && _end > 1828 {
                    let offset = _start.saturating_sub(1828);
                    let start = 1828u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1828) - offset) as usize;
                    self.write_p0_pin_cnfn(9, offset, &_buf[start..end])?;
                }
                if _start < 1836 && _end > 1832 {
                    let offset = _start.saturating_sub(1832);
                    let start = 1832u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1832) - offset) as usize;
                    self.write_p0_pin_cnfn(10, offset, &_buf[start..end])?;
                }
                if _start < 1840 && _end > 1836 {
                    let offset = _start.saturating_sub(1836);
                    let start = 1836u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1836) - offset) as usize;
                    self.write_p0_pin_cnfn(11, offset, &_buf[start..end])?;
                }
                if _start < 1844 && _end > 1840 {
                    let offset = _start.saturating_sub(1840);
                    let start = 1840u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1840) - offset) as usize;
                    self.write_p0_pin_cnfn(12, offset, &_buf[start..end])?;
                }
                if _start < 1848 && _end > 1844 {
                    let offset = _start.saturating_sub(1844);
                    let start = 1844u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1844) - offset) as usize;
                    self.write_p0_pin_cnfn(13, offset, &_buf[start..end])?;
                }
                if _start < 1852 && _end > 1848 {
                    let offset = _start.saturating_sub(1848);
                    let start = 1848u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1848) - offset) as usize;
                    self.write_p0_pin_cnfn(14, offset, &_buf[start..end])?;
                }
                if _start < 1856 && _end > 1852 {
                    let offset = _start.saturating_sub(1852);
                    let start = 1852u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1852) - offset) as usize;
                    self.write_p0_pin_cnfn(15, offset, &_buf[start..end])?;
                }
                if _start < 1860 && _end > 1856 {
                    let offset = _start.saturating_sub(1856);
                    let start = 1856u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1856) - offset) as usize;
                    self.write_p0_pin_cnfn(16, offset, &_buf[start..end])?;
                }
                if _start < 1864 && _end > 1860 {
                    let offset = _start.saturating_sub(1860);
                    let start = 1860u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1860) - offset) as usize;
                    self.write_p0_pin_cnfn(17, offset, &_buf[start..end])?;
                }
                if _start < 1868 && _end > 1864 {
                    let offset = _start.saturating_sub(1864);
                    let start = 1864u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1864) - offset) as usize;
                    self.write_p0_pin_cnfn(18, offset, &_buf[start..end])?;
                }
                if _start < 1872 && _end > 1868 {
                    let offset = _start.saturating_sub(1868);
                    let start = 1868u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1868) - offset) as usize;
                    self.write_p0_pin_cnfn(19, offset, &_buf[start..end])?;
                }
                if _start < 1876 && _end > 1872 {
                    let offset = _start.saturating_sub(1872);
                    let start = 1872u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1872) - offset) as usize;
                    self.write_p0_pin_cnfn(20, offset, &_buf[start..end])?;
                }
                if _start < 1880 && _end > 1876 {
                    let offset = _start.saturating_sub(1876);
                    let start = 1876u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1876) - offset) as usize;
                    self.write_p0_pin_cnfn(21, offset, &_buf[start..end])?;
                }
                if _start < 1884 && _end > 1880 {
                    let offset = _start.saturating_sub(1880);
                    let start = 1880u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1880) - offset) as usize;
                    self.write_p0_pin_cnfn(22, offset, &_buf[start..end])?;
                }
                if _start < 1888 && _end > 1884 {
                    let offset = _start.saturating_sub(1884);
                    let start = 1884u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1884) - offset) as usize;
                    self.write_p0_pin_cnfn(23, offset, &_buf[start..end])?;
                }
                if _start < 1892 && _end > 1888 {
                    let offset = _start.saturating_sub(1888);
                    let start = 1888u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1888) - offset) as usize;
                    self.write_p0_pin_cnfn(24, offset, &_buf[start..end])?;
                }
                if _start < 1896 && _end > 1892 {
                    let offset = _start.saturating_sub(1892);
                    let start = 1892u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1892) - offset) as usize;
                    self.write_p0_pin_cnfn(25, offset, &_buf[start..end])?;
                }
                if _start < 1900 && _end > 1896 {
                    let offset = _start.saturating_sub(1896);
                    let start = 1896u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1896) - offset) as usize;
                    self.write_p0_pin_cnfn(26, offset, &_buf[start..end])?;
                }
                if _start < 1904 && _end > 1900 {
                    let offset = _start.saturating_sub(1900);
                    let start = 1900u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1900) - offset) as usize;
                    self.write_p0_pin_cnfn(27, offset, &_buf[start..end])?;
                }
                if _start < 1908 && _end > 1904 {
                    let offset = _start.saturating_sub(1904);
                    let start = 1904u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1904) - offset) as usize;
                    self.write_p0_pin_cnfn(28, offset, &_buf[start..end])?;
                }
                if _start < 1912 && _end > 1908 {
                    let offset = _start.saturating_sub(1908);
                    let start = 1908u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1908) - offset) as usize;
                    self.write_p0_pin_cnfn(29, offset, &_buf[start..end])?;
                }
                if _start < 1916 && _end > 1912 {
                    let offset = _start.saturating_sub(1912);
                    let start = 1912u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1912) - offset) as usize;
                    self.write_p0_pin_cnfn(30, offset, &_buf[start..end])?;
                }
                if _start < 1920 && _end > 1916 {
                    let offset = _start.saturating_sub(1916);
                    let start = 1916u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1916) - offset) as usize;
                    self.write_p0_pin_cnfn(31, offset, &_buf[start..end])?;
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0x50000000 {
    fn read_p0_out(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin0()?) << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin1()?) << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin2()?) << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin3()?) << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin4()?) << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin5()?) << 5u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin6()?) << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin7()?) << 7u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin8()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_out_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_out_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_p0_out(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_out_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_p0_outset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outset_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_p0_outset(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outset_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_p0_outclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_outclr_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_p0_outclr(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_outclr_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_p0_in(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin0()?) << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin1()?) << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin2()?) << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin3()?) << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin4()?) << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin5()?) << 5u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin6()?) << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin7()?) << 7u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin8()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_in_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_in_pin31()?) << 31u32;
        Ok(_value)
    }
    fn read_p0_dir(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin0()?) << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin1()?) << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin2()?) << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin3()?) << 3u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin4()?) << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin5()?) << 5u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin6()?) << 6u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin7()?) << 7u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin8()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_p0_dir_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dir_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_p0_dir(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dir_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_p0_dirset(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirset_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_p0_dirset(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirset_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_p0_dirclr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_dirclr_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_p0_dirclr(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_dirclr_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_p0_latch(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin1()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin2()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin3()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin4()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin5()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin6()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin7()?) << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin8()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin9()?) << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin10()?) << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin11()?) << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin12()?) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin13()?) << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin14()?) << 14u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin15()?) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin16()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin17()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin18()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin19()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin20()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin21()?) << 21u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin22()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin23()?) << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin24()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin25()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin26()?) << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin27()?) << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin28()?) << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin29()?) << 29u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin30()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_latch_pin31()?) << 31u32;
        Ok(_value)
    }
    fn write_p0_latch(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin0((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin1((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin2((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin3((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin4((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin5((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin6((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin7((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin8((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin9((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin10((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin11((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin12((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin13((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin14((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin15((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin16((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin17((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin18((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin19((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin20((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin21((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin22((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin23((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin24((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin25((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin26((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin27((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin28((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin29((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin30((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_latch_pin31((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_p0_detectmode(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_detectmode_detectmode()?)
                << 0u32;
        Ok(_value)
    }
    fn write_p0_detectmode(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_detectmode_detectmode((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_p0_pin_cnfn(&self, _dim: usize) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_p0_pin_cnfn_dir(_dim)?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_pin_cnfn_input(_dim)?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_pin_cnfn_pull(_dim)?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_pin_cnfn_drive(_dim)?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_p0_pin_cnfn_sense(_dim)?)
                << 16u32;
        Ok(_value)
    }
    fn write_p0_pin_cnfn(
        &mut self,
        _dim: usize,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_pin_cnfn_dir(_dim, (_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_pin_cnfn_input(_dim, (_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_pin_cnfn_pull(_dim, (_value[_i] >> 2) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_pin_cnfn_drive(_dim, (_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_p0_pin_cnfn_sense(_dim, (_value[_i] >> 0) & 3u8)?;
        }
        Ok(())
    }
}
pub(crate) struct PeripheralPage0xE000E000(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for PeripheralPage0xE000E000 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _start = _addr - 3758153728;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=11, 5..=12) => {
                if _start < 8 && _end > 4 {
                    let _value = self.read_nvic_ictr()?.to_ne_bytes();
                    if _start <= 4 && _end > 4 {
                        _buf[(4 - _start) as usize] = _value[0];
                    }
                    if _start <= 5 && _end > 5 {
                        _buf[(5 - _start) as usize] = _value[1];
                    }
                    if _start <= 6 && _end > 6 {
                        _buf[(6 - _start) as usize] = _value[2];
                    }
                    if _start <= 7 && _end > 7 {
                        _buf[(7 - _start) as usize] = _value[3];
                    }
                }
                if _start < 12 && _end > 8 {
                    let _value = self.read_control_actlr()?.to_ne_bytes();
                    if _start <= 8 && _end > 8 {
                        _buf[(8 - _start) as usize] = _value[0];
                    }
                    if _start <= 9 && _end > 9 {
                        _buf[(9 - _start) as usize] = _value[1];
                    }
                    if _start <= 10 && _end > 10 {
                        _buf[(10 - _start) as usize] = _value[2];
                    }
                    if _start <= 11 && _end > 11 {
                        _buf[(11 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (16..=31, 17..=32) => {
                if _start < 20 && _end > 16 {
                    let _value = self.read_systick_stcsr()?.to_ne_bytes();
                    if _start <= 16 && _end > 16 {
                        _buf[(16 - _start) as usize] = _value[0];
                    }
                    if _start <= 17 && _end > 17 {
                        _buf[(17 - _start) as usize] = _value[1];
                    }
                    if _start <= 18 && _end > 18 {
                        _buf[(18 - _start) as usize] = _value[2];
                    }
                    if _start <= 19 && _end > 19 {
                        _buf[(19 - _start) as usize] = _value[3];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _value = self.read_systick_strvr()?.to_ne_bytes();
                    if _start <= 20 && _end > 20 {
                        _buf[(20 - _start) as usize] = _value[0];
                    }
                    if _start <= 21 && _end > 21 {
                        _buf[(21 - _start) as usize] = _value[1];
                    }
                    if _start <= 22 && _end > 22 {
                        _buf[(22 - _start) as usize] = _value[2];
                    }
                    if _start <= 23 && _end > 23 {
                        _buf[(23 - _start) as usize] = _value[3];
                    }
                }
                if _start < 28 && _end > 24 {
                    let _value = self.read_systick_stcvr()?.to_ne_bytes();
                    if _start <= 24 && _end > 24 {
                        _buf[(24 - _start) as usize] = _value[0];
                    }
                    if _start <= 25 && _end > 25 {
                        _buf[(25 - _start) as usize] = _value[1];
                    }
                    if _start <= 26 && _end > 26 {
                        _buf[(26 - _start) as usize] = _value[2];
                    }
                    if _start <= 27 && _end > 27 {
                        _buf[(27 - _start) as usize] = _value[3];
                    }
                }
                if _start < 32 && _end > 28 {
                    let _value = self.read_systick_stcr()?.to_ne_bytes();
                    if _start <= 28 && _end > 28 {
                        _buf[(28 - _start) as usize] = _value[0];
                    }
                    if _start <= 29 && _end > 29 {
                        _buf[(29 - _start) as usize] = _value[1];
                    }
                    if _start <= 30 && _end > 30 {
                        _buf[(30 - _start) as usize] = _value[2];
                    }
                    if _start <= 31 && _end > 31 {
                        _buf[(31 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser0()?
                        .to_ne_bytes();
                    if _start <= 256 && _end > 256 {
                        _buf[(256 - _start) as usize] = _value[0];
                    }
                    if _start <= 257 && _end > 257 {
                        _buf[(257 - _start) as usize] = _value[1];
                    }
                    if _start <= 258 && _end > 258 {
                        _buf[(258 - _start) as usize] = _value[2];
                    }
                    if _start <= 259 && _end > 259 {
                        _buf[(259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser1()?
                        .to_ne_bytes();
                    if _start <= 260 && _end > 260 {
                        _buf[(260 - _start) as usize] = _value[0];
                    }
                    if _start <= 261 && _end > 261 {
                        _buf[(261 - _start) as usize] = _value[1];
                    }
                    if _start <= 262 && _end > 262 {
                        _buf[(262 - _start) as usize] = _value[2];
                    }
                    if _start <= 263 && _end > 263 {
                        _buf[(263 - _start) as usize] = _value[3];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser2()?
                        .to_ne_bytes();
                    if _start <= 264 && _end > 264 {
                        _buf[(264 - _start) as usize] = _value[0];
                    }
                    if _start <= 265 && _end > 265 {
                        _buf[(265 - _start) as usize] = _value[1];
                    }
                    if _start <= 266 && _end > 266 {
                        _buf[(266 - _start) as usize] = _value[2];
                    }
                    if _start <= 267 && _end > 267 {
                        _buf[(267 - _start) as usize] = _value[3];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser3()?
                        .to_ne_bytes();
                    if _start <= 268 && _end > 268 {
                        _buf[(268 - _start) as usize] = _value[0];
                    }
                    if _start <= 269 && _end > 269 {
                        _buf[(269 - _start) as usize] = _value[1];
                    }
                    if _start <= 270 && _end > 270 {
                        _buf[(270 - _start) as usize] = _value[2];
                    }
                    if _start <= 271 && _end > 271 {
                        _buf[(271 - _start) as usize] = _value[3];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser4()?
                        .to_ne_bytes();
                    if _start <= 272 && _end > 272 {
                        _buf[(272 - _start) as usize] = _value[0];
                    }
                    if _start <= 273 && _end > 273 {
                        _buf[(273 - _start) as usize] = _value[1];
                    }
                    if _start <= 274 && _end > 274 {
                        _buf[(274 - _start) as usize] = _value[2];
                    }
                    if _start <= 275 && _end > 275 {
                        _buf[(275 - _start) as usize] = _value[3];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser5()?
                        .to_ne_bytes();
                    if _start <= 276 && _end > 276 {
                        _buf[(276 - _start) as usize] = _value[0];
                    }
                    if _start <= 277 && _end > 277 {
                        _buf[(277 - _start) as usize] = _value[1];
                    }
                    if _start <= 278 && _end > 278 {
                        _buf[(278 - _start) as usize] = _value[2];
                    }
                    if _start <= 279 && _end > 279 {
                        _buf[(279 - _start) as usize] = _value[3];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser6()?
                        .to_ne_bytes();
                    if _start <= 280 && _end > 280 {
                        _buf[(280 - _start) as usize] = _value[0];
                    }
                    if _start <= 281 && _end > 281 {
                        _buf[(281 - _start) as usize] = _value[1];
                    }
                    if _start <= 282 && _end > 282 {
                        _buf[(282 - _start) as usize] = _value[2];
                    }
                    if _start <= 283 && _end > 283 {
                        _buf[(283 - _start) as usize] = _value[3];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iser7()?
                        .to_ne_bytes();
                    if _start <= 284 && _end > 284 {
                        _buf[(284 - _start) as usize] = _value[0];
                    }
                    if _start <= 285 && _end > 285 {
                        _buf[(285 - _start) as usize] = _value[1];
                    }
                    if _start <= 286 && _end > 286 {
                        _buf[(286 - _start) as usize] = _value[2];
                    }
                    if _start <= 287 && _end > 287 {
                        _buf[(287 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (384..=415, 385..=416) => {
                if _start < 388 && _end > 384 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer0()?
                        .to_ne_bytes();
                    if _start <= 384 && _end > 384 {
                        _buf[(384 - _start) as usize] = _value[0];
                    }
                    if _start <= 385 && _end > 385 {
                        _buf[(385 - _start) as usize] = _value[1];
                    }
                    if _start <= 386 && _end > 386 {
                        _buf[(386 - _start) as usize] = _value[2];
                    }
                    if _start <= 387 && _end > 387 {
                        _buf[(387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 392 && _end > 388 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer1()?
                        .to_ne_bytes();
                    if _start <= 388 && _end > 388 {
                        _buf[(388 - _start) as usize] = _value[0];
                    }
                    if _start <= 389 && _end > 389 {
                        _buf[(389 - _start) as usize] = _value[1];
                    }
                    if _start <= 390 && _end > 390 {
                        _buf[(390 - _start) as usize] = _value[2];
                    }
                    if _start <= 391 && _end > 391 {
                        _buf[(391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 396 && _end > 392 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer2()?
                        .to_ne_bytes();
                    if _start <= 392 && _end > 392 {
                        _buf[(392 - _start) as usize] = _value[0];
                    }
                    if _start <= 393 && _end > 393 {
                        _buf[(393 - _start) as usize] = _value[1];
                    }
                    if _start <= 394 && _end > 394 {
                        _buf[(394 - _start) as usize] = _value[2];
                    }
                    if _start <= 395 && _end > 395 {
                        _buf[(395 - _start) as usize] = _value[3];
                    }
                }
                if _start < 400 && _end > 396 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer3()?
                        .to_ne_bytes();
                    if _start <= 396 && _end > 396 {
                        _buf[(396 - _start) as usize] = _value[0];
                    }
                    if _start <= 397 && _end > 397 {
                        _buf[(397 - _start) as usize] = _value[1];
                    }
                    if _start <= 398 && _end > 398 {
                        _buf[(398 - _start) as usize] = _value[2];
                    }
                    if _start <= 399 && _end > 399 {
                        _buf[(399 - _start) as usize] = _value[3];
                    }
                }
                if _start < 404 && _end > 400 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer4()?
                        .to_ne_bytes();
                    if _start <= 400 && _end > 400 {
                        _buf[(400 - _start) as usize] = _value[0];
                    }
                    if _start <= 401 && _end > 401 {
                        _buf[(401 - _start) as usize] = _value[1];
                    }
                    if _start <= 402 && _end > 402 {
                        _buf[(402 - _start) as usize] = _value[2];
                    }
                    if _start <= 403 && _end > 403 {
                        _buf[(403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 408 && _end > 404 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer5()?
                        .to_ne_bytes();
                    if _start <= 404 && _end > 404 {
                        _buf[(404 - _start) as usize] = _value[0];
                    }
                    if _start <= 405 && _end > 405 {
                        _buf[(405 - _start) as usize] = _value[1];
                    }
                    if _start <= 406 && _end > 406 {
                        _buf[(406 - _start) as usize] = _value[2];
                    }
                    if _start <= 407 && _end > 407 {
                        _buf[(407 - _start) as usize] = _value[3];
                    }
                }
                if _start < 412 && _end > 408 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer6()?
                        .to_ne_bytes();
                    if _start <= 408 && _end > 408 {
                        _buf[(408 - _start) as usize] = _value[0];
                    }
                    if _start <= 409 && _end > 409 {
                        _buf[(409 - _start) as usize] = _value[1];
                    }
                    if _start <= 410 && _end > 410 {
                        _buf[(410 - _start) as usize] = _value[2];
                    }
                    if _start <= 411 && _end > 411 {
                        _buf[(411 - _start) as usize] = _value[3];
                    }
                }
                if _start < 416 && _end > 412 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icer7()?
                        .to_ne_bytes();
                    if _start <= 412 && _end > 412 {
                        _buf[(412 - _start) as usize] = _value[0];
                    }
                    if _start <= 413 && _end > 413 {
                        _buf[(413 - _start) as usize] = _value[1];
                    }
                    if _start <= 414 && _end > 414 {
                        _buf[(414 - _start) as usize] = _value[2];
                    }
                    if _start <= 415 && _end > 415 {
                        _buf[(415 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (512..=543, 513..=544) => {
                if _start < 516 && _end > 512 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr0()?
                        .to_ne_bytes();
                    if _start <= 512 && _end > 512 {
                        _buf[(512 - _start) as usize] = _value[0];
                    }
                    if _start <= 513 && _end > 513 {
                        _buf[(513 - _start) as usize] = _value[1];
                    }
                    if _start <= 514 && _end > 514 {
                        _buf[(514 - _start) as usize] = _value[2];
                    }
                    if _start <= 515 && _end > 515 {
                        _buf[(515 - _start) as usize] = _value[3];
                    }
                }
                if _start < 520 && _end > 516 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr1()?
                        .to_ne_bytes();
                    if _start <= 516 && _end > 516 {
                        _buf[(516 - _start) as usize] = _value[0];
                    }
                    if _start <= 517 && _end > 517 {
                        _buf[(517 - _start) as usize] = _value[1];
                    }
                    if _start <= 518 && _end > 518 {
                        _buf[(518 - _start) as usize] = _value[2];
                    }
                    if _start <= 519 && _end > 519 {
                        _buf[(519 - _start) as usize] = _value[3];
                    }
                }
                if _start < 524 && _end > 520 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr2()?
                        .to_ne_bytes();
                    if _start <= 520 && _end > 520 {
                        _buf[(520 - _start) as usize] = _value[0];
                    }
                    if _start <= 521 && _end > 521 {
                        _buf[(521 - _start) as usize] = _value[1];
                    }
                    if _start <= 522 && _end > 522 {
                        _buf[(522 - _start) as usize] = _value[2];
                    }
                    if _start <= 523 && _end > 523 {
                        _buf[(523 - _start) as usize] = _value[3];
                    }
                }
                if _start < 528 && _end > 524 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr3()?
                        .to_ne_bytes();
                    if _start <= 524 && _end > 524 {
                        _buf[(524 - _start) as usize] = _value[0];
                    }
                    if _start <= 525 && _end > 525 {
                        _buf[(525 - _start) as usize] = _value[1];
                    }
                    if _start <= 526 && _end > 526 {
                        _buf[(526 - _start) as usize] = _value[2];
                    }
                    if _start <= 527 && _end > 527 {
                        _buf[(527 - _start) as usize] = _value[3];
                    }
                }
                if _start < 532 && _end > 528 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr4()?
                        .to_ne_bytes();
                    if _start <= 528 && _end > 528 {
                        _buf[(528 - _start) as usize] = _value[0];
                    }
                    if _start <= 529 && _end > 529 {
                        _buf[(529 - _start) as usize] = _value[1];
                    }
                    if _start <= 530 && _end > 530 {
                        _buf[(530 - _start) as usize] = _value[2];
                    }
                    if _start <= 531 && _end > 531 {
                        _buf[(531 - _start) as usize] = _value[3];
                    }
                }
                if _start < 536 && _end > 532 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr5()?
                        .to_ne_bytes();
                    if _start <= 532 && _end > 532 {
                        _buf[(532 - _start) as usize] = _value[0];
                    }
                    if _start <= 533 && _end > 533 {
                        _buf[(533 - _start) as usize] = _value[1];
                    }
                    if _start <= 534 && _end > 534 {
                        _buf[(534 - _start) as usize] = _value[2];
                    }
                    if _start <= 535 && _end > 535 {
                        _buf[(535 - _start) as usize] = _value[3];
                    }
                }
                if _start < 540 && _end > 536 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr6()?
                        .to_ne_bytes();
                    if _start <= 536 && _end > 536 {
                        _buf[(536 - _start) as usize] = _value[0];
                    }
                    if _start <= 537 && _end > 537 {
                        _buf[(537 - _start) as usize] = _value[1];
                    }
                    if _start <= 538 && _end > 538 {
                        _buf[(538 - _start) as usize] = _value[2];
                    }
                    if _start <= 539 && _end > 539 {
                        _buf[(539 - _start) as usize] = _value[3];
                    }
                }
                if _start < 544 && _end > 540 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_ispr7()?
                        .to_ne_bytes();
                    if _start <= 540 && _end > 540 {
                        _buf[(540 - _start) as usize] = _value[0];
                    }
                    if _start <= 541 && _end > 541 {
                        _buf[(541 - _start) as usize] = _value[1];
                    }
                    if _start <= 542 && _end > 542 {
                        _buf[(542 - _start) as usize] = _value[2];
                    }
                    if _start <= 543 && _end > 543 {
                        _buf[(543 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (640..=671, 641..=672) => {
                if _start < 644 && _end > 640 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr0()?
                        .to_ne_bytes();
                    if _start <= 640 && _end > 640 {
                        _buf[(640 - _start) as usize] = _value[0];
                    }
                    if _start <= 641 && _end > 641 {
                        _buf[(641 - _start) as usize] = _value[1];
                    }
                    if _start <= 642 && _end > 642 {
                        _buf[(642 - _start) as usize] = _value[2];
                    }
                    if _start <= 643 && _end > 643 {
                        _buf[(643 - _start) as usize] = _value[3];
                    }
                }
                if _start < 648 && _end > 644 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr1()?
                        .to_ne_bytes();
                    if _start <= 644 && _end > 644 {
                        _buf[(644 - _start) as usize] = _value[0];
                    }
                    if _start <= 645 && _end > 645 {
                        _buf[(645 - _start) as usize] = _value[1];
                    }
                    if _start <= 646 && _end > 646 {
                        _buf[(646 - _start) as usize] = _value[2];
                    }
                    if _start <= 647 && _end > 647 {
                        _buf[(647 - _start) as usize] = _value[3];
                    }
                }
                if _start < 652 && _end > 648 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr2()?
                        .to_ne_bytes();
                    if _start <= 648 && _end > 648 {
                        _buf[(648 - _start) as usize] = _value[0];
                    }
                    if _start <= 649 && _end > 649 {
                        _buf[(649 - _start) as usize] = _value[1];
                    }
                    if _start <= 650 && _end > 650 {
                        _buf[(650 - _start) as usize] = _value[2];
                    }
                    if _start <= 651 && _end > 651 {
                        _buf[(651 - _start) as usize] = _value[3];
                    }
                }
                if _start < 656 && _end > 652 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr3()?
                        .to_ne_bytes();
                    if _start <= 652 && _end > 652 {
                        _buf[(652 - _start) as usize] = _value[0];
                    }
                    if _start <= 653 && _end > 653 {
                        _buf[(653 - _start) as usize] = _value[1];
                    }
                    if _start <= 654 && _end > 654 {
                        _buf[(654 - _start) as usize] = _value[2];
                    }
                    if _start <= 655 && _end > 655 {
                        _buf[(655 - _start) as usize] = _value[3];
                    }
                }
                if _start < 660 && _end > 656 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr4()?
                        .to_ne_bytes();
                    if _start <= 656 && _end > 656 {
                        _buf[(656 - _start) as usize] = _value[0];
                    }
                    if _start <= 657 && _end > 657 {
                        _buf[(657 - _start) as usize] = _value[1];
                    }
                    if _start <= 658 && _end > 658 {
                        _buf[(658 - _start) as usize] = _value[2];
                    }
                    if _start <= 659 && _end > 659 {
                        _buf[(659 - _start) as usize] = _value[3];
                    }
                }
                if _start < 664 && _end > 660 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr5()?
                        .to_ne_bytes();
                    if _start <= 660 && _end > 660 {
                        _buf[(660 - _start) as usize] = _value[0];
                    }
                    if _start <= 661 && _end > 661 {
                        _buf[(661 - _start) as usize] = _value[1];
                    }
                    if _start <= 662 && _end > 662 {
                        _buf[(662 - _start) as usize] = _value[2];
                    }
                    if _start <= 663 && _end > 663 {
                        _buf[(663 - _start) as usize] = _value[3];
                    }
                }
                if _start < 668 && _end > 664 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr6()?
                        .to_ne_bytes();
                    if _start <= 664 && _end > 664 {
                        _buf[(664 - _start) as usize] = _value[0];
                    }
                    if _start <= 665 && _end > 665 {
                        _buf[(665 - _start) as usize] = _value[1];
                    }
                    if _start <= 666 && _end > 666 {
                        _buf[(666 - _start) as usize] = _value[2];
                    }
                    if _start <= 667 && _end > 667 {
                        _buf[(667 - _start) as usize] = _value[3];
                    }
                }
                if _start < 672 && _end > 668 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_icpr7()?
                        .to_ne_bytes();
                    if _start <= 668 && _end > 668 {
                        _buf[(668 - _start) as usize] = _value[0];
                    }
                    if _start <= 669 && _end > 669 {
                        _buf[(669 - _start) as usize] = _value[1];
                    }
                    if _start <= 670 && _end > 670 {
                        _buf[(670 - _start) as usize] = _value[2];
                    }
                    if _start <= 671 && _end > 671 {
                        _buf[(671 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (768..=799, 769..=800) => {
                if _start < 772 && _end > 768 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr0()?
                        .to_ne_bytes();
                    if _start <= 768 && _end > 768 {
                        _buf[(768 - _start) as usize] = _value[0];
                    }
                    if _start <= 769 && _end > 769 {
                        _buf[(769 - _start) as usize] = _value[1];
                    }
                    if _start <= 770 && _end > 770 {
                        _buf[(770 - _start) as usize] = _value[2];
                    }
                    if _start <= 771 && _end > 771 {
                        _buf[(771 - _start) as usize] = _value[3];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr1()?
                        .to_ne_bytes();
                    if _start <= 772 && _end > 772 {
                        _buf[(772 - _start) as usize] = _value[0];
                    }
                    if _start <= 773 && _end > 773 {
                        _buf[(773 - _start) as usize] = _value[1];
                    }
                    if _start <= 774 && _end > 774 {
                        _buf[(774 - _start) as usize] = _value[2];
                    }
                    if _start <= 775 && _end > 775 {
                        _buf[(775 - _start) as usize] = _value[3];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr2()?
                        .to_ne_bytes();
                    if _start <= 776 && _end > 776 {
                        _buf[(776 - _start) as usize] = _value[0];
                    }
                    if _start <= 777 && _end > 777 {
                        _buf[(777 - _start) as usize] = _value[1];
                    }
                    if _start <= 778 && _end > 778 {
                        _buf[(778 - _start) as usize] = _value[2];
                    }
                    if _start <= 779 && _end > 779 {
                        _buf[(779 - _start) as usize] = _value[3];
                    }
                }
                if _start < 784 && _end > 780 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr3()?
                        .to_ne_bytes();
                    if _start <= 780 && _end > 780 {
                        _buf[(780 - _start) as usize] = _value[0];
                    }
                    if _start <= 781 && _end > 781 {
                        _buf[(781 - _start) as usize] = _value[1];
                    }
                    if _start <= 782 && _end > 782 {
                        _buf[(782 - _start) as usize] = _value[2];
                    }
                    if _start <= 783 && _end > 783 {
                        _buf[(783 - _start) as usize] = _value[3];
                    }
                }
                if _start < 788 && _end > 784 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr4()?
                        .to_ne_bytes();
                    if _start <= 784 && _end > 784 {
                        _buf[(784 - _start) as usize] = _value[0];
                    }
                    if _start <= 785 && _end > 785 {
                        _buf[(785 - _start) as usize] = _value[1];
                    }
                    if _start <= 786 && _end > 786 {
                        _buf[(786 - _start) as usize] = _value[2];
                    }
                    if _start <= 787 && _end > 787 {
                        _buf[(787 - _start) as usize] = _value[3];
                    }
                }
                if _start < 792 && _end > 788 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr5()?
                        .to_ne_bytes();
                    if _start <= 788 && _end > 788 {
                        _buf[(788 - _start) as usize] = _value[0];
                    }
                    if _start <= 789 && _end > 789 {
                        _buf[(789 - _start) as usize] = _value[1];
                    }
                    if _start <= 790 && _end > 790 {
                        _buf[(790 - _start) as usize] = _value[2];
                    }
                    if _start <= 791 && _end > 791 {
                        _buf[(791 - _start) as usize] = _value[3];
                    }
                }
                if _start < 796 && _end > 792 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr6()?
                        .to_ne_bytes();
                    if _start <= 792 && _end > 792 {
                        _buf[(792 - _start) as usize] = _value[0];
                    }
                    if _start <= 793 && _end > 793 {
                        _buf[(793 - _start) as usize] = _value[1];
                    }
                    if _start <= 794 && _end > 794 {
                        _buf[(794 - _start) as usize] = _value[2];
                    }
                    if _start <= 795 && _end > 795 {
                        _buf[(795 - _start) as usize] = _value[3];
                    }
                }
                if _start < 800 && _end > 796 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_nvic_nvic_iabr7()?
                        .to_ne_bytes();
                    if _start <= 796 && _end > 796 {
                        _buf[(796 - _start) as usize] = _value[0];
                    }
                    if _start <= 797 && _end > 797 {
                        _buf[(797 - _start) as usize] = _value[1];
                    }
                    if _start <= 798 && _end > 798 {
                        _buf[(798 - _start) as usize] = _value[2];
                    }
                    if _start <= 799 && _end > 799 {
                        _buf[(799 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (1024..=1263, 1025..=1264) => {
                if _start < 1028 && _end > 1024 {
                    let _value = self.read_nvic_nvic_ipr0()?.to_ne_bytes();
                    if _start <= 1024 && _end > 1024 {
                        _buf[(1024 - _start) as usize] = _value[0];
                    }
                    if _start <= 1025 && _end > 1025 {
                        _buf[(1025 - _start) as usize] = _value[1];
                    }
                    if _start <= 1026 && _end > 1026 {
                        _buf[(1026 - _start) as usize] = _value[2];
                    }
                    if _start <= 1027 && _end > 1027 {
                        _buf[(1027 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1032 && _end > 1028 {
                    let _value = self.read_nvic_nvic_ipr1()?.to_ne_bytes();
                    if _start <= 1028 && _end > 1028 {
                        _buf[(1028 - _start) as usize] = _value[0];
                    }
                    if _start <= 1029 && _end > 1029 {
                        _buf[(1029 - _start) as usize] = _value[1];
                    }
                    if _start <= 1030 && _end > 1030 {
                        _buf[(1030 - _start) as usize] = _value[2];
                    }
                    if _start <= 1031 && _end > 1031 {
                        _buf[(1031 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1036 && _end > 1032 {
                    let _value = self.read_nvic_nvic_ipr2()?.to_ne_bytes();
                    if _start <= 1032 && _end > 1032 {
                        _buf[(1032 - _start) as usize] = _value[0];
                    }
                    if _start <= 1033 && _end > 1033 {
                        _buf[(1033 - _start) as usize] = _value[1];
                    }
                    if _start <= 1034 && _end > 1034 {
                        _buf[(1034 - _start) as usize] = _value[2];
                    }
                    if _start <= 1035 && _end > 1035 {
                        _buf[(1035 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _value = self.read_nvic_nvic_ipr3()?.to_ne_bytes();
                    if _start <= 1036 && _end > 1036 {
                        _buf[(1036 - _start) as usize] = _value[0];
                    }
                    if _start <= 1037 && _end > 1037 {
                        _buf[(1037 - _start) as usize] = _value[1];
                    }
                    if _start <= 1038 && _end > 1038 {
                        _buf[(1038 - _start) as usize] = _value[2];
                    }
                    if _start <= 1039 && _end > 1039 {
                        _buf[(1039 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1044 && _end > 1040 {
                    let _value = self.read_nvic_nvic_ipr4()?.to_ne_bytes();
                    if _start <= 1040 && _end > 1040 {
                        _buf[(1040 - _start) as usize] = _value[0];
                    }
                    if _start <= 1041 && _end > 1041 {
                        _buf[(1041 - _start) as usize] = _value[1];
                    }
                    if _start <= 1042 && _end > 1042 {
                        _buf[(1042 - _start) as usize] = _value[2];
                    }
                    if _start <= 1043 && _end > 1043 {
                        _buf[(1043 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1048 && _end > 1044 {
                    let _value = self.read_nvic_nvic_ipr5()?.to_ne_bytes();
                    if _start <= 1044 && _end > 1044 {
                        _buf[(1044 - _start) as usize] = _value[0];
                    }
                    if _start <= 1045 && _end > 1045 {
                        _buf[(1045 - _start) as usize] = _value[1];
                    }
                    if _start <= 1046 && _end > 1046 {
                        _buf[(1046 - _start) as usize] = _value[2];
                    }
                    if _start <= 1047 && _end > 1047 {
                        _buf[(1047 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1052 && _end > 1048 {
                    let _value = self.read_nvic_nvic_ipr6()?.to_ne_bytes();
                    if _start <= 1048 && _end > 1048 {
                        _buf[(1048 - _start) as usize] = _value[0];
                    }
                    if _start <= 1049 && _end > 1049 {
                        _buf[(1049 - _start) as usize] = _value[1];
                    }
                    if _start <= 1050 && _end > 1050 {
                        _buf[(1050 - _start) as usize] = _value[2];
                    }
                    if _start <= 1051 && _end > 1051 {
                        _buf[(1051 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1056 && _end > 1052 {
                    let _value = self.read_nvic_nvic_ipr7()?.to_ne_bytes();
                    if _start <= 1052 && _end > 1052 {
                        _buf[(1052 - _start) as usize] = _value[0];
                    }
                    if _start <= 1053 && _end > 1053 {
                        _buf[(1053 - _start) as usize] = _value[1];
                    }
                    if _start <= 1054 && _end > 1054 {
                        _buf[(1054 - _start) as usize] = _value[2];
                    }
                    if _start <= 1055 && _end > 1055 {
                        _buf[(1055 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1060 && _end > 1056 {
                    let _value = self.read_nvic_nvic_ipr8()?.to_ne_bytes();
                    if _start <= 1056 && _end > 1056 {
                        _buf[(1056 - _start) as usize] = _value[0];
                    }
                    if _start <= 1057 && _end > 1057 {
                        _buf[(1057 - _start) as usize] = _value[1];
                    }
                    if _start <= 1058 && _end > 1058 {
                        _buf[(1058 - _start) as usize] = _value[2];
                    }
                    if _start <= 1059 && _end > 1059 {
                        _buf[(1059 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1064 && _end > 1060 {
                    let _value = self.read_nvic_nvic_ipr9()?.to_ne_bytes();
                    if _start <= 1060 && _end > 1060 {
                        _buf[(1060 - _start) as usize] = _value[0];
                    }
                    if _start <= 1061 && _end > 1061 {
                        _buf[(1061 - _start) as usize] = _value[1];
                    }
                    if _start <= 1062 && _end > 1062 {
                        _buf[(1062 - _start) as usize] = _value[2];
                    }
                    if _start <= 1063 && _end > 1063 {
                        _buf[(1063 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1068 && _end > 1064 {
                    let _value = self.read_nvic_nvic_ipr10()?.to_ne_bytes();
                    if _start <= 1064 && _end > 1064 {
                        _buf[(1064 - _start) as usize] = _value[0];
                    }
                    if _start <= 1065 && _end > 1065 {
                        _buf[(1065 - _start) as usize] = _value[1];
                    }
                    if _start <= 1066 && _end > 1066 {
                        _buf[(1066 - _start) as usize] = _value[2];
                    }
                    if _start <= 1067 && _end > 1067 {
                        _buf[(1067 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1072 && _end > 1068 {
                    let _value = self.read_nvic_nvic_ipr11()?.to_ne_bytes();
                    if _start <= 1068 && _end > 1068 {
                        _buf[(1068 - _start) as usize] = _value[0];
                    }
                    if _start <= 1069 && _end > 1069 {
                        _buf[(1069 - _start) as usize] = _value[1];
                    }
                    if _start <= 1070 && _end > 1070 {
                        _buf[(1070 - _start) as usize] = _value[2];
                    }
                    if _start <= 1071 && _end > 1071 {
                        _buf[(1071 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1076 && _end > 1072 {
                    let _value = self.read_nvic_nvic_ipr12()?.to_ne_bytes();
                    if _start <= 1072 && _end > 1072 {
                        _buf[(1072 - _start) as usize] = _value[0];
                    }
                    if _start <= 1073 && _end > 1073 {
                        _buf[(1073 - _start) as usize] = _value[1];
                    }
                    if _start <= 1074 && _end > 1074 {
                        _buf[(1074 - _start) as usize] = _value[2];
                    }
                    if _start <= 1075 && _end > 1075 {
                        _buf[(1075 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1080 && _end > 1076 {
                    let _value = self.read_nvic_nvic_ipr13()?.to_ne_bytes();
                    if _start <= 1076 && _end > 1076 {
                        _buf[(1076 - _start) as usize] = _value[0];
                    }
                    if _start <= 1077 && _end > 1077 {
                        _buf[(1077 - _start) as usize] = _value[1];
                    }
                    if _start <= 1078 && _end > 1078 {
                        _buf[(1078 - _start) as usize] = _value[2];
                    }
                    if _start <= 1079 && _end > 1079 {
                        _buf[(1079 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1084 && _end > 1080 {
                    let _value = self.read_nvic_nvic_ipr14()?.to_ne_bytes();
                    if _start <= 1080 && _end > 1080 {
                        _buf[(1080 - _start) as usize] = _value[0];
                    }
                    if _start <= 1081 && _end > 1081 {
                        _buf[(1081 - _start) as usize] = _value[1];
                    }
                    if _start <= 1082 && _end > 1082 {
                        _buf[(1082 - _start) as usize] = _value[2];
                    }
                    if _start <= 1083 && _end > 1083 {
                        _buf[(1083 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1088 && _end > 1084 {
                    let _value = self.read_nvic_nvic_ipr15()?.to_ne_bytes();
                    if _start <= 1084 && _end > 1084 {
                        _buf[(1084 - _start) as usize] = _value[0];
                    }
                    if _start <= 1085 && _end > 1085 {
                        _buf[(1085 - _start) as usize] = _value[1];
                    }
                    if _start <= 1086 && _end > 1086 {
                        _buf[(1086 - _start) as usize] = _value[2];
                    }
                    if _start <= 1087 && _end > 1087 {
                        _buf[(1087 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1092 && _end > 1088 {
                    let _value = self.read_nvic_nvic_ipr16()?.to_ne_bytes();
                    if _start <= 1088 && _end > 1088 {
                        _buf[(1088 - _start) as usize] = _value[0];
                    }
                    if _start <= 1089 && _end > 1089 {
                        _buf[(1089 - _start) as usize] = _value[1];
                    }
                    if _start <= 1090 && _end > 1090 {
                        _buf[(1090 - _start) as usize] = _value[2];
                    }
                    if _start <= 1091 && _end > 1091 {
                        _buf[(1091 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1096 && _end > 1092 {
                    let _value = self.read_nvic_nvic_ipr17()?.to_ne_bytes();
                    if _start <= 1092 && _end > 1092 {
                        _buf[(1092 - _start) as usize] = _value[0];
                    }
                    if _start <= 1093 && _end > 1093 {
                        _buf[(1093 - _start) as usize] = _value[1];
                    }
                    if _start <= 1094 && _end > 1094 {
                        _buf[(1094 - _start) as usize] = _value[2];
                    }
                    if _start <= 1095 && _end > 1095 {
                        _buf[(1095 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1100 && _end > 1096 {
                    let _value = self.read_nvic_nvic_ipr18()?.to_ne_bytes();
                    if _start <= 1096 && _end > 1096 {
                        _buf[(1096 - _start) as usize] = _value[0];
                    }
                    if _start <= 1097 && _end > 1097 {
                        _buf[(1097 - _start) as usize] = _value[1];
                    }
                    if _start <= 1098 && _end > 1098 {
                        _buf[(1098 - _start) as usize] = _value[2];
                    }
                    if _start <= 1099 && _end > 1099 {
                        _buf[(1099 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1104 && _end > 1100 {
                    let _value = self.read_nvic_nvic_ipr19()?.to_ne_bytes();
                    if _start <= 1100 && _end > 1100 {
                        _buf[(1100 - _start) as usize] = _value[0];
                    }
                    if _start <= 1101 && _end > 1101 {
                        _buf[(1101 - _start) as usize] = _value[1];
                    }
                    if _start <= 1102 && _end > 1102 {
                        _buf[(1102 - _start) as usize] = _value[2];
                    }
                    if _start <= 1103 && _end > 1103 {
                        _buf[(1103 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1108 && _end > 1104 {
                    let _value = self.read_nvic_nvic_ipr20()?.to_ne_bytes();
                    if _start <= 1104 && _end > 1104 {
                        _buf[(1104 - _start) as usize] = _value[0];
                    }
                    if _start <= 1105 && _end > 1105 {
                        _buf[(1105 - _start) as usize] = _value[1];
                    }
                    if _start <= 1106 && _end > 1106 {
                        _buf[(1106 - _start) as usize] = _value[2];
                    }
                    if _start <= 1107 && _end > 1107 {
                        _buf[(1107 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1112 && _end > 1108 {
                    let _value = self.read_nvic_nvic_ipr21()?.to_ne_bytes();
                    if _start <= 1108 && _end > 1108 {
                        _buf[(1108 - _start) as usize] = _value[0];
                    }
                    if _start <= 1109 && _end > 1109 {
                        _buf[(1109 - _start) as usize] = _value[1];
                    }
                    if _start <= 1110 && _end > 1110 {
                        _buf[(1110 - _start) as usize] = _value[2];
                    }
                    if _start <= 1111 && _end > 1111 {
                        _buf[(1111 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1116 && _end > 1112 {
                    let _value = self.read_nvic_nvic_ipr22()?.to_ne_bytes();
                    if _start <= 1112 && _end > 1112 {
                        _buf[(1112 - _start) as usize] = _value[0];
                    }
                    if _start <= 1113 && _end > 1113 {
                        _buf[(1113 - _start) as usize] = _value[1];
                    }
                    if _start <= 1114 && _end > 1114 {
                        _buf[(1114 - _start) as usize] = _value[2];
                    }
                    if _start <= 1115 && _end > 1115 {
                        _buf[(1115 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1120 && _end > 1116 {
                    let _value = self.read_nvic_nvic_ipr23()?.to_ne_bytes();
                    if _start <= 1116 && _end > 1116 {
                        _buf[(1116 - _start) as usize] = _value[0];
                    }
                    if _start <= 1117 && _end > 1117 {
                        _buf[(1117 - _start) as usize] = _value[1];
                    }
                    if _start <= 1118 && _end > 1118 {
                        _buf[(1118 - _start) as usize] = _value[2];
                    }
                    if _start <= 1119 && _end > 1119 {
                        _buf[(1119 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1124 && _end > 1120 {
                    let _value = self.read_nvic_nvic_ipr24()?.to_ne_bytes();
                    if _start <= 1120 && _end > 1120 {
                        _buf[(1120 - _start) as usize] = _value[0];
                    }
                    if _start <= 1121 && _end > 1121 {
                        _buf[(1121 - _start) as usize] = _value[1];
                    }
                    if _start <= 1122 && _end > 1122 {
                        _buf[(1122 - _start) as usize] = _value[2];
                    }
                    if _start <= 1123 && _end > 1123 {
                        _buf[(1123 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1128 && _end > 1124 {
                    let _value = self.read_nvic_nvic_ipr25()?.to_ne_bytes();
                    if _start <= 1124 && _end > 1124 {
                        _buf[(1124 - _start) as usize] = _value[0];
                    }
                    if _start <= 1125 && _end > 1125 {
                        _buf[(1125 - _start) as usize] = _value[1];
                    }
                    if _start <= 1126 && _end > 1126 {
                        _buf[(1126 - _start) as usize] = _value[2];
                    }
                    if _start <= 1127 && _end > 1127 {
                        _buf[(1127 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1132 && _end > 1128 {
                    let _value = self.read_nvic_nvic_ipr26()?.to_ne_bytes();
                    if _start <= 1128 && _end > 1128 {
                        _buf[(1128 - _start) as usize] = _value[0];
                    }
                    if _start <= 1129 && _end > 1129 {
                        _buf[(1129 - _start) as usize] = _value[1];
                    }
                    if _start <= 1130 && _end > 1130 {
                        _buf[(1130 - _start) as usize] = _value[2];
                    }
                    if _start <= 1131 && _end > 1131 {
                        _buf[(1131 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1136 && _end > 1132 {
                    let _value = self.read_nvic_nvic_ipr27()?.to_ne_bytes();
                    if _start <= 1132 && _end > 1132 {
                        _buf[(1132 - _start) as usize] = _value[0];
                    }
                    if _start <= 1133 && _end > 1133 {
                        _buf[(1133 - _start) as usize] = _value[1];
                    }
                    if _start <= 1134 && _end > 1134 {
                        _buf[(1134 - _start) as usize] = _value[2];
                    }
                    if _start <= 1135 && _end > 1135 {
                        _buf[(1135 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1140 && _end > 1136 {
                    let _value = self.read_nvic_nvic_ipr28()?.to_ne_bytes();
                    if _start <= 1136 && _end > 1136 {
                        _buf[(1136 - _start) as usize] = _value[0];
                    }
                    if _start <= 1137 && _end > 1137 {
                        _buf[(1137 - _start) as usize] = _value[1];
                    }
                    if _start <= 1138 && _end > 1138 {
                        _buf[(1138 - _start) as usize] = _value[2];
                    }
                    if _start <= 1139 && _end > 1139 {
                        _buf[(1139 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1144 && _end > 1140 {
                    let _value = self.read_nvic_nvic_ipr29()?.to_ne_bytes();
                    if _start <= 1140 && _end > 1140 {
                        _buf[(1140 - _start) as usize] = _value[0];
                    }
                    if _start <= 1141 && _end > 1141 {
                        _buf[(1141 - _start) as usize] = _value[1];
                    }
                    if _start <= 1142 && _end > 1142 {
                        _buf[(1142 - _start) as usize] = _value[2];
                    }
                    if _start <= 1143 && _end > 1143 {
                        _buf[(1143 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1148 && _end > 1144 {
                    let _value = self.read_nvic_nvic_ipr30()?.to_ne_bytes();
                    if _start <= 1144 && _end > 1144 {
                        _buf[(1144 - _start) as usize] = _value[0];
                    }
                    if _start <= 1145 && _end > 1145 {
                        _buf[(1145 - _start) as usize] = _value[1];
                    }
                    if _start <= 1146 && _end > 1146 {
                        _buf[(1146 - _start) as usize] = _value[2];
                    }
                    if _start <= 1147 && _end > 1147 {
                        _buf[(1147 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1152 && _end > 1148 {
                    let _value = self.read_nvic_nvic_ipr31()?.to_ne_bytes();
                    if _start <= 1148 && _end > 1148 {
                        _buf[(1148 - _start) as usize] = _value[0];
                    }
                    if _start <= 1149 && _end > 1149 {
                        _buf[(1149 - _start) as usize] = _value[1];
                    }
                    if _start <= 1150 && _end > 1150 {
                        _buf[(1150 - _start) as usize] = _value[2];
                    }
                    if _start <= 1151 && _end > 1151 {
                        _buf[(1151 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1156 && _end > 1152 {
                    let _value = self.read_nvic_nvic_ipr32()?.to_ne_bytes();
                    if _start <= 1152 && _end > 1152 {
                        _buf[(1152 - _start) as usize] = _value[0];
                    }
                    if _start <= 1153 && _end > 1153 {
                        _buf[(1153 - _start) as usize] = _value[1];
                    }
                    if _start <= 1154 && _end > 1154 {
                        _buf[(1154 - _start) as usize] = _value[2];
                    }
                    if _start <= 1155 && _end > 1155 {
                        _buf[(1155 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1160 && _end > 1156 {
                    let _value = self.read_nvic_nvic_ipr33()?.to_ne_bytes();
                    if _start <= 1156 && _end > 1156 {
                        _buf[(1156 - _start) as usize] = _value[0];
                    }
                    if _start <= 1157 && _end > 1157 {
                        _buf[(1157 - _start) as usize] = _value[1];
                    }
                    if _start <= 1158 && _end > 1158 {
                        _buf[(1158 - _start) as usize] = _value[2];
                    }
                    if _start <= 1159 && _end > 1159 {
                        _buf[(1159 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1164 && _end > 1160 {
                    let _value = self.read_nvic_nvic_ipr34()?.to_ne_bytes();
                    if _start <= 1160 && _end > 1160 {
                        _buf[(1160 - _start) as usize] = _value[0];
                    }
                    if _start <= 1161 && _end > 1161 {
                        _buf[(1161 - _start) as usize] = _value[1];
                    }
                    if _start <= 1162 && _end > 1162 {
                        _buf[(1162 - _start) as usize] = _value[2];
                    }
                    if _start <= 1163 && _end > 1163 {
                        _buf[(1163 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1168 && _end > 1164 {
                    let _value = self.read_nvic_nvic_ipr35()?.to_ne_bytes();
                    if _start <= 1164 && _end > 1164 {
                        _buf[(1164 - _start) as usize] = _value[0];
                    }
                    if _start <= 1165 && _end > 1165 {
                        _buf[(1165 - _start) as usize] = _value[1];
                    }
                    if _start <= 1166 && _end > 1166 {
                        _buf[(1166 - _start) as usize] = _value[2];
                    }
                    if _start <= 1167 && _end > 1167 {
                        _buf[(1167 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1172 && _end > 1168 {
                    let _value = self.read_nvic_nvic_ipr36()?.to_ne_bytes();
                    if _start <= 1168 && _end > 1168 {
                        _buf[(1168 - _start) as usize] = _value[0];
                    }
                    if _start <= 1169 && _end > 1169 {
                        _buf[(1169 - _start) as usize] = _value[1];
                    }
                    if _start <= 1170 && _end > 1170 {
                        _buf[(1170 - _start) as usize] = _value[2];
                    }
                    if _start <= 1171 && _end > 1171 {
                        _buf[(1171 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1176 && _end > 1172 {
                    let _value = self.read_nvic_nvic_ipr37()?.to_ne_bytes();
                    if _start <= 1172 && _end > 1172 {
                        _buf[(1172 - _start) as usize] = _value[0];
                    }
                    if _start <= 1173 && _end > 1173 {
                        _buf[(1173 - _start) as usize] = _value[1];
                    }
                    if _start <= 1174 && _end > 1174 {
                        _buf[(1174 - _start) as usize] = _value[2];
                    }
                    if _start <= 1175 && _end > 1175 {
                        _buf[(1175 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1180 && _end > 1176 {
                    let _value = self.read_nvic_nvic_ipr38()?.to_ne_bytes();
                    if _start <= 1176 && _end > 1176 {
                        _buf[(1176 - _start) as usize] = _value[0];
                    }
                    if _start <= 1177 && _end > 1177 {
                        _buf[(1177 - _start) as usize] = _value[1];
                    }
                    if _start <= 1178 && _end > 1178 {
                        _buf[(1178 - _start) as usize] = _value[2];
                    }
                    if _start <= 1179 && _end > 1179 {
                        _buf[(1179 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1184 && _end > 1180 {
                    let _value = self.read_nvic_nvic_ipr39()?.to_ne_bytes();
                    if _start <= 1180 && _end > 1180 {
                        _buf[(1180 - _start) as usize] = _value[0];
                    }
                    if _start <= 1181 && _end > 1181 {
                        _buf[(1181 - _start) as usize] = _value[1];
                    }
                    if _start <= 1182 && _end > 1182 {
                        _buf[(1182 - _start) as usize] = _value[2];
                    }
                    if _start <= 1183 && _end > 1183 {
                        _buf[(1183 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1188 && _end > 1184 {
                    let _value = self.read_nvic_nvic_ipr40()?.to_ne_bytes();
                    if _start <= 1184 && _end > 1184 {
                        _buf[(1184 - _start) as usize] = _value[0];
                    }
                    if _start <= 1185 && _end > 1185 {
                        _buf[(1185 - _start) as usize] = _value[1];
                    }
                    if _start <= 1186 && _end > 1186 {
                        _buf[(1186 - _start) as usize] = _value[2];
                    }
                    if _start <= 1187 && _end > 1187 {
                        _buf[(1187 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1192 && _end > 1188 {
                    let _value = self.read_nvic_nvic_ipr41()?.to_ne_bytes();
                    if _start <= 1188 && _end > 1188 {
                        _buf[(1188 - _start) as usize] = _value[0];
                    }
                    if _start <= 1189 && _end > 1189 {
                        _buf[(1189 - _start) as usize] = _value[1];
                    }
                    if _start <= 1190 && _end > 1190 {
                        _buf[(1190 - _start) as usize] = _value[2];
                    }
                    if _start <= 1191 && _end > 1191 {
                        _buf[(1191 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1196 && _end > 1192 {
                    let _value = self.read_nvic_nvic_ipr42()?.to_ne_bytes();
                    if _start <= 1192 && _end > 1192 {
                        _buf[(1192 - _start) as usize] = _value[0];
                    }
                    if _start <= 1193 && _end > 1193 {
                        _buf[(1193 - _start) as usize] = _value[1];
                    }
                    if _start <= 1194 && _end > 1194 {
                        _buf[(1194 - _start) as usize] = _value[2];
                    }
                    if _start <= 1195 && _end > 1195 {
                        _buf[(1195 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1200 && _end > 1196 {
                    let _value = self.read_nvic_nvic_ipr43()?.to_ne_bytes();
                    if _start <= 1196 && _end > 1196 {
                        _buf[(1196 - _start) as usize] = _value[0];
                    }
                    if _start <= 1197 && _end > 1197 {
                        _buf[(1197 - _start) as usize] = _value[1];
                    }
                    if _start <= 1198 && _end > 1198 {
                        _buf[(1198 - _start) as usize] = _value[2];
                    }
                    if _start <= 1199 && _end > 1199 {
                        _buf[(1199 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1204 && _end > 1200 {
                    let _value = self.read_nvic_nvic_ipr44()?.to_ne_bytes();
                    if _start <= 1200 && _end > 1200 {
                        _buf[(1200 - _start) as usize] = _value[0];
                    }
                    if _start <= 1201 && _end > 1201 {
                        _buf[(1201 - _start) as usize] = _value[1];
                    }
                    if _start <= 1202 && _end > 1202 {
                        _buf[(1202 - _start) as usize] = _value[2];
                    }
                    if _start <= 1203 && _end > 1203 {
                        _buf[(1203 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1208 && _end > 1204 {
                    let _value = self.read_nvic_nvic_ipr45()?.to_ne_bytes();
                    if _start <= 1204 && _end > 1204 {
                        _buf[(1204 - _start) as usize] = _value[0];
                    }
                    if _start <= 1205 && _end > 1205 {
                        _buf[(1205 - _start) as usize] = _value[1];
                    }
                    if _start <= 1206 && _end > 1206 {
                        _buf[(1206 - _start) as usize] = _value[2];
                    }
                    if _start <= 1207 && _end > 1207 {
                        _buf[(1207 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1212 && _end > 1208 {
                    let _value = self.read_nvic_nvic_ipr46()?.to_ne_bytes();
                    if _start <= 1208 && _end > 1208 {
                        _buf[(1208 - _start) as usize] = _value[0];
                    }
                    if _start <= 1209 && _end > 1209 {
                        _buf[(1209 - _start) as usize] = _value[1];
                    }
                    if _start <= 1210 && _end > 1210 {
                        _buf[(1210 - _start) as usize] = _value[2];
                    }
                    if _start <= 1211 && _end > 1211 {
                        _buf[(1211 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1216 && _end > 1212 {
                    let _value = self.read_nvic_nvic_ipr47()?.to_ne_bytes();
                    if _start <= 1212 && _end > 1212 {
                        _buf[(1212 - _start) as usize] = _value[0];
                    }
                    if _start <= 1213 && _end > 1213 {
                        _buf[(1213 - _start) as usize] = _value[1];
                    }
                    if _start <= 1214 && _end > 1214 {
                        _buf[(1214 - _start) as usize] = _value[2];
                    }
                    if _start <= 1215 && _end > 1215 {
                        _buf[(1215 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1220 && _end > 1216 {
                    let _value = self.read_nvic_nvic_ipr48()?.to_ne_bytes();
                    if _start <= 1216 && _end > 1216 {
                        _buf[(1216 - _start) as usize] = _value[0];
                    }
                    if _start <= 1217 && _end > 1217 {
                        _buf[(1217 - _start) as usize] = _value[1];
                    }
                    if _start <= 1218 && _end > 1218 {
                        _buf[(1218 - _start) as usize] = _value[2];
                    }
                    if _start <= 1219 && _end > 1219 {
                        _buf[(1219 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1224 && _end > 1220 {
                    let _value = self.read_nvic_nvic_ipr49()?.to_ne_bytes();
                    if _start <= 1220 && _end > 1220 {
                        _buf[(1220 - _start) as usize] = _value[0];
                    }
                    if _start <= 1221 && _end > 1221 {
                        _buf[(1221 - _start) as usize] = _value[1];
                    }
                    if _start <= 1222 && _end > 1222 {
                        _buf[(1222 - _start) as usize] = _value[2];
                    }
                    if _start <= 1223 && _end > 1223 {
                        _buf[(1223 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1228 && _end > 1224 {
                    let _value = self.read_nvic_nvic_ipr50()?.to_ne_bytes();
                    if _start <= 1224 && _end > 1224 {
                        _buf[(1224 - _start) as usize] = _value[0];
                    }
                    if _start <= 1225 && _end > 1225 {
                        _buf[(1225 - _start) as usize] = _value[1];
                    }
                    if _start <= 1226 && _end > 1226 {
                        _buf[(1226 - _start) as usize] = _value[2];
                    }
                    if _start <= 1227 && _end > 1227 {
                        _buf[(1227 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1232 && _end > 1228 {
                    let _value = self.read_nvic_nvic_ipr51()?.to_ne_bytes();
                    if _start <= 1228 && _end > 1228 {
                        _buf[(1228 - _start) as usize] = _value[0];
                    }
                    if _start <= 1229 && _end > 1229 {
                        _buf[(1229 - _start) as usize] = _value[1];
                    }
                    if _start <= 1230 && _end > 1230 {
                        _buf[(1230 - _start) as usize] = _value[2];
                    }
                    if _start <= 1231 && _end > 1231 {
                        _buf[(1231 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1236 && _end > 1232 {
                    let _value = self.read_nvic_nvic_ipr52()?.to_ne_bytes();
                    if _start <= 1232 && _end > 1232 {
                        _buf[(1232 - _start) as usize] = _value[0];
                    }
                    if _start <= 1233 && _end > 1233 {
                        _buf[(1233 - _start) as usize] = _value[1];
                    }
                    if _start <= 1234 && _end > 1234 {
                        _buf[(1234 - _start) as usize] = _value[2];
                    }
                    if _start <= 1235 && _end > 1235 {
                        _buf[(1235 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1240 && _end > 1236 {
                    let _value = self.read_nvic_nvic_ipr53()?.to_ne_bytes();
                    if _start <= 1236 && _end > 1236 {
                        _buf[(1236 - _start) as usize] = _value[0];
                    }
                    if _start <= 1237 && _end > 1237 {
                        _buf[(1237 - _start) as usize] = _value[1];
                    }
                    if _start <= 1238 && _end > 1238 {
                        _buf[(1238 - _start) as usize] = _value[2];
                    }
                    if _start <= 1239 && _end > 1239 {
                        _buf[(1239 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1244 && _end > 1240 {
                    let _value = self.read_nvic_nvic_ipr54()?.to_ne_bytes();
                    if _start <= 1240 && _end > 1240 {
                        _buf[(1240 - _start) as usize] = _value[0];
                    }
                    if _start <= 1241 && _end > 1241 {
                        _buf[(1241 - _start) as usize] = _value[1];
                    }
                    if _start <= 1242 && _end > 1242 {
                        _buf[(1242 - _start) as usize] = _value[2];
                    }
                    if _start <= 1243 && _end > 1243 {
                        _buf[(1243 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1248 && _end > 1244 {
                    let _value = self.read_nvic_nvic_ipr55()?.to_ne_bytes();
                    if _start <= 1244 && _end > 1244 {
                        _buf[(1244 - _start) as usize] = _value[0];
                    }
                    if _start <= 1245 && _end > 1245 {
                        _buf[(1245 - _start) as usize] = _value[1];
                    }
                    if _start <= 1246 && _end > 1246 {
                        _buf[(1246 - _start) as usize] = _value[2];
                    }
                    if _start <= 1247 && _end > 1247 {
                        _buf[(1247 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1252 && _end > 1248 {
                    let _value = self.read_nvic_nvic_ipr56()?.to_ne_bytes();
                    if _start <= 1248 && _end > 1248 {
                        _buf[(1248 - _start) as usize] = _value[0];
                    }
                    if _start <= 1249 && _end > 1249 {
                        _buf[(1249 - _start) as usize] = _value[1];
                    }
                    if _start <= 1250 && _end > 1250 {
                        _buf[(1250 - _start) as usize] = _value[2];
                    }
                    if _start <= 1251 && _end > 1251 {
                        _buf[(1251 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1256 && _end > 1252 {
                    let _value = self.read_nvic_nvic_ipr57()?.to_ne_bytes();
                    if _start <= 1252 && _end > 1252 {
                        _buf[(1252 - _start) as usize] = _value[0];
                    }
                    if _start <= 1253 && _end > 1253 {
                        _buf[(1253 - _start) as usize] = _value[1];
                    }
                    if _start <= 1254 && _end > 1254 {
                        _buf[(1254 - _start) as usize] = _value[2];
                    }
                    if _start <= 1255 && _end > 1255 {
                        _buf[(1255 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1260 && _end > 1256 {
                    let _value = self.read_nvic_nvic_ipr58()?.to_ne_bytes();
                    if _start <= 1256 && _end > 1256 {
                        _buf[(1256 - _start) as usize] = _value[0];
                    }
                    if _start <= 1257 && _end > 1257 {
                        _buf[(1257 - _start) as usize] = _value[1];
                    }
                    if _start <= 1258 && _end > 1258 {
                        _buf[(1258 - _start) as usize] = _value[2];
                    }
                    if _start <= 1259 && _end > 1259 {
                        _buf[(1259 - _start) as usize] = _value[3];
                    }
                }
                if _start < 1264 && _end > 1260 {
                    let _value = self.read_nvic_nvic_ipr59()?.to_ne_bytes();
                    if _start <= 1260 && _end > 1260 {
                        _buf[(1260 - _start) as usize] = _value[0];
                    }
                    if _start <= 1261 && _end > 1261 {
                        _buf[(1261 - _start) as usize] = _value[1];
                    }
                    if _start <= 1262 && _end > 1262 {
                        _buf[(1262 - _start) as usize] = _value[2];
                    }
                    if _start <= 1263 && _end > 1263 {
                        _buf[(1263 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3328..=3443, 3329..=3444) => {
                if _start < 3332 && _end > 3328 {
                    let _value = self.read_id_cpuid()?.to_ne_bytes();
                    if _start <= 3328 && _end > 3328 {
                        _buf[(3328 - _start) as usize] = _value[0];
                    }
                    if _start <= 3329 && _end > 3329 {
                        _buf[(3329 - _start) as usize] = _value[1];
                    }
                    if _start <= 3330 && _end > 3330 {
                        _buf[(3330 - _start) as usize] = _value[2];
                    }
                    if _start <= 3331 && _end > 3331 {
                        _buf[(3331 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3336 && _end > 3332 {
                    let _value = self.read_control_icsr()?.to_ne_bytes();
                    if _start <= 3332 && _end > 3332 {
                        _buf[(3332 - _start) as usize] = _value[0];
                    }
                    if _start <= 3333 && _end > 3333 {
                        _buf[(3333 - _start) as usize] = _value[1];
                    }
                    if _start <= 3334 && _end > 3334 {
                        _buf[(3334 - _start) as usize] = _value[2];
                    }
                    if _start <= 3335 && _end > 3335 {
                        _buf[(3335 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3340 && _end > 3336 {
                    let _value = self.read_control_vtor()?.to_ne_bytes();
                    if _start <= 3336 && _end > 3336 {
                        _buf[(3336 - _start) as usize] = _value[0];
                    }
                    if _start <= 3337 && _end > 3337 {
                        _buf[(3337 - _start) as usize] = _value[1];
                    }
                    if _start <= 3338 && _end > 3338 {
                        _buf[(3338 - _start) as usize] = _value[2];
                    }
                    if _start <= 3339 && _end > 3339 {
                        _buf[(3339 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3344 && _end > 3340 {
                    let _value = self.read_control_aircr()?.to_ne_bytes();
                    if _start <= 3340 && _end > 3340 {
                        _buf[(3340 - _start) as usize] = _value[0];
                    }
                    if _start <= 3341 && _end > 3341 {
                        _buf[(3341 - _start) as usize] = _value[1];
                    }
                    if _start <= 3342 && _end > 3342 {
                        _buf[(3342 - _start) as usize] = _value[2];
                    }
                    if _start <= 3343 && _end > 3343 {
                        _buf[(3343 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3348 && _end > 3344 {
                    let _value = self.read_control_scr()?.to_ne_bytes();
                    if _start <= 3344 && _end > 3344 {
                        _buf[(3344 - _start) as usize] = _value[0];
                    }
                    if _start <= 3345 && _end > 3345 {
                        _buf[(3345 - _start) as usize] = _value[1];
                    }
                    if _start <= 3346 && _end > 3346 {
                        _buf[(3346 - _start) as usize] = _value[2];
                    }
                    if _start <= 3347 && _end > 3347 {
                        _buf[(3347 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3352 && _end > 3348 {
                    let _value = self.read_control_ccr()?.to_ne_bytes();
                    if _start <= 3348 && _end > 3348 {
                        _buf[(3348 - _start) as usize] = _value[0];
                    }
                    if _start <= 3349 && _end > 3349 {
                        _buf[(3349 - _start) as usize] = _value[1];
                    }
                    if _start <= 3350 && _end > 3350 {
                        _buf[(3350 - _start) as usize] = _value[2];
                    }
                    if _start <= 3351 && _end > 3351 {
                        _buf[(3351 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3356 && _end > 3352 {
                    let _value = self.read_control_shpr1()?.to_ne_bytes();
                    if _start <= 3352 && _end > 3352 {
                        _buf[(3352 - _start) as usize] = _value[0];
                    }
                    if _start <= 3353 && _end > 3353 {
                        _buf[(3353 - _start) as usize] = _value[1];
                    }
                    if _start <= 3354 && _end > 3354 {
                        _buf[(3354 - _start) as usize] = _value[2];
                    }
                    if _start <= 3355 && _end > 3355 {
                        _buf[(3355 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3360 && _end > 3356 {
                    let _value = self.read_control_shpr2()?.to_ne_bytes();
                    if _start <= 3356 && _end > 3356 {
                        _buf[(3356 - _start) as usize] = _value[0];
                    }
                    if _start <= 3357 && _end > 3357 {
                        _buf[(3357 - _start) as usize] = _value[1];
                    }
                    if _start <= 3358 && _end > 3358 {
                        _buf[(3358 - _start) as usize] = _value[2];
                    }
                    if _start <= 3359 && _end > 3359 {
                        _buf[(3359 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3364 && _end > 3360 {
                    let _value = self.read_control_shpr3()?.to_ne_bytes();
                    if _start <= 3360 && _end > 3360 {
                        _buf[(3360 - _start) as usize] = _value[0];
                    }
                    if _start <= 3361 && _end > 3361 {
                        _buf[(3361 - _start) as usize] = _value[1];
                    }
                    if _start <= 3362 && _end > 3362 {
                        _buf[(3362 - _start) as usize] = _value[2];
                    }
                    if _start <= 3363 && _end > 3363 {
                        _buf[(3363 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3368 && _end > 3364 {
                    let _value = self.read_control_shcsr()?.to_ne_bytes();
                    if _start <= 3364 && _end > 3364 {
                        _buf[(3364 - _start) as usize] = _value[0];
                    }
                    if _start <= 3365 && _end > 3365 {
                        _buf[(3365 - _start) as usize] = _value[1];
                    }
                    if _start <= 3366 && _end > 3366 {
                        _buf[(3366 - _start) as usize] = _value[2];
                    }
                    if _start <= 3367 && _end > 3367 {
                        _buf[(3367 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3372 && _end > 3368 {
                    let _value = self.read_control_cfsr()?.to_ne_bytes();
                    if _start <= 3368 && _end > 3368 {
                        _buf[(3368 - _start) as usize] = _value[0];
                    }
                    if _start <= 3369 && _end > 3369 {
                        _buf[(3369 - _start) as usize] = _value[1];
                    }
                    if _start <= 3370 && _end > 3370 {
                        _buf[(3370 - _start) as usize] = _value[2];
                    }
                    if _start <= 3371 && _end > 3371 {
                        _buf[(3371 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3376 && _end > 3372 {
                    let _value = self.read_control_hfsr()?.to_ne_bytes();
                    if _start <= 3372 && _end > 3372 {
                        _buf[(3372 - _start) as usize] = _value[0];
                    }
                    if _start <= 3373 && _end > 3373 {
                        _buf[(3373 - _start) as usize] = _value[1];
                    }
                    if _start <= 3374 && _end > 3374 {
                        _buf[(3374 - _start) as usize] = _value[2];
                    }
                    if _start <= 3375 && _end > 3375 {
                        _buf[(3375 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3380 && _end > 3376 {
                    let _value = self.read_control_dfsr()?.to_ne_bytes();
                    if _start <= 3376 && _end > 3376 {
                        _buf[(3376 - _start) as usize] = _value[0];
                    }
                    if _start <= 3377 && _end > 3377 {
                        _buf[(3377 - _start) as usize] = _value[1];
                    }
                    if _start <= 3378 && _end > 3378 {
                        _buf[(3378 - _start) as usize] = _value[2];
                    }
                    if _start <= 3379 && _end > 3379 {
                        _buf[(3379 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3384 && _end > 3380 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_control_mmfar()?
                        .to_ne_bytes();
                    if _start <= 3380 && _end > 3380 {
                        _buf[(3380 - _start) as usize] = _value[0];
                    }
                    if _start <= 3381 && _end > 3381 {
                        _buf[(3381 - _start) as usize] = _value[1];
                    }
                    if _start <= 3382 && _end > 3382 {
                        _buf[(3382 - _start) as usize] = _value[2];
                    }
                    if _start <= 3383 && _end > 3383 {
                        _buf[(3383 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3388 && _end > 3384 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_control_bfar()?
                        .to_ne_bytes();
                    if _start <= 3384 && _end > 3384 {
                        _buf[(3384 - _start) as usize] = _value[0];
                    }
                    if _start <= 3385 && _end > 3385 {
                        _buf[(3385 - _start) as usize] = _value[1];
                    }
                    if _start <= 3386 && _end > 3386 {
                        _buf[(3386 - _start) as usize] = _value[2];
                    }
                    if _start <= 3387 && _end > 3387 {
                        _buf[(3387 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3392 && _end > 3388 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_control_afsr()?
                        .to_ne_bytes();
                    if _start <= 3388 && _end > 3388 {
                        _buf[(3388 - _start) as usize] = _value[0];
                    }
                    if _start <= 3389 && _end > 3389 {
                        _buf[(3389 - _start) as usize] = _value[1];
                    }
                    if _start <= 3390 && _end > 3390 {
                        _buf[(3390 - _start) as usize] = _value[2];
                    }
                    if _start <= 3391 && _end > 3391 {
                        _buf[(3391 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3396 && _end > 3392 {
                    let _value = self.read_id_id_pfr0()?.to_ne_bytes();
                    if _start <= 3392 && _end > 3392 {
                        _buf[(3392 - _start) as usize] = _value[0];
                    }
                    if _start <= 3393 && _end > 3393 {
                        _buf[(3393 - _start) as usize] = _value[1];
                    }
                    if _start <= 3394 && _end > 3394 {
                        _buf[(3394 - _start) as usize] = _value[2];
                    }
                    if _start <= 3395 && _end > 3395 {
                        _buf[(3395 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3400 && _end > 3396 {
                    let _value = self.read_id_id_pfr1()?.to_ne_bytes();
                    if _start <= 3396 && _end > 3396 {
                        _buf[(3396 - _start) as usize] = _value[0];
                    }
                    if _start <= 3397 && _end > 3397 {
                        _buf[(3397 - _start) as usize] = _value[1];
                    }
                    if _start <= 3398 && _end > 3398 {
                        _buf[(3398 - _start) as usize] = _value[2];
                    }
                    if _start <= 3399 && _end > 3399 {
                        _buf[(3399 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3404 && _end > 3400 {
                    let _value = self.read_id_id_dfr0()?.to_ne_bytes();
                    if _start <= 3400 && _end > 3400 {
                        _buf[(3400 - _start) as usize] = _value[0];
                    }
                    if _start <= 3401 && _end > 3401 {
                        _buf[(3401 - _start) as usize] = _value[1];
                    }
                    if _start <= 3402 && _end > 3402 {
                        _buf[(3402 - _start) as usize] = _value[2];
                    }
                    if _start <= 3403 && _end > 3403 {
                        _buf[(3403 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3408 && _end > 3404 {
                    let _value =
                        self.0.lock().unwrap().read_id_id_afr0()?.to_ne_bytes();
                    if _start <= 3404 && _end > 3404 {
                        _buf[(3404 - _start) as usize] = _value[0];
                    }
                    if _start <= 3405 && _end > 3405 {
                        _buf[(3405 - _start) as usize] = _value[1];
                    }
                    if _start <= 3406 && _end > 3406 {
                        _buf[(3406 - _start) as usize] = _value[2];
                    }
                    if _start <= 3407 && _end > 3407 {
                        _buf[(3407 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3412 && _end > 3408 {
                    let _value = self.read_id_id_mmfr0()?.to_ne_bytes();
                    if _start <= 3408 && _end > 3408 {
                        _buf[(3408 - _start) as usize] = _value[0];
                    }
                    if _start <= 3409 && _end > 3409 {
                        _buf[(3409 - _start) as usize] = _value[1];
                    }
                    if _start <= 3410 && _end > 3410 {
                        _buf[(3410 - _start) as usize] = _value[2];
                    }
                    if _start <= 3411 && _end > 3411 {
                        _buf[(3411 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3416 && _end > 3412 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_id_id_mmfr1()?
                        .to_ne_bytes();
                    if _start <= 3412 && _end > 3412 {
                        _buf[(3412 - _start) as usize] = _value[0];
                    }
                    if _start <= 3413 && _end > 3413 {
                        _buf[(3413 - _start) as usize] = _value[1];
                    }
                    if _start <= 3414 && _end > 3414 {
                        _buf[(3414 - _start) as usize] = _value[2];
                    }
                    if _start <= 3415 && _end > 3415 {
                        _buf[(3415 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3420 && _end > 3416 {
                    let _value = self.read_id_id_mmfr2()?.to_ne_bytes();
                    if _start <= 3416 && _end > 3416 {
                        _buf[(3416 - _start) as usize] = _value[0];
                    }
                    if _start <= 3417 && _end > 3417 {
                        _buf[(3417 - _start) as usize] = _value[1];
                    }
                    if _start <= 3418 && _end > 3418 {
                        _buf[(3418 - _start) as usize] = _value[2];
                    }
                    if _start <= 3419 && _end > 3419 {
                        _buf[(3419 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3424 && _end > 3420 {
                    let _value = self
                        .0
                        .lock()
                        .unwrap()
                        .read_id_id_mmfr3()?
                        .to_ne_bytes();
                    if _start <= 3420 && _end > 3420 {
                        _buf[(3420 - _start) as usize] = _value[0];
                    }
                    if _start <= 3421 && _end > 3421 {
                        _buf[(3421 - _start) as usize] = _value[1];
                    }
                    if _start <= 3422 && _end > 3422 {
                        _buf[(3422 - _start) as usize] = _value[2];
                    }
                    if _start <= 3423 && _end > 3423 {
                        _buf[(3423 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3428 && _end > 3424 {
                    let _value = self.read_id_id_isar0()?.to_ne_bytes();
                    if _start <= 3424 && _end > 3424 {
                        _buf[(3424 - _start) as usize] = _value[0];
                    }
                    if _start <= 3425 && _end > 3425 {
                        _buf[(3425 - _start) as usize] = _value[1];
                    }
                    if _start <= 3426 && _end > 3426 {
                        _buf[(3426 - _start) as usize] = _value[2];
                    }
                    if _start <= 3427 && _end > 3427 {
                        _buf[(3427 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3432 && _end > 3428 {
                    let _value = self.read_id_id_isar1()?.to_ne_bytes();
                    if _start <= 3428 && _end > 3428 {
                        _buf[(3428 - _start) as usize] = _value[0];
                    }
                    if _start <= 3429 && _end > 3429 {
                        _buf[(3429 - _start) as usize] = _value[1];
                    }
                    if _start <= 3430 && _end > 3430 {
                        _buf[(3430 - _start) as usize] = _value[2];
                    }
                    if _start <= 3431 && _end > 3431 {
                        _buf[(3431 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3436 && _end > 3432 {
                    let _value = self.read_id_id_isar2()?.to_ne_bytes();
                    if _start <= 3432 && _end > 3432 {
                        _buf[(3432 - _start) as usize] = _value[0];
                    }
                    if _start <= 3433 && _end > 3433 {
                        _buf[(3433 - _start) as usize] = _value[1];
                    }
                    if _start <= 3434 && _end > 3434 {
                        _buf[(3434 - _start) as usize] = _value[2];
                    }
                    if _start <= 3435 && _end > 3435 {
                        _buf[(3435 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3440 && _end > 3436 {
                    let _value = self.read_id_id_isar3()?.to_ne_bytes();
                    if _start <= 3436 && _end > 3436 {
                        _buf[(3436 - _start) as usize] = _value[0];
                    }
                    if _start <= 3437 && _end > 3437 {
                        _buf[(3437 - _start) as usize] = _value[1];
                    }
                    if _start <= 3438 && _end > 3438 {
                        _buf[(3438 - _start) as usize] = _value[2];
                    }
                    if _start <= 3439 && _end > 3439 {
                        _buf[(3439 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3444 && _end > 3440 {
                    let _value = self.read_id_id_isar4()?.to_ne_bytes();
                    if _start <= 3440 && _end > 3440 {
                        _buf[(3440 - _start) as usize] = _value[0];
                    }
                    if _start <= 3441 && _end > 3441 {
                        _buf[(3441 - _start) as usize] = _value[1];
                    }
                    if _start <= 3442 && _end > 3442 {
                        _buf[(3442 - _start) as usize] = _value[2];
                    }
                    if _start <= 3443 && _end > 3443 {
                        _buf[(3443 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3464..=3467, 3465..=3468) => {
                if _start < 3468 && _end > 3464 {
                    let _value = self.read_control_cpacr()?.to_ne_bytes();
                    if _start <= 3464 && _end > 3464 {
                        _buf[(3464 - _start) as usize] = _value[0];
                    }
                    if _start <= 3465 && _end > 3465 {
                        _buf[(3465 - _start) as usize] = _value[1];
                    }
                    if _start <= 3466 && _end > 3466 {
                        _buf[(3466 - _start) as usize] = _value[2];
                    }
                    if _start <= 3467 && _end > 3467 {
                        _buf[(3467 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3472..=3515, 3473..=3516) => {
                if _start < 3476 && _end > 3472 {
                    let _value = self.read_mpu_mpu_type()?.to_ne_bytes();
                    if _start <= 3472 && _end > 3472 {
                        _buf[(3472 - _start) as usize] = _value[0];
                    }
                    if _start <= 3473 && _end > 3473 {
                        _buf[(3473 - _start) as usize] = _value[1];
                    }
                    if _start <= 3474 && _end > 3474 {
                        _buf[(3474 - _start) as usize] = _value[2];
                    }
                    if _start <= 3475 && _end > 3475 {
                        _buf[(3475 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3480 && _end > 3476 {
                    let _value = self.read_mpu_mpu_ctrl()?.to_ne_bytes();
                    if _start <= 3476 && _end > 3476 {
                        _buf[(3476 - _start) as usize] = _value[0];
                    }
                    if _start <= 3477 && _end > 3477 {
                        _buf[(3477 - _start) as usize] = _value[1];
                    }
                    if _start <= 3478 && _end > 3478 {
                        _buf[(3478 - _start) as usize] = _value[2];
                    }
                    if _start <= 3479 && _end > 3479 {
                        _buf[(3479 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3484 && _end > 3480 {
                    let _value = self.read_mpu_mpu_rnr()?.to_ne_bytes();
                    if _start <= 3480 && _end > 3480 {
                        _buf[(3480 - _start) as usize] = _value[0];
                    }
                    if _start <= 3481 && _end > 3481 {
                        _buf[(3481 - _start) as usize] = _value[1];
                    }
                    if _start <= 3482 && _end > 3482 {
                        _buf[(3482 - _start) as usize] = _value[2];
                    }
                    if _start <= 3483 && _end > 3483 {
                        _buf[(3483 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3488 && _end > 3484 {
                    let _value = self.read_mpu_mpu_rbar()?.to_ne_bytes();
                    if _start <= 3484 && _end > 3484 {
                        _buf[(3484 - _start) as usize] = _value[0];
                    }
                    if _start <= 3485 && _end > 3485 {
                        _buf[(3485 - _start) as usize] = _value[1];
                    }
                    if _start <= 3486 && _end > 3486 {
                        _buf[(3486 - _start) as usize] = _value[2];
                    }
                    if _start <= 3487 && _end > 3487 {
                        _buf[(3487 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3492 && _end > 3488 {
                    let _value = self.read_mpu_mpu_rasr()?.to_ne_bytes();
                    if _start <= 3488 && _end > 3488 {
                        _buf[(3488 - _start) as usize] = _value[0];
                    }
                    if _start <= 3489 && _end > 3489 {
                        _buf[(3489 - _start) as usize] = _value[1];
                    }
                    if _start <= 3490 && _end > 3490 {
                        _buf[(3490 - _start) as usize] = _value[2];
                    }
                    if _start <= 3491 && _end > 3491 {
                        _buf[(3491 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3496 && _end > 3492 {
                    let _value = self.read_mpu_mpu_rbar_a1()?.to_ne_bytes();
                    if _start <= 3492 && _end > 3492 {
                        _buf[(3492 - _start) as usize] = _value[0];
                    }
                    if _start <= 3493 && _end > 3493 {
                        _buf[(3493 - _start) as usize] = _value[1];
                    }
                    if _start <= 3494 && _end > 3494 {
                        _buf[(3494 - _start) as usize] = _value[2];
                    }
                    if _start <= 3495 && _end > 3495 {
                        _buf[(3495 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3500 && _end > 3496 {
                    let _value = self.read_mpu_mpu_rasr_a1()?.to_ne_bytes();
                    if _start <= 3496 && _end > 3496 {
                        _buf[(3496 - _start) as usize] = _value[0];
                    }
                    if _start <= 3497 && _end > 3497 {
                        _buf[(3497 - _start) as usize] = _value[1];
                    }
                    if _start <= 3498 && _end > 3498 {
                        _buf[(3498 - _start) as usize] = _value[2];
                    }
                    if _start <= 3499 && _end > 3499 {
                        _buf[(3499 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3504 && _end > 3500 {
                    let _value = self.read_mpu_mpu_rbar_a2()?.to_ne_bytes();
                    if _start <= 3500 && _end > 3500 {
                        _buf[(3500 - _start) as usize] = _value[0];
                    }
                    if _start <= 3501 && _end > 3501 {
                        _buf[(3501 - _start) as usize] = _value[1];
                    }
                    if _start <= 3502 && _end > 3502 {
                        _buf[(3502 - _start) as usize] = _value[2];
                    }
                    if _start <= 3503 && _end > 3503 {
                        _buf[(3503 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3508 && _end > 3504 {
                    let _value = self.read_mpu_mpu_rasr_a2()?.to_ne_bytes();
                    if _start <= 3504 && _end > 3504 {
                        _buf[(3504 - _start) as usize] = _value[0];
                    }
                    if _start <= 3505 && _end > 3505 {
                        _buf[(3505 - _start) as usize] = _value[1];
                    }
                    if _start <= 3506 && _end > 3506 {
                        _buf[(3506 - _start) as usize] = _value[2];
                    }
                    if _start <= 3507 && _end > 3507 {
                        _buf[(3507 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3512 && _end > 3508 {
                    let _value = self.read_mpu_mpu_rbar_a3()?.to_ne_bytes();
                    if _start <= 3508 && _end > 3508 {
                        _buf[(3508 - _start) as usize] = _value[0];
                    }
                    if _start <= 3509 && _end > 3509 {
                        _buf[(3509 - _start) as usize] = _value[1];
                    }
                    if _start <= 3510 && _end > 3510 {
                        _buf[(3510 - _start) as usize] = _value[2];
                    }
                    if _start <= 3511 && _end > 3511 {
                        _buf[(3511 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3516 && _end > 3512 {
                    let _value = self.read_mpu_mpu_rasr_a3()?.to_ne_bytes();
                    if _start <= 3512 && _end > 3512 {
                        _buf[(3512 - _start) as usize] = _value[0];
                    }
                    if _start <= 3513 && _end > 3513 {
                        _buf[(3513 - _start) as usize] = _value[1];
                    }
                    if _start <= 3514 && _end > 3514 {
                        _buf[(3514 - _start) as usize] = _value[2];
                    }
                    if _start <= 3515 && _end > 3515 {
                        _buf[(3515 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3580..=3583, 3581..=3584) => {
                if _start < 3584 && _end > 3580 {
                    let _value = self.read_control_demcr()?.to_ne_bytes();
                    if _start <= 3580 && _end > 3580 {
                        _buf[(3580 - _start) as usize] = _value[0];
                    }
                    if _start <= 3581 && _end > 3581 {
                        _buf[(3581 - _start) as usize] = _value[1];
                    }
                    if _start <= 3582 && _end > 3582 {
                        _buf[(3582 - _start) as usize] = _value[2];
                    }
                    if _start <= 3583 && _end > 3583 {
                        _buf[(3583 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            (3840..=3843, 3841..=3844) => {
                if _start < 3844 && _end > 3840 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (3892..=3911, 3893..=3912) => {
                if _start < 3896 && _end > 3892 {
                    let _value = self.read_fpe_fpccr()?.to_ne_bytes();
                    if _start <= 3892 && _end > 3892 {
                        _buf[(3892 - _start) as usize] = _value[0];
                    }
                    if _start <= 3893 && _end > 3893 {
                        _buf[(3893 - _start) as usize] = _value[1];
                    }
                    if _start <= 3894 && _end > 3894 {
                        _buf[(3894 - _start) as usize] = _value[2];
                    }
                    if _start <= 3895 && _end > 3895 {
                        _buf[(3895 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3900 && _end > 3896 {
                    let _value =
                        self.0.lock().unwrap().read_fpe_fpcar()?.to_ne_bytes();
                    if _start <= 3896 && _end > 3896 {
                        _buf[(3896 - _start) as usize] = _value[0];
                    }
                    if _start <= 3897 && _end > 3897 {
                        _buf[(3897 - _start) as usize] = _value[1];
                    }
                    if _start <= 3898 && _end > 3898 {
                        _buf[(3898 - _start) as usize] = _value[2];
                    }
                    if _start <= 3899 && _end > 3899 {
                        _buf[(3899 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3904 && _end > 3900 {
                    let _value = self.read_fpe_fpdscr()?.to_ne_bytes();
                    if _start <= 3900 && _end > 3900 {
                        _buf[(3900 - _start) as usize] = _value[0];
                    }
                    if _start <= 3901 && _end > 3901 {
                        _buf[(3901 - _start) as usize] = _value[1];
                    }
                    if _start <= 3902 && _end > 3902 {
                        _buf[(3902 - _start) as usize] = _value[2];
                    }
                    if _start <= 3903 && _end > 3903 {
                        _buf[(3903 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3908 && _end > 3904 {
                    let _value = self.read_fpe_mvfr0()?.to_ne_bytes();
                    if _start <= 3904 && _end > 3904 {
                        _buf[(3904 - _start) as usize] = _value[0];
                    }
                    if _start <= 3905 && _end > 3905 {
                        _buf[(3905 - _start) as usize] = _value[1];
                    }
                    if _start <= 3906 && _end > 3906 {
                        _buf[(3906 - _start) as usize] = _value[2];
                    }
                    if _start <= 3907 && _end > 3907 {
                        _buf[(3907 - _start) as usize] = _value[3];
                    }
                }
                if _start < 3912 && _end > 3908 {
                    let _value = self.read_fpe_mvfr1()?.to_ne_bytes();
                    if _start <= 3908 && _end > 3908 {
                        _buf[(3908 - _start) as usize] = _value[0];
                    }
                    if _start <= 3909 && _end > 3909 {
                        _buf[(3909 - _start) as usize] = _value[1];
                    }
                    if _start <= 3910 && _end > 3910 {
                        _buf[(3910 - _start) as usize] = _value[2];
                    }
                    if _start <= 3911 && _end > 3911 {
                        _buf[(3911 - _start) as usize] = _value[3];
                    }
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _start = _addr - 3758153728;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=11, 5..=12) => {
                if _start < 8 && _end > 4 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 12 && _end > 8 {
                    let offset = _start.saturating_sub(8);
                    let start = 8u64.saturating_sub(_start) as usize;
                    let end = ((_end - 8) - offset) as usize;
                    self.write_control_actlr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (16..=31, 17..=32) => {
                if _start < 20 && _end > 16 {
                    let offset = _start.saturating_sub(16);
                    let start = 16u64.saturating_sub(_start) as usize;
                    let end = ((_end - 16) - offset) as usize;
                    self.write_systick_stcsr(offset, &_buf[start..end])?;
                }
                if _start < 24 && _end > 20 {
                    let offset = _start.saturating_sub(20);
                    let start = 20u64.saturating_sub(_start) as usize;
                    let end = ((_end - 20) - offset) as usize;
                    self.write_systick_strvr(offset, &_buf[start..end])?;
                }
                if _start < 28 && _end > 24 {
                    let offset = _start.saturating_sub(24);
                    let start = 24u64.saturating_sub(_start) as usize;
                    let end = ((_end - 24) - offset) as usize;
                    self.write_systick_stcvr(offset, &_buf[start..end])?;
                }
                if _start < 32 && _end > 28 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    assert!(
                        _start <= 256 && _end >= 260u64,
                        "partial write for NVIC NVIC_ISER0 not implemented",
                    );
                    let start = _start.saturating_sub(256) as usize;
                    let end =
                        (_end.saturating_sub(256) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 264 && _end > 260 {
                    assert!(
                        _start <= 260 && _end >= 264u64,
                        "partial write for NVIC NVIC_ISER1 not implemented",
                    );
                    let start = _start.saturating_sub(260) as usize;
                    let end =
                        (_end.saturating_sub(260) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 268 && _end > 264 {
                    assert!(
                        _start <= 264 && _end >= 268u64,
                        "partial write for NVIC NVIC_ISER2 not implemented",
                    );
                    let start = _start.saturating_sub(264) as usize;
                    let end =
                        (_end.saturating_sub(264) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 272 && _end > 268 {
                    assert!(
                        _start <= 268 && _end >= 272u64,
                        "partial write for NVIC NVIC_ISER3 not implemented",
                    );
                    let start = _start.saturating_sub(268) as usize;
                    let end =
                        (_end.saturating_sub(268) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 276 && _end > 272 {
                    assert!(
                        _start <= 272 && _end >= 276u64,
                        "partial write for NVIC NVIC_ISER4 not implemented",
                    );
                    let start = _start.saturating_sub(272) as usize;
                    let end =
                        (_end.saturating_sub(272) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 280 && _end > 276 {
                    assert!(
                        _start <= 276 && _end >= 280u64,
                        "partial write for NVIC NVIC_ISER5 not implemented",
                    );
                    let start = _start.saturating_sub(276) as usize;
                    let end =
                        (_end.saturating_sub(276) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 284 && _end > 280 {
                    assert!(
                        _start <= 280 && _end >= 284u64,
                        "partial write for NVIC NVIC_ISER6 not implemented",
                    );
                    let start = _start.saturating_sub(280) as usize;
                    let end =
                        (_end.saturating_sub(280) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 288 && _end > 284 {
                    assert!(
                        _start <= 284 && _end >= 288u64,
                        "partial write for NVIC NVIC_ISER7 not implemented",
                    );
                    let start = _start.saturating_sub(284) as usize;
                    let end =
                        (_end.saturating_sub(284) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iser7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (384..=415, 385..=416) => {
                if _start < 388 && _end > 384 {
                    assert!(
                        _start <= 384 && _end >= 388u64,
                        "partial write for NVIC NVIC_ICER0 not implemented",
                    );
                    let start = _start.saturating_sub(384) as usize;
                    let end =
                        (_end.saturating_sub(384) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 392 && _end > 388 {
                    assert!(
                        _start <= 388 && _end >= 392u64,
                        "partial write for NVIC NVIC_ICER1 not implemented",
                    );
                    let start = _start.saturating_sub(388) as usize;
                    let end =
                        (_end.saturating_sub(388) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 396 && _end > 392 {
                    assert!(
                        _start <= 392 && _end >= 396u64,
                        "partial write for NVIC NVIC_ICER2 not implemented",
                    );
                    let start = _start.saturating_sub(392) as usize;
                    let end =
                        (_end.saturating_sub(392) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 400 && _end > 396 {
                    assert!(
                        _start <= 396 && _end >= 400u64,
                        "partial write for NVIC NVIC_ICER3 not implemented",
                    );
                    let start = _start.saturating_sub(396) as usize;
                    let end =
                        (_end.saturating_sub(396) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 404 && _end > 400 {
                    assert!(
                        _start <= 400 && _end >= 404u64,
                        "partial write for NVIC NVIC_ICER4 not implemented",
                    );
                    let start = _start.saturating_sub(400) as usize;
                    let end =
                        (_end.saturating_sub(400) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 408 && _end > 404 {
                    assert!(
                        _start <= 404 && _end >= 408u64,
                        "partial write for NVIC NVIC_ICER5 not implemented",
                    );
                    let start = _start.saturating_sub(404) as usize;
                    let end =
                        (_end.saturating_sub(404) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 412 && _end > 408 {
                    assert!(
                        _start <= 408 && _end >= 412u64,
                        "partial write for NVIC NVIC_ICER6 not implemented",
                    );
                    let start = _start.saturating_sub(408) as usize;
                    let end =
                        (_end.saturating_sub(408) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 416 && _end > 412 {
                    assert!(
                        _start <= 412 && _end >= 416u64,
                        "partial write for NVIC NVIC_ICER7 not implemented",
                    );
                    let start = _start.saturating_sub(412) as usize;
                    let end =
                        (_end.saturating_sub(412) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icer7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (512..=543, 513..=544) => {
                if _start < 516 && _end > 512 {
                    assert!(
                        _start <= 512 && _end >= 516u64,
                        "partial write for NVIC NVIC_ISPR0 not implemented",
                    );
                    let start = _start.saturating_sub(512) as usize;
                    let end =
                        (_end.saturating_sub(512) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 520 && _end > 516 {
                    assert!(
                        _start <= 516 && _end >= 520u64,
                        "partial write for NVIC NVIC_ISPR1 not implemented",
                    );
                    let start = _start.saturating_sub(516) as usize;
                    let end =
                        (_end.saturating_sub(516) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 524 && _end > 520 {
                    assert!(
                        _start <= 520 && _end >= 524u64,
                        "partial write for NVIC NVIC_ISPR2 not implemented",
                    );
                    let start = _start.saturating_sub(520) as usize;
                    let end =
                        (_end.saturating_sub(520) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 528 && _end > 524 {
                    assert!(
                        _start <= 524 && _end >= 528u64,
                        "partial write for NVIC NVIC_ISPR3 not implemented",
                    );
                    let start = _start.saturating_sub(524) as usize;
                    let end =
                        (_end.saturating_sub(524) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 532 && _end > 528 {
                    assert!(
                        _start <= 528 && _end >= 532u64,
                        "partial write for NVIC NVIC_ISPR4 not implemented",
                    );
                    let start = _start.saturating_sub(528) as usize;
                    let end =
                        (_end.saturating_sub(528) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 536 && _end > 532 {
                    assert!(
                        _start <= 532 && _end >= 536u64,
                        "partial write for NVIC NVIC_ISPR5 not implemented",
                    );
                    let start = _start.saturating_sub(532) as usize;
                    let end =
                        (_end.saturating_sub(532) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 540 && _end > 536 {
                    assert!(
                        _start <= 536 && _end >= 540u64,
                        "partial write for NVIC NVIC_ISPR6 not implemented",
                    );
                    let start = _start.saturating_sub(536) as usize;
                    let end =
                        (_end.saturating_sub(536) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 544 && _end > 540 {
                    assert!(
                        _start <= 540 && _end >= 544u64,
                        "partial write for NVIC NVIC_ISPR7 not implemented",
                    );
                    let start = _start.saturating_sub(540) as usize;
                    let end =
                        (_end.saturating_sub(540) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_ispr7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (640..=671, 641..=672) => {
                if _start < 644 && _end > 640 {
                    assert!(
                        _start <= 640 && _end >= 644u64,
                        "partial write for NVIC NVIC_ICPR0 not implemented",
                    );
                    let start = _start.saturating_sub(640) as usize;
                    let end =
                        (_end.saturating_sub(640) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 648 && _end > 644 {
                    assert!(
                        _start <= 644 && _end >= 648u64,
                        "partial write for NVIC NVIC_ICPR1 not implemented",
                    );
                    let start = _start.saturating_sub(644) as usize;
                    let end =
                        (_end.saturating_sub(644) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 652 && _end > 648 {
                    assert!(
                        _start <= 648 && _end >= 652u64,
                        "partial write for NVIC NVIC_ICPR2 not implemented",
                    );
                    let start = _start.saturating_sub(648) as usize;
                    let end =
                        (_end.saturating_sub(648) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 656 && _end > 652 {
                    assert!(
                        _start <= 652 && _end >= 656u64,
                        "partial write for NVIC NVIC_ICPR3 not implemented",
                    );
                    let start = _start.saturating_sub(652) as usize;
                    let end =
                        (_end.saturating_sub(652) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 660 && _end > 656 {
                    assert!(
                        _start <= 656 && _end >= 660u64,
                        "partial write for NVIC NVIC_ICPR4 not implemented",
                    );
                    let start = _start.saturating_sub(656) as usize;
                    let end =
                        (_end.saturating_sub(656) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 664 && _end > 660 {
                    assert!(
                        _start <= 660 && _end >= 664u64,
                        "partial write for NVIC NVIC_ICPR5 not implemented",
                    );
                    let start = _start.saturating_sub(660) as usize;
                    let end =
                        (_end.saturating_sub(660) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 668 && _end > 664 {
                    assert!(
                        _start <= 664 && _end >= 668u64,
                        "partial write for NVIC NVIC_ICPR6 not implemented",
                    );
                    let start = _start.saturating_sub(664) as usize;
                    let end =
                        (_end.saturating_sub(664) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 672 && _end > 668 {
                    assert!(
                        _start <= 668 && _end >= 672u64,
                        "partial write for NVIC NVIC_ICPR7 not implemented",
                    );
                    let start = _start.saturating_sub(668) as usize;
                    let end =
                        (_end.saturating_sub(668) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_icpr7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (768..=799, 769..=800) => {
                if _start < 772 && _end > 768 {
                    assert!(
                        _start <= 768 && _end >= 772u64,
                        "partial write for NVIC NVIC_IABR0 not implemented",
                    );
                    let start = _start.saturating_sub(768) as usize;
                    let end =
                        (_end.saturating_sub(768) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr0(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 776 && _end > 772 {
                    assert!(
                        _start <= 772 && _end >= 776u64,
                        "partial write for NVIC NVIC_IABR1 not implemented",
                    );
                    let start = _start.saturating_sub(772) as usize;
                    let end =
                        (_end.saturating_sub(772) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr1(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 780 && _end > 776 {
                    assert!(
                        _start <= 776 && _end >= 780u64,
                        "partial write for NVIC NVIC_IABR2 not implemented",
                    );
                    let start = _start.saturating_sub(776) as usize;
                    let end =
                        (_end.saturating_sub(776) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr2(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 784 && _end > 780 {
                    assert!(
                        _start <= 780 && _end >= 784u64,
                        "partial write for NVIC NVIC_IABR3 not implemented",
                    );
                    let start = _start.saturating_sub(780) as usize;
                    let end =
                        (_end.saturating_sub(780) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr3(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 788 && _end > 784 {
                    assert!(
                        _start <= 784 && _end >= 788u64,
                        "partial write for NVIC NVIC_IABR4 not implemented",
                    );
                    let start = _start.saturating_sub(784) as usize;
                    let end =
                        (_end.saturating_sub(784) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr4(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 792 && _end > 788 {
                    assert!(
                        _start <= 788 && _end >= 792u64,
                        "partial write for NVIC NVIC_IABR5 not implemented",
                    );
                    let start = _start.saturating_sub(788) as usize;
                    let end =
                        (_end.saturating_sub(788) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr5(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 796 && _end > 792 {
                    assert!(
                        _start <= 792 && _end >= 796u64,
                        "partial write for NVIC NVIC_IABR6 not implemented",
                    );
                    let start = _start.saturating_sub(792) as usize;
                    let end =
                        (_end.saturating_sub(792) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr6(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 800 && _end > 796 {
                    assert!(
                        _start <= 796 && _end >= 800u64,
                        "partial write for NVIC NVIC_IABR7 not implemented",
                    );
                    let start = _start.saturating_sub(796) as usize;
                    let end =
                        (_end.saturating_sub(796) as usize).min(start + 4);
                    self.0.lock().unwrap().write_nvic_nvic_iabr7(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                Ok(())
            }
            (1024..=1263, 1025..=1264) => {
                if _start < 1028 && _end > 1024 {
                    let offset = _start.saturating_sub(1024);
                    let start = 1024u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1024) - offset) as usize;
                    self.write_nvic_nvic_ipr0(offset, &_buf[start..end])?;
                }
                if _start < 1032 && _end > 1028 {
                    let offset = _start.saturating_sub(1028);
                    let start = 1028u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1028) - offset) as usize;
                    self.write_nvic_nvic_ipr1(offset, &_buf[start..end])?;
                }
                if _start < 1036 && _end > 1032 {
                    let offset = _start.saturating_sub(1032);
                    let start = 1032u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1032) - offset) as usize;
                    self.write_nvic_nvic_ipr2(offset, &_buf[start..end])?;
                }
                if _start < 1040 && _end > 1036 {
                    let offset = _start.saturating_sub(1036);
                    let start = 1036u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1036) - offset) as usize;
                    self.write_nvic_nvic_ipr3(offset, &_buf[start..end])?;
                }
                if _start < 1044 && _end > 1040 {
                    let offset = _start.saturating_sub(1040);
                    let start = 1040u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1040) - offset) as usize;
                    self.write_nvic_nvic_ipr4(offset, &_buf[start..end])?;
                }
                if _start < 1048 && _end > 1044 {
                    let offset = _start.saturating_sub(1044);
                    let start = 1044u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1044) - offset) as usize;
                    self.write_nvic_nvic_ipr5(offset, &_buf[start..end])?;
                }
                if _start < 1052 && _end > 1048 {
                    let offset = _start.saturating_sub(1048);
                    let start = 1048u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1048) - offset) as usize;
                    self.write_nvic_nvic_ipr6(offset, &_buf[start..end])?;
                }
                if _start < 1056 && _end > 1052 {
                    let offset = _start.saturating_sub(1052);
                    let start = 1052u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1052) - offset) as usize;
                    self.write_nvic_nvic_ipr7(offset, &_buf[start..end])?;
                }
                if _start < 1060 && _end > 1056 {
                    let offset = _start.saturating_sub(1056);
                    let start = 1056u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1056) - offset) as usize;
                    self.write_nvic_nvic_ipr8(offset, &_buf[start..end])?;
                }
                if _start < 1064 && _end > 1060 {
                    let offset = _start.saturating_sub(1060);
                    let start = 1060u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1060) - offset) as usize;
                    self.write_nvic_nvic_ipr9(offset, &_buf[start..end])?;
                }
                if _start < 1068 && _end > 1064 {
                    let offset = _start.saturating_sub(1064);
                    let start = 1064u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1064) - offset) as usize;
                    self.write_nvic_nvic_ipr10(offset, &_buf[start..end])?;
                }
                if _start < 1072 && _end > 1068 {
                    let offset = _start.saturating_sub(1068);
                    let start = 1068u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1068) - offset) as usize;
                    self.write_nvic_nvic_ipr11(offset, &_buf[start..end])?;
                }
                if _start < 1076 && _end > 1072 {
                    let offset = _start.saturating_sub(1072);
                    let start = 1072u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1072) - offset) as usize;
                    self.write_nvic_nvic_ipr12(offset, &_buf[start..end])?;
                }
                if _start < 1080 && _end > 1076 {
                    let offset = _start.saturating_sub(1076);
                    let start = 1076u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1076) - offset) as usize;
                    self.write_nvic_nvic_ipr13(offset, &_buf[start..end])?;
                }
                if _start < 1084 && _end > 1080 {
                    let offset = _start.saturating_sub(1080);
                    let start = 1080u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1080) - offset) as usize;
                    self.write_nvic_nvic_ipr14(offset, &_buf[start..end])?;
                }
                if _start < 1088 && _end > 1084 {
                    let offset = _start.saturating_sub(1084);
                    let start = 1084u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1084) - offset) as usize;
                    self.write_nvic_nvic_ipr15(offset, &_buf[start..end])?;
                }
                if _start < 1092 && _end > 1088 {
                    let offset = _start.saturating_sub(1088);
                    let start = 1088u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1088) - offset) as usize;
                    self.write_nvic_nvic_ipr16(offset, &_buf[start..end])?;
                }
                if _start < 1096 && _end > 1092 {
                    let offset = _start.saturating_sub(1092);
                    let start = 1092u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1092) - offset) as usize;
                    self.write_nvic_nvic_ipr17(offset, &_buf[start..end])?;
                }
                if _start < 1100 && _end > 1096 {
                    let offset = _start.saturating_sub(1096);
                    let start = 1096u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1096) - offset) as usize;
                    self.write_nvic_nvic_ipr18(offset, &_buf[start..end])?;
                }
                if _start < 1104 && _end > 1100 {
                    let offset = _start.saturating_sub(1100);
                    let start = 1100u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1100) - offset) as usize;
                    self.write_nvic_nvic_ipr19(offset, &_buf[start..end])?;
                }
                if _start < 1108 && _end > 1104 {
                    let offset = _start.saturating_sub(1104);
                    let start = 1104u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1104) - offset) as usize;
                    self.write_nvic_nvic_ipr20(offset, &_buf[start..end])?;
                }
                if _start < 1112 && _end > 1108 {
                    let offset = _start.saturating_sub(1108);
                    let start = 1108u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1108) - offset) as usize;
                    self.write_nvic_nvic_ipr21(offset, &_buf[start..end])?;
                }
                if _start < 1116 && _end > 1112 {
                    let offset = _start.saturating_sub(1112);
                    let start = 1112u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1112) - offset) as usize;
                    self.write_nvic_nvic_ipr22(offset, &_buf[start..end])?;
                }
                if _start < 1120 && _end > 1116 {
                    let offset = _start.saturating_sub(1116);
                    let start = 1116u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1116) - offset) as usize;
                    self.write_nvic_nvic_ipr23(offset, &_buf[start..end])?;
                }
                if _start < 1124 && _end > 1120 {
                    let offset = _start.saturating_sub(1120);
                    let start = 1120u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1120) - offset) as usize;
                    self.write_nvic_nvic_ipr24(offset, &_buf[start..end])?;
                }
                if _start < 1128 && _end > 1124 {
                    let offset = _start.saturating_sub(1124);
                    let start = 1124u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1124) - offset) as usize;
                    self.write_nvic_nvic_ipr25(offset, &_buf[start..end])?;
                }
                if _start < 1132 && _end > 1128 {
                    let offset = _start.saturating_sub(1128);
                    let start = 1128u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1128) - offset) as usize;
                    self.write_nvic_nvic_ipr26(offset, &_buf[start..end])?;
                }
                if _start < 1136 && _end > 1132 {
                    let offset = _start.saturating_sub(1132);
                    let start = 1132u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1132) - offset) as usize;
                    self.write_nvic_nvic_ipr27(offset, &_buf[start..end])?;
                }
                if _start < 1140 && _end > 1136 {
                    let offset = _start.saturating_sub(1136);
                    let start = 1136u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1136) - offset) as usize;
                    self.write_nvic_nvic_ipr28(offset, &_buf[start..end])?;
                }
                if _start < 1144 && _end > 1140 {
                    let offset = _start.saturating_sub(1140);
                    let start = 1140u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1140) - offset) as usize;
                    self.write_nvic_nvic_ipr29(offset, &_buf[start..end])?;
                }
                if _start < 1148 && _end > 1144 {
                    let offset = _start.saturating_sub(1144);
                    let start = 1144u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1144) - offset) as usize;
                    self.write_nvic_nvic_ipr30(offset, &_buf[start..end])?;
                }
                if _start < 1152 && _end > 1148 {
                    let offset = _start.saturating_sub(1148);
                    let start = 1148u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1148) - offset) as usize;
                    self.write_nvic_nvic_ipr31(offset, &_buf[start..end])?;
                }
                if _start < 1156 && _end > 1152 {
                    let offset = _start.saturating_sub(1152);
                    let start = 1152u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1152) - offset) as usize;
                    self.write_nvic_nvic_ipr32(offset, &_buf[start..end])?;
                }
                if _start < 1160 && _end > 1156 {
                    let offset = _start.saturating_sub(1156);
                    let start = 1156u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1156) - offset) as usize;
                    self.write_nvic_nvic_ipr33(offset, &_buf[start..end])?;
                }
                if _start < 1164 && _end > 1160 {
                    let offset = _start.saturating_sub(1160);
                    let start = 1160u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1160) - offset) as usize;
                    self.write_nvic_nvic_ipr34(offset, &_buf[start..end])?;
                }
                if _start < 1168 && _end > 1164 {
                    let offset = _start.saturating_sub(1164);
                    let start = 1164u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1164) - offset) as usize;
                    self.write_nvic_nvic_ipr35(offset, &_buf[start..end])?;
                }
                if _start < 1172 && _end > 1168 {
                    let offset = _start.saturating_sub(1168);
                    let start = 1168u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1168) - offset) as usize;
                    self.write_nvic_nvic_ipr36(offset, &_buf[start..end])?;
                }
                if _start < 1176 && _end > 1172 {
                    let offset = _start.saturating_sub(1172);
                    let start = 1172u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1172) - offset) as usize;
                    self.write_nvic_nvic_ipr37(offset, &_buf[start..end])?;
                }
                if _start < 1180 && _end > 1176 {
                    let offset = _start.saturating_sub(1176);
                    let start = 1176u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1176) - offset) as usize;
                    self.write_nvic_nvic_ipr38(offset, &_buf[start..end])?;
                }
                if _start < 1184 && _end > 1180 {
                    let offset = _start.saturating_sub(1180);
                    let start = 1180u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1180) - offset) as usize;
                    self.write_nvic_nvic_ipr39(offset, &_buf[start..end])?;
                }
                if _start < 1188 && _end > 1184 {
                    let offset = _start.saturating_sub(1184);
                    let start = 1184u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1184) - offset) as usize;
                    self.write_nvic_nvic_ipr40(offset, &_buf[start..end])?;
                }
                if _start < 1192 && _end > 1188 {
                    let offset = _start.saturating_sub(1188);
                    let start = 1188u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1188) - offset) as usize;
                    self.write_nvic_nvic_ipr41(offset, &_buf[start..end])?;
                }
                if _start < 1196 && _end > 1192 {
                    let offset = _start.saturating_sub(1192);
                    let start = 1192u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1192) - offset) as usize;
                    self.write_nvic_nvic_ipr42(offset, &_buf[start..end])?;
                }
                if _start < 1200 && _end > 1196 {
                    let offset = _start.saturating_sub(1196);
                    let start = 1196u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1196) - offset) as usize;
                    self.write_nvic_nvic_ipr43(offset, &_buf[start..end])?;
                }
                if _start < 1204 && _end > 1200 {
                    let offset = _start.saturating_sub(1200);
                    let start = 1200u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1200) - offset) as usize;
                    self.write_nvic_nvic_ipr44(offset, &_buf[start..end])?;
                }
                if _start < 1208 && _end > 1204 {
                    let offset = _start.saturating_sub(1204);
                    let start = 1204u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1204) - offset) as usize;
                    self.write_nvic_nvic_ipr45(offset, &_buf[start..end])?;
                }
                if _start < 1212 && _end > 1208 {
                    let offset = _start.saturating_sub(1208);
                    let start = 1208u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1208) - offset) as usize;
                    self.write_nvic_nvic_ipr46(offset, &_buf[start..end])?;
                }
                if _start < 1216 && _end > 1212 {
                    let offset = _start.saturating_sub(1212);
                    let start = 1212u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1212) - offset) as usize;
                    self.write_nvic_nvic_ipr47(offset, &_buf[start..end])?;
                }
                if _start < 1220 && _end > 1216 {
                    let offset = _start.saturating_sub(1216);
                    let start = 1216u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1216) - offset) as usize;
                    self.write_nvic_nvic_ipr48(offset, &_buf[start..end])?;
                }
                if _start < 1224 && _end > 1220 {
                    let offset = _start.saturating_sub(1220);
                    let start = 1220u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1220) - offset) as usize;
                    self.write_nvic_nvic_ipr49(offset, &_buf[start..end])?;
                }
                if _start < 1228 && _end > 1224 {
                    let offset = _start.saturating_sub(1224);
                    let start = 1224u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1224) - offset) as usize;
                    self.write_nvic_nvic_ipr50(offset, &_buf[start..end])?;
                }
                if _start < 1232 && _end > 1228 {
                    let offset = _start.saturating_sub(1228);
                    let start = 1228u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1228) - offset) as usize;
                    self.write_nvic_nvic_ipr51(offset, &_buf[start..end])?;
                }
                if _start < 1236 && _end > 1232 {
                    let offset = _start.saturating_sub(1232);
                    let start = 1232u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1232) - offset) as usize;
                    self.write_nvic_nvic_ipr52(offset, &_buf[start..end])?;
                }
                if _start < 1240 && _end > 1236 {
                    let offset = _start.saturating_sub(1236);
                    let start = 1236u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1236) - offset) as usize;
                    self.write_nvic_nvic_ipr53(offset, &_buf[start..end])?;
                }
                if _start < 1244 && _end > 1240 {
                    let offset = _start.saturating_sub(1240);
                    let start = 1240u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1240) - offset) as usize;
                    self.write_nvic_nvic_ipr54(offset, &_buf[start..end])?;
                }
                if _start < 1248 && _end > 1244 {
                    let offset = _start.saturating_sub(1244);
                    let start = 1244u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1244) - offset) as usize;
                    self.write_nvic_nvic_ipr55(offset, &_buf[start..end])?;
                }
                if _start < 1252 && _end > 1248 {
                    let offset = _start.saturating_sub(1248);
                    let start = 1248u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1248) - offset) as usize;
                    self.write_nvic_nvic_ipr56(offset, &_buf[start..end])?;
                }
                if _start < 1256 && _end > 1252 {
                    let offset = _start.saturating_sub(1252);
                    let start = 1252u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1252) - offset) as usize;
                    self.write_nvic_nvic_ipr57(offset, &_buf[start..end])?;
                }
                if _start < 1260 && _end > 1256 {
                    let offset = _start.saturating_sub(1256);
                    let start = 1256u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1256) - offset) as usize;
                    self.write_nvic_nvic_ipr58(offset, &_buf[start..end])?;
                }
                if _start < 1264 && _end > 1260 {
                    let offset = _start.saturating_sub(1260);
                    let start = 1260u64.saturating_sub(_start) as usize;
                    let end = ((_end - 1260) - offset) as usize;
                    self.write_nvic_nvic_ipr59(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (3328..=3443, 3329..=3444) => {
                if _start < 3332 && _end > 3328 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3336 && _end > 3332 {
                    let offset = _start.saturating_sub(3332);
                    let start = 3332u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3332) - offset) as usize;
                    self.write_control_icsr(offset, &_buf[start..end])?;
                }
                if _start < 3340 && _end > 3336 {
                    let offset = _start.saturating_sub(3336);
                    let start = 3336u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3336) - offset) as usize;
                    self.write_control_vtor(offset, &_buf[start..end])?;
                }
                if _start < 3344 && _end > 3340 {
                    let offset = _start.saturating_sub(3340);
                    let start = 3340u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3340) - offset) as usize;
                    self.write_control_aircr(offset, &_buf[start..end])?;
                }
                if _start < 3348 && _end > 3344 {
                    let offset = _start.saturating_sub(3344);
                    let start = 3344u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3344) - offset) as usize;
                    self.write_control_scr(offset, &_buf[start..end])?;
                }
                if _start < 3352 && _end > 3348 {
                    let offset = _start.saturating_sub(3348);
                    let start = 3348u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3348) - offset) as usize;
                    self.write_control_ccr(offset, &_buf[start..end])?;
                }
                if _start < 3356 && _end > 3352 {
                    let offset = _start.saturating_sub(3352);
                    let start = 3352u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3352) - offset) as usize;
                    self.write_control_shpr1(offset, &_buf[start..end])?;
                }
                if _start < 3360 && _end > 3356 {
                    let offset = _start.saturating_sub(3356);
                    let start = 3356u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3356) - offset) as usize;
                    self.write_control_shpr2(offset, &_buf[start..end])?;
                }
                if _start < 3364 && _end > 3360 {
                    let offset = _start.saturating_sub(3360);
                    let start = 3360u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3360) - offset) as usize;
                    self.write_control_shpr3(offset, &_buf[start..end])?;
                }
                if _start < 3368 && _end > 3364 {
                    let offset = _start.saturating_sub(3364);
                    let start = 3364u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3364) - offset) as usize;
                    self.write_control_shcsr(offset, &_buf[start..end])?;
                }
                if _start < 3372 && _end > 3368 {
                    let offset = _start.saturating_sub(3368);
                    let start = 3368u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3368) - offset) as usize;
                    self.write_control_cfsr(offset, &_buf[start..end])?;
                }
                if _start < 3376 && _end > 3372 {
                    let offset = _start.saturating_sub(3372);
                    let start = 3372u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3372) - offset) as usize;
                    self.write_control_hfsr(offset, &_buf[start..end])?;
                }
                if _start < 3380 && _end > 3376 {
                    let offset = _start.saturating_sub(3376);
                    let start = 3376u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3376) - offset) as usize;
                    self.write_control_dfsr(offset, &_buf[start..end])?;
                }
                if _start < 3384 && _end > 3380 {
                    assert!(
                        _start <= 3380 && _end >= 3384u64,
                        "partial write for Control MMFAR not implemented",
                    );
                    let start = _start.saturating_sub(3380) as usize;
                    let end =
                        (_end.saturating_sub(3380) as usize).min(start + 4);
                    self.0.lock().unwrap().write_control_mmfar(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 3388 && _end > 3384 {
                    assert!(
                        _start <= 3384 && _end >= 3388u64,
                        "partial write for Control BFAR not implemented",
                    );
                    let start = _start.saturating_sub(3384) as usize;
                    let end =
                        (_end.saturating_sub(3384) as usize).min(start + 4);
                    self.0.lock().unwrap().write_control_bfar(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 3392 && _end > 3388 {
                    assert!(
                        _start <= 3388 && _end >= 3392u64,
                        "partial write for Control AFSR not implemented",
                    );
                    let start = _start.saturating_sub(3388) as usize;
                    let end =
                        (_end.saturating_sub(3388) as usize).min(start + 4);
                    self.0.lock().unwrap().write_control_afsr(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 3396 && _end > 3392 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3400 && _end > 3396 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3404 && _end > 3400 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3408 && _end > 3404 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3412 && _end > 3408 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3416 && _end > 3412 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3420 && _end > 3416 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3424 && _end > 3420 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3428 && _end > 3424 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3432 && _end > 3428 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3436 && _end > 3432 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3440 && _end > 3436 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3444 && _end > 3440 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (3464..=3467, 3465..=3468) => {
                if _start < 3468 && _end > 3464 {
                    let offset = _start.saturating_sub(3464);
                    let start = 3464u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3464) - offset) as usize;
                    self.write_control_cpacr(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (3472..=3515, 3473..=3516) => {
                if _start < 3476 && _end > 3472 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3480 && _end > 3476 {
                    let offset = _start.saturating_sub(3476);
                    let start = 3476u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3476) - offset) as usize;
                    self.write_mpu_mpu_ctrl(offset, &_buf[start..end])?;
                }
                if _start < 3484 && _end > 3480 {
                    let offset = _start.saturating_sub(3480);
                    let start = 3480u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3480) - offset) as usize;
                    self.write_mpu_mpu_rnr(offset, &_buf[start..end])?;
                }
                if _start < 3488 && _end > 3484 {
                    let offset = _start.saturating_sub(3484);
                    let start = 3484u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3484) - offset) as usize;
                    self.write_mpu_mpu_rbar(offset, &_buf[start..end])?;
                }
                if _start < 3492 && _end > 3488 {
                    let offset = _start.saturating_sub(3488);
                    let start = 3488u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3488) - offset) as usize;
                    self.write_mpu_mpu_rasr(offset, &_buf[start..end])?;
                }
                if _start < 3496 && _end > 3492 {
                    let offset = _start.saturating_sub(3492);
                    let start = 3492u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3492) - offset) as usize;
                    self.write_mpu_mpu_rbar_a1(offset, &_buf[start..end])?;
                }
                if _start < 3500 && _end > 3496 {
                    let offset = _start.saturating_sub(3496);
                    let start = 3496u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3496) - offset) as usize;
                    self.write_mpu_mpu_rasr_a1(offset, &_buf[start..end])?;
                }
                if _start < 3504 && _end > 3500 {
                    let offset = _start.saturating_sub(3500);
                    let start = 3500u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3500) - offset) as usize;
                    self.write_mpu_mpu_rbar_a2(offset, &_buf[start..end])?;
                }
                if _start < 3508 && _end > 3504 {
                    let offset = _start.saturating_sub(3504);
                    let start = 3504u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3504) - offset) as usize;
                    self.write_mpu_mpu_rasr_a2(offset, &_buf[start..end])?;
                }
                if _start < 3512 && _end > 3508 {
                    let offset = _start.saturating_sub(3508);
                    let start = 3508u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3508) - offset) as usize;
                    self.write_mpu_mpu_rbar_a3(offset, &_buf[start..end])?;
                }
                if _start < 3516 && _end > 3512 {
                    let offset = _start.saturating_sub(3512);
                    let start = 3512u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3512) - offset) as usize;
                    self.write_mpu_mpu_rasr_a3(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (3580..=3583, 3581..=3584) => {
                if _start < 3584 && _end > 3580 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            (3840..=3843, 3841..=3844) => {
                if _start < 3844 && _end > 3840 {
                    let offset = _start.saturating_sub(3840);
                    let start = 3840u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3840) - offset) as usize;
                    self.write_control_stir(offset, &_buf[start..end])?;
                }
                Ok(())
            }
            (3892..=3911, 3893..=3912) => {
                if _start < 3896 && _end > 3892 {
                    let offset = _start.saturating_sub(3892);
                    let start = 3892u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3892) - offset) as usize;
                    self.write_fpe_fpccr(offset, &_buf[start..end])?;
                }
                if _start < 3900 && _end > 3896 {
                    assert!(
                        _start <= 3896 && _end >= 3900u64,
                        "partial write for FPE FPCAR not implemented",
                    );
                    let start = _start.saturating_sub(3896) as usize;
                    let end =
                        (_end.saturating_sub(3896) as usize).min(start + 4);
                    self.0.lock().unwrap().write_fpe_fpcar(
                        u32::from_ne_bytes(
                            _buf[start..end].try_into().unwrap(),
                        ),
                    )?;
                }
                if _start < 3904 && _end > 3900 {
                    let offset = _start.saturating_sub(3900);
                    let start = 3900u64.saturating_sub(_start) as usize;
                    let end = ((_end - 3900) - offset) as usize;
                    self.write_fpe_fpdscr(offset, &_buf[start..end])?;
                }
                if _start < 3908 && _end > 3904 {
                    return Err(MemError::ReadViolation);
                }
                if _start < 3912 && _end > 3908 {
                    return Err(MemError::ReadViolation);
                }
                Ok(())
            }
            _ => return Err(MemError::Unmapped),
        }
    }
}
impl PeripheralPage0xE000E000 {
    fn read_nvic_ictr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_ictr_intlinesnum()?)
                << 0u32;
        Ok(_value)
    }
    fn read_control_actlr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_dismcycint()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_disdefwbuf()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_disfold()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_disfpca()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_actlr_disoofp()?)
                << 9u32;
        Ok(_value)
    }
    fn write_control_actlr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_dismcycint((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_disdefwbuf((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_disfold((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_disfpca((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_actlr_disoofp((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_systick_stcsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcsr_enable()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcsr_tickint()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcsr_clksource()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcsr_countflag()?)
                << 16u32;
        Ok(_value)
    }
    fn write_systick_stcsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_systick_stcsr_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_systick_stcsr_tickint((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_systick_stcsr_clksource((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_systick_stcsr_countflag((_value[_i] >> 0) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_systick_strvr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_strvr_reload()?)
                << 0u32;
        Ok(_value)
    }
    fn write_systick_strvr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_systick_strvr_reload(_value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_systick_stcvr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_systick_stcvr_current()?)
                << 0u32;
        Ok(_value)
    }
    fn write_systick_stcvr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 3 {
            let _offset_start = (0 - _start) as usize;
            let _offset_end = _offset_start + 3;
            let _value = u32::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_systick_stcvr_current(_value)?;
        } else if (_start > 0 && _start < 3) || (_end > 0 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_systick_stcr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_systick_stcr_tenms()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_systick_stcr_skew()?)
            << 30u32;
        _value |= u32::from(self.0.lock().unwrap().read_systick_stcr_noref()?)
            << 31u32;
        Ok(_value)
    }
    fn read_nvic_nvic_ipr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr0_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr0_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr0_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr0_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr0(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr0_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr0_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr0_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr0_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr1_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr1_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr1_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr1_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr1_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr1_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr1_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr1_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr2_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr2_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr2_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr2_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr2_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr2_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr2_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr2_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr3_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr3_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr3_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr3_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr3_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr3_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr3_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr3_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr4_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr4_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr4_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr4_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr4(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr4_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr4_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr4_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr4_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr5(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr5_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr5_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr5_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr5_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr5(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr5_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr5_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr5_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr5_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr6(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr6_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr6_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr6_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr6_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr6(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr6_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr6_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr6_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr6_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr7(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr7_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr7_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr7_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr7_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr7(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr7_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr7_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr7_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr7_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr8(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr8_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr8_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr8_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr8_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr8(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr8_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr8_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr8_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr8_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr9(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr9_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr9_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr9_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr9_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr9(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr9_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr9_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr9_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr9_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr10(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr10_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr10_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr10_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr10_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr10(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr10_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr10_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr10_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr10_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr11(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr11_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr11_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr11_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr11_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr11(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr11_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr11_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr11_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr11_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr12(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr12_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr12_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr12_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr12_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr12(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr12_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr12_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr12_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr12_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr13(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr13_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr13_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr13_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr13_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr13(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr13_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr13_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr13_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr13_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr14(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr14_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr14_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr14_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr14_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr14(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr14_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr14_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr14_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr14_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr15(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr15_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr15_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr15_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr15_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr15(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr15_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr15_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr15_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr15_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr16(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr16_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr16_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr16_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr16_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr16(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr16_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr16_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr16_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr16_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr17(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr17_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr17_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr17_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr17_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr17(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr17_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr17_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr17_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr17_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr18(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr18_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr18_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr18_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr18_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr18(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr18_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr18_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr18_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr18_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr19(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr19_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr19_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr19_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr19_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr19(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr19_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr19_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr19_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr19_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr20(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr20_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr20_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr20_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr20_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr20(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr20_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr20_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr20_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr20_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr21(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr21_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr21_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr21_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr21_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr21(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr21_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr21_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr21_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr21_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr22(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr22_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr22_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr22_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr22_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr22(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr22_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr22_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr22_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr22_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr23(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr23_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr23_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr23_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr23_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr23(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr23_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr23_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr23_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr23_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr24(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr24_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr24_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr24_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr24_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr24(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr24_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr24_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr24_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr24_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr25(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr25_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr25_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr25_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr25_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr25(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr25_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr25_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr25_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr25_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr26(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr26_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr26_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr26_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr26_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr26(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr26_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr26_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr26_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr26_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr27(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr27_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr27_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr27_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr27_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr27(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr27_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr27_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr27_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr27_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr28(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr28_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr28_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr28_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr28_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr28(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr28_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr28_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr28_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr28_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr29(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr29_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr29_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr29_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr29_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr29(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr29_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr29_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr29_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr29_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr30(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr30_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr30_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr30_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr30_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr30(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr30_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr30_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr30_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr30_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr31(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr31_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr31_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr31_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr31_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr31(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr31_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr31_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr31_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr31_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr32(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr32_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr32_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr32_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr32_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr32(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr32_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr32_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr32_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr32_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr33(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr33_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr33_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr33_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr33_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr33(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr33_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr33_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr33_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr33_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr34(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr34_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr34_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr34_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr34_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr34(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr34_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr34_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr34_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr34_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr35(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr35_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr35_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr35_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr35_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr35(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr35_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr35_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr35_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr35_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr36(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr36_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr36_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr36_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr36_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr36(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr36_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr36_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr36_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr36_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr37(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr37_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr37_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr37_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr37_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr37(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr37_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr37_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr37_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr37_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr38(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr38_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr38_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr38_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr38_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr38(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr38_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr38_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr38_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr38_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr39(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr39_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr39_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr39_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr39_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr39(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr39_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr39_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr39_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr39_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr40(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr40_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr40_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr40_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr40_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr40(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr40_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr40_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr40_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr40_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr41(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr41_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr41_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr41_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr41_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr41(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr41_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr41_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr41_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr41_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr42(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr42_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr42_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr42_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr42_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr42(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr42_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr42_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr42_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr42_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr43(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr43_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr43_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr43_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr43_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr43(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr43_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr43_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr43_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr43_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr44(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr44_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr44_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr44_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr44_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr44(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr44_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr44_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr44_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr44_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr45(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr45_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr45_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr45_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr45_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr45(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr45_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr45_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr45_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr45_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr46(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr46_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr46_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr46_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr46_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr46(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr46_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr46_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr46_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr46_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr47(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr47_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr47_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr47_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr47_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr47(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr47_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr47_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr47_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr47_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr48(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr48_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr48_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr48_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr48_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr48(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr48_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr48_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr48_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr48_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr49(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr49_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr49_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr49_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr49_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr49(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr49_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr49_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr49_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr49_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr50(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr50_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr50_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr50_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr50_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr50(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr50_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr50_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr50_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr50_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr51(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr51_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr51_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr51_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr51_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr51(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr51_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr51_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr51_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr51_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr52(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr52_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr52_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr52_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr52_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr52(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr52_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr52_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr52_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr52_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr53(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr53_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr53_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr53_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr53_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr53(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr53_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr53_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr53_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr53_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr54(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr54_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr54_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr54_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr54_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr54(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr54_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr54_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr54_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr54_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr55(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr55_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr55_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr55_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr55_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr55(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr55_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr55_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr55_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr55_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr56(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr56_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr56_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr56_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr56_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr56(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr56_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr56_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr56_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr56_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr57(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr57_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr57_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr57_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr57_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr57(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr57_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr57_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr57_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr57_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr58(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr58_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr58_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr58_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr58_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr58(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr58_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr58_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr58_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr58_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_nvic_nvic_ipr59(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr59_pri_n0()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr59_pri_n1()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr59_pri_n2()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_nvic_nvic_ipr59_pri_n3()?)
                << 24u32;
        Ok(_value)
    }
    fn write_nvic_nvic_ipr59(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr59_pri_n0((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr59_pri_n1((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr59_pri_n2((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_nvic_nvic_ipr59_pri_n3((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_id_cpuid(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_cpuid_revision()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_cpuid_partno()?) << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_id_cpuid_constant()?)
            << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_cpuid_variant()?) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_cpuid_implementer()?)
                << 24u32;
        Ok(_value)
    }
    fn read_control_icsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_vectactive()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_rettobase()?)
                << 11u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_vectpending()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_isrpending()?)
                << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_isrpreempt()?)
                << 23u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_pendstclr()?)
                << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_pendstset()?)
                << 26u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_pendsvclr()?)
                << 27u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_pendsvset()?)
                << 28u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_icsr_nmipendset()?)
                << 31u32;
        Ok(_value)
    }
    fn write_control_icsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 1u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_vectactive(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_rettobase((_value[_i] >> 3) & 1 != 0)?;
        }
        if _start <= 1 && _end >= 3 {
            let mut _extracted: u16 = 0;
            _extracted |= ((_value[(1 - _start) as usize] >> 4) & 15u8) as u16;
            _extracted |= ((_value[((1 + 0 + 1) - _start) as usize] & 31u8)
                as u16)
                << (4 + (0 * 8));
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_vectpending(_extracted)?;
        } else if (_start > 1 && _start < 3) || (_end > 1 && _end < 3) {
            return Err(MemError::WriteViolation);
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_isrpending((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_isrpreempt((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_pendstclr((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_pendstset((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_pendsvclr((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_pendsvset((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_icsr_nmipendset((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_vtor(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_control_vtor_tbloff()?)
            << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_vtor_tblbase()?)
                << 29u32;
        Ok(_value)
    }
    fn write_control_vtor(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 7) & 1u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (7 + (byte_i * 8));
            }
            self.0
                .lock()
                .unwrap()
                .write_control_vtor_tbloff(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_vtor_tblbase((_value[_i] >> 5) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_aircr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_aircr_vectclractive()?,
        ) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_aircr_sysresetreq()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_aircr_prigroup()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_aircr_endianness()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_aircr_vectkey()?)
                << 16u32;
        Ok(_value)
    }
    fn write_control_aircr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0.lock().unwrap().write_control_aircr_vectclractive(
                (_value[_i] >> 1) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_aircr_sysresetreq((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_aircr_prigroup((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_aircr_endianness((_value[_i] >> 7) & 1 != 0)?;
        }
        if _start <= 2 && _end >= 4 {
            let _offset_start = (2 - _start) as usize;
            let _offset_end = _offset_start + 2;
            let _value = u16::from_ne_bytes(
                _value[_offset_start.._offset_end].try_into().unwrap(),
            );
            self.0.lock().unwrap().write_control_aircr_vectkey(_value)?;
        } else if (_start > 2 && _start < 4) || (_end > 2 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_control_scr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_scr_sleeponexit()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_scr_sleepdeep()?)
                << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_scr_sevonpend()?)
                << 4u32;
        Ok(_value)
    }
    fn write_control_scr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_scr_sleeponexit((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_scr_sleepdeep((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_scr_sevonpend((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_ccr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_ccr_nonbasethrdena()?,
        ) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_usersetmpend()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_unalign_trp()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_div_0_trp()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_bfhfnmign()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_ccr_stkalign()?)
                << 9u32;
        Ok(_value)
    }
    fn write_control_ccr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_nonbasethrdena((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_usersetmpend((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_unalign_trp((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_div_0_trp((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_bfhfnmign((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_ccr_stkalign((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_shpr1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr1_pri_4()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr1_pri_5()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr1_pri_6()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr1_pri_7()?)
            << 24u32;
        Ok(_value)
    }
    fn write_control_shpr1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr1_pri_4((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr1_pri_5((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr1_pri_6((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr1_pri_7((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_control_shpr2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr2_pri_8()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_shpr2_pri_9()?)
            << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr2_pri_10()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr2_pri_11()?)
                << 24u32;
        Ok(_value)
    }
    fn write_control_shpr2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr2_pri_8((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr2_pri_9((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr2_pri_10((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr2_pri_11((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_control_shpr3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr3_pri_12()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr3_pri_13()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr3_pri_14()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shpr3_pri_15()?)
                << 24u32;
        Ok(_value)
    }
    fn write_control_shpr3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr3_pri_12((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr3_pri_13((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr3_pri_14((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shpr3_pri_15((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_control_shcsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_memfaultact()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_busfaultact()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_usgfaultact()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_svcallact()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_monitoract()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_pendsvact()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_systickact()?)
                << 11u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_shcsr_usgfaultpended()?,
        ) << 12u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_shcsr_memfaultpended()?,
        ) << 13u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_shcsr_busfaultpended()?,
        ) << 14u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_control_shcsr_svcallpended()?,
        ) << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_memfaultena()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_busfaultena()?)
                << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_shcsr_usgfaultena()?)
                << 18u32;
        Ok(_value)
    }
    fn write_control_shcsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_memfaultact((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_busfaultact((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_usgfaultact((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_svcallact((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_monitoract((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_pendsvact((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_systickact((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_control_shcsr_usgfaultpended(
                (_value[_i] >> 4) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_control_shcsr_memfaultpended(
                (_value[_i] >> 5) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0.lock().unwrap().write_control_shcsr_busfaultpended(
                (_value[_i] >> 6) & 1 != 0,
            )?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_svcallpended((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_memfaultena((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_busfaultena((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_shcsr_usgfaultena((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_cfsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_iaccviol()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_daccviol()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_munstkerr()?)
                << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_mstkerr()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_mlsperr()?)
                << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_mmarvalid()?)
                << 7u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_ibuserr()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_preciserr()?)
                << 9u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_impreciserr()?)
                << 10u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_unstkerr()?)
                << 11u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cfsr_stkerr()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cfsr_lsperr()?)
            << 13u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_bfarvalid()?)
                << 15u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_undefinstr()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_invstate()?)
                << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cfsr_invpc()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cfsr_nocp()?)
            << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_unaligned()?)
                << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cfsr_divbyzero()?)
                << 25u32;
        Ok(_value)
    }
    fn write_control_cfsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_iaccviol((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_daccviol((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_munstkerr((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_mstkerr((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_mlsperr((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_mmarvalid((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_ibuserr((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_preciserr((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_impreciserr((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_unstkerr((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_stkerr((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_lsperr((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_bfarvalid((_value[_i] >> 7) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_undefinstr((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_invstate((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_invpc((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_nocp((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_unaligned((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cfsr_divbyzero((_value[_i] >> 1) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_hfsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_hfsr_vecttbl()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_hfsr_forced()?)
            << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_hfsr_debugevt()?)
                << 31u32;
        Ok(_value)
    }
    fn write_control_hfsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_hfsr_vecttbl((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_hfsr_forced((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_hfsr_debugevt((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_dfsr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_control_dfsr_halted()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_dfsr_bkpt()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_dfsr_dwttrap()?)
                << 2u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_dfsr_vcatch()?)
            << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_dfsr_external()?)
                << 4u32;
        Ok(_value)
    }
    fn write_control_dfsr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_halted((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_bkpt((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_dwttrap((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_vcatch((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_dfsr_external((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_id_id_pfr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_pfr0_state1()?) << 4u32;
        Ok(_value)
    }
    fn read_id_id_pfr1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_pfr1_m_profile()?)
                << 8u32;
        Ok(_value)
    }
    fn read_id_id_dfr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_dfr0_m_profile()?)
                << 20u32;
        Ok(_value)
    }
    fn read_id_id_mmfr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_mmfr0_pmsa()?) << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_mmfr0_outermost_shareability()?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_mmfr0_shareability_levels()?,
        ) << 12u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_mmfr0_auxiliary_registers()?,
        ) << 20u32;
        Ok(_value)
    }
    fn read_id_id_mmfr2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_mmfr2_wfi()?) << 24u32;
        Ok(_value)
    }
    fn read_id_id_isar0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar0_bitcount_instrs()?,
        ) << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar0_bitfield_instrs()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar0_cmpbranch_instrs()?,
        ) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar0_coproc_instrs()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar0_debug_instrs()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar0_divide_instrs()?)
                << 24u32;
        Ok(_value)
    }
    fn read_id_id_isar1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar1_extend_instrs()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar1_ifthen_instrs()?)
                << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar1_immediate_instrs()?,
        ) << 20u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar1_interwork_instrs()?,
        ) << 24u32;
        Ok(_value)
    }
    fn read_id_id_isar2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar2_loadstore_instrs()?,
        ) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar2_memhint_instrs()?,
        ) << 4u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_isar2_multiaccessint_instrs()?,
        ) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar2_mult_instrs()?)
                << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar2_mults_instrs()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar2_multu_instrs()?)
                << 20u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar2_reversal_instrs()?,
        ) << 28u32;
        Ok(_value)
    }
    fn read_id_id_isar3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_saturate_instrs()?,
        ) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar3_simd_instrs()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar3_svc_instrs()?)
                << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_synchprim_instrs()?,
        ) << 12u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_tabbranch_instrs()?,
        ) << 16u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_thumbcopy_instrs()?,
        ) << 20u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar3_truenop_instrs()?,
        ) << 24u32;
        Ok(_value)
    }
    fn read_id_id_isar4(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar4_unpriv_instrs()?)
                << 0u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_isar4_withshifts_instrs()?,
        ) << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar4_writeback_instrs()?,
        ) << 8u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_id_id_isar4_barrier_instrs()?,
        ) << 16u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_id_id_isar4_synchprim_instrs_frac()?,
        ) << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_id_id_isar4_psr_m_instrs()?)
                << 24u32;
        Ok(_value)
    }
    fn read_control_cpacr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp0()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp1()?) << 2u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp2()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp3()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_cpacr_cp4()?) << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp5()?)
            << 10u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp6()?)
            << 12u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp7()?)
            << 14u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp10()?)
            << 20u32;
        _value |= u32::from(self.0.lock().unwrap().read_control_cpacr_cp11()?)
            << 22u32;
        Ok(_value)
    }
    fn write_control_cpacr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp0((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp1((_value[_i] >> 2) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp2((_value[_i] >> 4) & 3u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp3((_value[_i] >> 6) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp4((_value[_i] >> 0) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp5((_value[_i] >> 2) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp6((_value[_i] >> 4) & 3u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp7((_value[_i] >> 6) & 3u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp10((_value[_i] >> 4) & 3u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_control_cpacr_cp11((_value[_i] >> 6) & 3u8)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_type(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_type_separate()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_type_dregion()?)
                << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_type_iregion()?)
                << 16u32;
        Ok(_value)
    }
    fn read_mpu_mpu_ctrl(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_ctrl_enable()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_ctrl_hfnmiena()?)
                << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_ctrl_privdefena()?)
                << 2u32;
        Ok(_value)
    }
    fn write_mpu_mpu_ctrl(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_ctrl_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_ctrl_hfnmiena((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_ctrl_privdefena((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rnr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rnr_region()?)
            << 0u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rnr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rnr_region((_value[_i] >> 0) & 255u8)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rbar(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_region()?)
            << 0u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_valid()?)
            << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_addr()?) << 5u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rbar(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_region((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_valid((_value[_i] >> 4) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 5) & 7u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (5 + (byte_i * 8));
            }
            self.0.lock().unwrap().write_mpu_mpu_rbar_addr(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_mpu_mpu_rasr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_enable()?)
            << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_size()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_srd()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_b()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_c()?) << 17u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_s()?) << 18u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_tex()?) << 19u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_ap()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_xn()?) << 28u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rasr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_size((_value[_i] >> 1) & 31u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_srd((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_b((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_c((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_s((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_tex((_value[_i] >> 3) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_ap((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_xn((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rbar_a1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a1_region()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a1_valid()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a1_addr()?)
                << 5u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rbar_a1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a1_region((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a1_valid((_value[_i] >> 4) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 5) & 7u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (5 + (byte_i * 8));
            }
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a1_addr(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_mpu_mpu_rasr_a1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_enable()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_size()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_srd()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_b()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_c()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_s()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_tex()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_ap()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a1_xn()?)
            << 28u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rasr_a1(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_size((_value[_i] >> 1) & 31u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_srd((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_b((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_c((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_s((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_tex((_value[_i] >> 3) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_ap((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a1_xn((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rbar_a2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a2_region()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a2_valid()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a2_addr()?)
                << 5u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rbar_a2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a2_region((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a2_valid((_value[_i] >> 4) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 5) & 7u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (5 + (byte_i * 8));
            }
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a2_addr(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_mpu_mpu_rasr_a2(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_enable()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_size()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_srd()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_b()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_c()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_s()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_tex()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_ap()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a2_xn()?)
            << 28u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rasr_a2(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_size((_value[_i] >> 1) & 31u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_srd((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_b((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_c((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_s((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_tex((_value[_i] >> 3) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_ap((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a2_xn((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_mpu_mpu_rbar_a3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a3_region()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a3_valid()?)
                << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rbar_a3_addr()?)
                << 5u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rbar_a3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a3_region((_value[_i] >> 0) & 15u8)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a3_valid((_value[_i] >> 4) & 1 != 0)?;
        }
        if _start <= 0 && _end >= 4 {
            let mut _extracted: u32 = 0;
            _extracted |= ((_value[(0 - _start) as usize] >> 5) & 7u8) as u32;
            for byte_i in 0..3 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u32)
                    << (5 + (byte_i * 8));
            }
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rbar_a3_addr(_extracted)?;
        } else if (_start > 0 && _start < 4) || (_end > 0 && _end < 4) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_mpu_mpu_rasr_a3(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_enable()?)
                << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_size()?)
                << 1u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_srd()?)
            << 8u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_b()?)
            << 16u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_c()?)
            << 17u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_s()?)
            << 18u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_tex()?)
            << 19u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_ap()?)
            << 24u32;
        _value |= u32::from(self.0.lock().unwrap().read_mpu_mpu_rasr_a3_xn()?)
            << 28u32;
        Ok(_value)
    }
    fn write_mpu_mpu_rasr_a3(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_enable((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_size((_value[_i] >> 1) & 31u8)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_srd((_value[_i] >> 0) & 255u8)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_b((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_c((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_s((_value[_i] >> 2) & 1 != 0)?;
        }
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_tex((_value[_i] >> 3) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_ap((_value[_i] >> 0) & 7u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_mpu_mpu_rasr_a3_xn((_value[_i] >> 4) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_control_demcr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_demcr_mon_en()?)
                << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_control_demcr_mon_pend()?)
                << 17u32;
        Ok(_value)
    }
    fn write_control_stir(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if _start <= 0 && _end >= 2 {
            let mut _extracted: u16 = 0;
            for byte_i in 0..1 {
                _extracted |= (_value[((0 + byte_i + 1) - _start) as usize]
                    as u16)
                    << (0 + (byte_i * 8));
            }
            _extracted |= ((_value[((0 + 1 + 1) - _start) as usize] & 1u8)
                as u16)
                << (0 + (1 * 8));
            self.0
                .lock()
                .unwrap()
                .write_control_stir_intid(_extracted)?;
        } else if (_start > 0 && _start < 2) || (_end > 0 && _end < 2) {
            return Err(MemError::WriteViolation);
        }
        Ok(())
    }
    fn read_fpe_fpccr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_lspact()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_user()?) << 1u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_thread()?) << 3u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_hfrdy()?) << 4u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_mmrdy()?) << 5u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_bfrdy()?) << 6u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_monrdy()?) << 8u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_lspen()?) << 30u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpccr_aspen()?) << 31u32;
        Ok(_value)
    }
    fn write_fpe_fpccr(&mut self, _start: u64, _value: &[u8]) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_lspact((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_user((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_thread((_value[_i] >> 3) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_hfrdy((_value[_i] >> 4) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_mmrdy((_value[_i] >> 5) & 1 != 0)?;
        }
        if (_start.._end).contains(&0) {
            let _i = (0 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_bfrdy((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&1) {
            let _i = (1 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_monrdy((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_lspen((_value[_i] >> 6) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpccr_aspen((_value[_i] >> 7) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_fpe_fpdscr(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpdscr_rmode()?) << 22u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpdscr_fz()?) << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpdscr_dn()?) << 25u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_fpdscr_ahp()?) << 26u32;
        Ok(_value)
    }
    fn write_fpe_fpdscr(
        &mut self,
        _start: u64,
        _value: &[u8],
    ) -> MemResult<()> {
        debug_assert!(!_value.is_empty());
        let _end = _start + _value.len() as u64;
        if (_start.._end).contains(&2) {
            let _i = (2 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpdscr_rmode((_value[_i] >> 6) & 3u8)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpdscr_fz((_value[_i] >> 0) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpdscr_dn((_value[_i] >> 1) & 1 != 0)?;
        }
        if (_start.._end).contains(&3) {
            let _i = (3 - _start) as usize;
            self.0
                .lock()
                .unwrap()
                .write_fpe_fpdscr_ahp((_value[_i] >> 2) & 1 != 0)?;
        }
        Ok(())
    }
    fn read_fpe_mvfr0(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr0_a_simd()?) << 0u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_fpe_mvfr0_single_precision()?,
        ) << 4u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_fpe_mvfr0_double_precision()?,
        ) << 8u32;
        _value |= u32::from(
            self.0
                .lock()
                .unwrap()
                .read_fpe_mvfr0_fp_exception_trapping()?,
        ) << 12u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr0_divide()?) << 16u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr0_square_root()?)
                << 20u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr0_short_vectors()?)
                << 24u32;
        _value |= u32::from(
            self.0.lock().unwrap().read_fpe_mvfr0_fp_rounding_modes()?,
        ) << 28u32;
        Ok(_value)
    }
    fn read_fpe_mvfr1(&self) -> MemResult<u32> {
        let mut _value = 0;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr1_ftz()?) << 0u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr1_d_nan()?) << 4u32;
        _value |= u32::from(self.0.lock().unwrap().read_fpe_mvfr1_fp_hpfp()?)
            << 24u32;
        _value |=
            u32::from(self.0.lock().unwrap().read_fpe_mvfr1_fp_fused_mac()?)
                << 28u32;
        Ok(_value)
    }
}
