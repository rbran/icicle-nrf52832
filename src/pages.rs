use icicle_vm::cpu::mem::{MemError, MemResult};
pub struct Ficr(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Ficr {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::ficr::Ficr::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (16..=23, 17..=24) => {
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ficr_codepagesize10_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ficr_codesize14_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (96..=103, 97..=104) => {
                if _start < 104 && _end > 96 {
                    let _offset_start = 96u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(104);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(96);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .ficr_deviceidn60_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (128..=171, 129..=172) => {
                if _start < 144 && _end > 128 {
                    let _offset_start = 128u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(144);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(128);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .ficr_ern80_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 160 && _end > 144 {
                    let _offset_start = 144u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(160);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(144);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .ficr_irn90_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 164 && _end > 160 {
                    let _offset_start = 160u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(164);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(160);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ficr_deviceaddrtypea0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 172 && _end > 164 {
                    let _offset_start = 164u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(172);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(164);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .ficr_deviceaddrna4_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (256..=287, 257..=288) => {
                if _start < 288 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(32);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_info_part0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_info_variant4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_info_package8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_info_ramc_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 20 && _end > 16 {
                        let _offset_start = 16u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(20);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(16);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_info_flash10_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 32 && _end > 20 {
                        let _offset_start = 20u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(32);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(20);
                        let _end = (_start + _buf.len() as u64).max(4);
                        for _dim in 0..3usize {
                            let _dim_offset = _dim as u64 * 4;
                            let _reg_start = _dim_offset;
                            let _reg_end = _reg_start + 4;
                            if _start < _reg_end && _end > _reg_start {
                                let _offset_start =
                                    _reg_start.saturating_sub(_start);
                                let _offset_end = _buf.len() as u64
                                    - _end.saturating_sub(_reg_end);
                                let _buf = &mut _buf[_offset_start as usize
                                    .._offset_end as usize];
                                let _start = _start.saturating_sub(_reg_start);
                                let _end = (_end - _reg_end).min(4);
                                let _end = (_start + _buf.len() as u64).max(4);
                                let value = self
                                    .0
                                    .lock()
                                    .unwrap()
                                    .ficr_info_unused0n14_read(_dim)?
                                    .to_ne_bytes();
                                for _byte in _start.._end {
                                    _buf[_byte as usize] =
                                        value[_byte as usize];
                                }
                            }
                        }
                    }
                }
            }
            (1028..=1095, 1029..=1096) => {
                if _start < 1096 && _end > 1028 {
                    let _offset_start = 1028u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1096);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1028);
                    let _end = (_start + _buf.len() as u64).max(68);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_a00_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_a14_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_a28_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_a3c_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 20 && _end > 16 {
                        let _offset_start = 16u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(20);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(16);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_a410_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 24 && _end > 20 {
                        let _offset_start = 20u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(24);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(20);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_a514_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 28 && _end > 24 {
                        let _offset_start = 24u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(28);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(24);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_b018_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 32 && _end > 28 {
                        let _offset_start = 28u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(32);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(28);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_b11c_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 36 && _end > 32 {
                        let _offset_start = 32u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(36);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(32);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_b220_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 40 && _end > 36 {
                        let _offset_start = 36u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(40);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(36);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_b324_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 44 && _end > 40 {
                        let _offset_start = 40u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(44);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(40);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_b428_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 48 && _end > 44 {
                        let _offset_start = 44u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(48);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(44);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_b52c_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 52 && _end > 48 {
                        let _offset_start = 48u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(52);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(48);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_t030_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 56 && _end > 52 {
                        let _offset_start = 52u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(56);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(52);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_t134_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 60 && _end > 56 {
                        let _offset_start = 56u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(60);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(56);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_t238_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 64 && _end > 60 {
                        let _offset_start = 60u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(64);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(60);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_t33c_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 68 && _end > 64 {
                        let _offset_start = 64u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(68);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(64);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_temp_t440_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1104..=1119, 1105..=1120) => {
                if _start < 1120 && _end > 1104 {
                    let _offset_start = 1104u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1120);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1104);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_nfc_tagheader00_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_nfc_tagheader14_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_nfc_tagheader28_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .ficr_nfc_tagheader3c_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::ficr::Ficr::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (16..=23, 17..=24) => {
                return Err(MemError::WriteViolation);
            }
            (96..=103, 97..=104) => {
                return Err(MemError::WriteViolation);
            }
            (128..=171, 129..=172) => {
                return Err(MemError::WriteViolation);
            }
            (256..=287, 257..=288) => {
                if _start < 288 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(32);
                    if _start < 4 && _end > 0 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 8 && _end > 4 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 12 && _end > 8 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 16 && _end > 12 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 20 && _end > 16 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 32 && _end > 20 {
                        let _offset_start = 20u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(32);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(20);
                        let _end = (_start + _buf.len() as u64).max(4);
                        for _dim in 0..3usize {
                            let _dim_offset = _dim as u64 * 4;
                            let _reg_start = _dim_offset;
                            let _reg_end = _reg_start + 4;
                            if _start < _reg_end && _end > _reg_start {
                                let _offset_start =
                                    _reg_start.saturating_sub(_start);
                                let _offset_end = _buf.len() as u64
                                    - _end.saturating_sub(_reg_end);
                                let _buf = &_buf[_offset_start as usize
                                    .._offset_end as usize];
                                let _start = _start.saturating_sub(_reg_start);
                                let _end = (_end - _reg_end).min(4);
                                let _end = (_start + _buf.len() as u64).max(4);
                                self.0
                                    .lock()
                                    .unwrap()
                                    .ficr_info_unused0n14_write(
                                        _dim, _start, _buf,
                                    )?;
                            }
                        }
                    }
                }
            }
            (1028..=1095, 1029..=1096) => {
                return Err(MemError::WriteViolation);
            }
            (1104..=1119, 1105..=1120) => {
                return Err(MemError::WriteViolation);
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Uicr(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Uicr {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::uicr::Uicr::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .uicr_unused00_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .uicr_unused14_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .uicr_unused28_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (16..=255, 17..=256) => {
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .uicr_unused310_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 80 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(80);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..15usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .uicr_nrffwn14_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 128 && _end > 80 {
                    let _offset_start = 80u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(128);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(80);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..12usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .uicr_nrfhwn50_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 256 && _end > 128 {
                    let _offset_start = 128u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(256);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(128);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..32usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .uicr_customern80_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (512..=527, 513..=528) => {
                if _start < 520 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(520);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .uicr_pselresetn200_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 524 && _end > 520 {
                    let _offset_start = 520u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(524);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(520);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .uicr_approtect208_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 528 && _end > 524 {
                    let _offset_start = 524u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(528);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(524);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .uicr_nfcpins20c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::uicr::Uicr::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().uicr_unused00_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().uicr_unused14_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().uicr_unused28_write(_start, _buf)?;
                }
            }
            (16..=255, 17..=256) => {
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .uicr_unused310_write(_start, _buf)?;
                }
                if _start < 80 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(80);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..15usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .uicr_nrffwn14_write(_dim, _start, _buf)?;
                        }
                    }
                }
                if _start < 128 && _end > 80 {
                    let _offset_start = 80u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(128);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(80);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..12usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .uicr_nrfhwn50_write(_dim, _start, _buf)?;
                        }
                    }
                }
                if _start < 256 && _end > 128 {
                    let _offset_start = 128u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(256);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(128);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..32usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .uicr_customern80_write(_dim, _start, _buf)?;
                        }
                    }
                }
            }
            (512..=527, 513..=528) => {
                if _start < 520 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(520);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .uicr_pselresetn200_write(_dim, _start, _buf)?;
                        }
                    }
                }
                if _start < 524 && _end > 520 {
                    let _offset_start = 520u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(524);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(520);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .uicr_approtect208_write(_start, _buf)?;
                }
                if _start < 528 && _end > 524 {
                    let _offset_start = 524u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(528);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(524);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .uicr_nfcpins20c_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Apb0(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Apb0 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb0::Apb0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=27, 1..=28) => {
                return Err(MemError::ReadViolation);
            }
            (120..=127, 121..=128) => {
                return Err(MemError::ReadViolation);
            }
            (256..=283, 257..=284) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_events_hfclkstarted100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_events_lfclkstarted104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_events_pofwarn108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_events_done10c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_events_ctto110_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_events_sleepenter114_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_events_sleepexit118_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_resetreas400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1032..=1039, 1033..=1040) => {
                if _start < 1036 && _end > 1032 {
                    let _offset_start = 1032u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1036);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1032);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_hfclkrun408_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _offset_start = 1036u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1040);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1036);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_hfclkstat40c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1044..=1055, 1045..=1056) => {
                if _start < 1048 && _end > 1044 {
                    let _offset_start = 1044u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1048);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1044);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_lfclkrun414_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1052 && _end > 1048 {
                    let _offset_start = 1048u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1052);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1048);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_lfclkstat418_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1056 && _end > 1052 {
                    let _offset_start = 1052u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1056);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1052);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_lfclksrccopy41c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1064..=1067, 1065..=1068) => {
                if _start < 1068 && _end > 1064 {
                    let _offset_start = 1064u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1068);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1064);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_ramstatus428_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1283, 1281..=1284) => {
                return Err(MemError::ReadViolation);
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_pofcon510_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1304..=1319, 1305..=1320) => {
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_lfclksrc518_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_gpregret51c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_gpregret2520_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_ramon524_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let _offset_start = 1336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1340);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_ctiv538_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1364..=1367, 1365..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_ramonb554_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _offset_start = 1372u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1376);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1372);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_traceconfig55c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1400..=1403, 1401..=1404) => {
                if _start < 1404 && _end > 1400 {
                    let _offset_start = 1400u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1404);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1400);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_dcdcen578_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1536..=1559, 1537..=1560) => {
                if _start < 1540 && _end > 1536 {
                    let _offset_start = 1536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1540);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1536);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_config0600_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1544 && _end > 1540 {
                    let _offset_start = 1540u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1544);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1540);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_config1604_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1548 && _end > 1544 {
                    let _offset_start = 1544u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1548);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1544);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_disableindebug608_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1552 && _end > 1548 {
                    let _offset_start = 1548u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1552);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1548);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_unused060c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1556 && _end > 1552 {
                    let _offset_start = 1552u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1556);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1552);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_config2610_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1560 && _end > 1556 {
                    let _offset_start = 1556u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1560);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1556);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb0_config3614_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (2304..=2431, 2305..=2432) => {
                if _start < 2432 && _end > 2304 {
                    let _offset_start = 2304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(2432);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(2304);
                    let _end = (_start + _buf.len() as u64).max(128);
                    for _ramn in 0..8usize {
                        let _dim_offset = _ramn as u64 * 16;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 16;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(16);
                            if _start < 12 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .apb0_ramn_power0_read(_ramn as usize)?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    return Err(MemError::ReadViolation);
                                }
                                if _start < 12 && _end > 8 {
                                    return Err(MemError::ReadViolation);
                                }
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb0::Apb0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=27, 1..=28) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_hfclkstart0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_hfclkstop4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_lfclkstart8_write(_start, _buf)?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_lfclkstopc_write(_start, _buf)?;
                }
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_cal10_write(_start, _buf)?;
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_ctstart14_write(_start, _buf)?;
                }
                if _start < 28 && _end > 24 {
                    let _offset_start = 24u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(28);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(24);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_ctstop18_write(_start, _buf)?;
                }
            }
            (120..=127, 121..=128) => {
                if _start < 124 && _end > 120 {
                    let _offset_start = 120u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(124);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(120);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_constlat78_write(_start, _buf)?;
                }
                if _start < 128 && _end > 124 {
                    let _offset_start = 124u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(128);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(124);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_tasks_lowpwr7c_write(_start, _buf)?;
                }
            }
            (256..=283, 257..=284) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_events_hfclkstarted100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_events_lfclkstarted104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_events_pofwarn108_write(_start, _buf)?;
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_events_done10c_write(_start, _buf)?;
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_events_ctto110_write(_start, _buf)?;
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_events_sleepenter114_write(_start, _buf)?;
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_events_sleepexit118_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_intenclr308_write(_start, _buf)?;
                }
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_resetreas400_write(_start, _buf)?;
                }
            }
            (1032..=1039, 1033..=1040) => {
                return Err(MemError::WriteViolation);
            }
            (1044..=1055, 1045..=1056) => {
                return Err(MemError::WriteViolation);
            }
            (1064..=1067, 1065..=1068) => {
                return Err(MemError::WriteViolation);
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_systemoff500_write(_start, _buf)?;
                }
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_pofcon510_write(_start, _buf)?;
                }
            }
            (1304..=1319, 1305..=1320) => {
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_lfclksrc518_write(_start, _buf)?;
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_gpregret51c_write(_start, _buf)?;
                }
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_gpregret2520_write(_start, _buf)?;
                }
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb0_ramon524_write(_start, _buf)?;
                }
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let _offset_start = 1336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1340);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb0_ctiv538_write(_start, _buf)?;
                }
            }
            (1364..=1367, 1365..=1368) => {
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_ramonb554_write(_start, _buf)?;
                }
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _offset_start = 1372u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1376);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1372);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_traceconfig55c_write(_start, _buf)?;
                }
            }
            (1400..=1403, 1401..=1404) => {
                if _start < 1404 && _end > 1400 {
                    let _offset_start = 1400u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1404);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1400);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_dcdcen578_write(_start, _buf)?;
                }
            }
            (1536..=1559, 1537..=1560) => {
                if _start < 1540 && _end > 1536 {
                    let _offset_start = 1536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1540);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1536);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_config0600_write(_start, _buf)?;
                }
                if _start < 1544 && _end > 1540 {
                    let _offset_start = 1540u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1544);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1540);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_config1604_write(_start, _buf)?;
                }
                if _start < 1548 && _end > 1544 {
                    let _offset_start = 1544u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1548);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1544);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_disableindebug608_write(_start, _buf)?;
                }
                if _start < 1552 && _end > 1548 {
                    let _offset_start = 1548u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1552);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1548);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_unused060c_write(_start, _buf)?;
                }
                if _start < 1556 && _end > 1552 {
                    let _offset_start = 1552u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1556);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1552);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_config2610_write(_start, _buf)?;
                }
                if _start < 1560 && _end > 1556 {
                    let _offset_start = 1556u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1560);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1556);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb0_config3614_write(_start, _buf)?;
                }
            }
            (2304..=2431, 2305..=2432) => {
                if _start < 2432 && _end > 2304 {
                    let _offset_start = 2304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(2432);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(2304);
                    let _end = (_start + _buf.len() as u64).max(128);
                    for _ramn in 0..8usize {
                        let _dim_offset = _ramn as u64 * 16;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 16;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(16);
                            if _start < 12 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .apb0_ramn_power0_write(
                                            _ramn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .apb0_ramn_powerset4_write(
                                            _ramn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 12 && _end > 8 {
                                    let _offset_start =
                                        8u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(12);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(8);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .apb0_ramn_powerclr8_write(
                                            _ramn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Radio(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Radio {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::radio::Radio::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=35, 1..=36) => {
                return Err(MemError::ReadViolation);
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_ready100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_address104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_payload108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_end10c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_disabled110_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_devmatch114_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_devmiss118_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_rssiend11c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    let _offset_start = 296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_bcmatch128_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (304..=311, 305..=312) => {
                if _start < 308 && _end > 304 {
                    let _offset_start = 304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_crcok130_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 312 && _end > 308 {
                    let _offset_start = 308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(312);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_events_crcerror134_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_shorts200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_crcstatus400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1032..=1043, 1033..=1044) => {
                if _start < 1036 && _end > 1032 {
                    let _offset_start = 1032u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1036);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1032);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_rxmatch408_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _offset_start = 1036u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1040);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1036);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_rxcrc40c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1044 && _end > 1040 {
                    let _offset_start = 1040u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1044);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1040);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_dai410_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1355, 1285..=1356) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_packetptr504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_frequency508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_txpower50c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_mode510_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_pcnf0514_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_pcnf1518_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_base051c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_base1520_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_prefix0524_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _offset_start = 1320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1324);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_prefix1528_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _offset_start = 1324u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1328);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1324);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_txaddress52c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _offset_start = 1328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1332);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_rxaddresses530_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_crccnf534_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _offset_start = 1336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1340);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_crcpoly538_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _offset_start = 1340u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1344);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1340);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_crcinit53c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_unused0540_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1352);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_tifs544_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _offset_start = 1352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1356);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_rssisample548_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1360..=1367, 1361..=1368) => {
                if _start < 1364 && _end > 1360 {
                    let _offset_start = 1360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_state550_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_datawhiteiv554_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1376..=1379, 1377..=1380) => {
                if _start < 1380 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1380);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_bcc560_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1536..=1603, 1537..=1604) => {
                if _start < 1568 && _end > 1536 {
                    let _offset_start = 1536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1568);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1536);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .radio_dabn600_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 1600 && _end > 1568 {
                    let _offset_start = 1568u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1600);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1568);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .radio_dapn620_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 1604 && _end > 1600 {
                    let _offset_start = 1600u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1604);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1600);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_dacnf640_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1616..=1619, 1617..=1620) => {
                if _start < 1620 && _end > 1616 {
                    let _offset_start = 1616u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1620);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1616);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_modecnf0650_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _offset_start = 4092u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4096);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4092);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .radio_powerffc_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::radio::Radio::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=35, 1..=36) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_txen0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_rxen4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_start8_write(_start, _buf)?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_stopc_write(_start, _buf)?;
                }
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_disable10_write(_start, _buf)?;
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_rssistart14_write(_start, _buf)?;
                }
                if _start < 28 && _end > 24 {
                    let _offset_start = 24u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(28);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(24);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_rssistop18_write(_start, _buf)?;
                }
                if _start < 32 && _end > 28 {
                    let _offset_start = 28u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(32);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(28);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_bcstart1c_write(_start, _buf)?;
                }
                if _start < 36 && _end > 32 {
                    let _offset_start = 32u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(36);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(32);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_tasks_bcstop20_write(_start, _buf)?;
                }
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_ready100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_address104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_payload108_write(_start, _buf)?;
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_end10c_write(_start, _buf)?;
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_disabled110_write(_start, _buf)?;
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_devmatch114_write(_start, _buf)?;
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_devmiss118_write(_start, _buf)?;
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_rssiend11c_write(_start, _buf)?;
                }
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    let _offset_start = 296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_bcmatch128_write(_start, _buf)?;
                }
            }
            (304..=311, 305..=312) => {
                if _start < 308 && _end > 304 {
                    let _offset_start = 304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(308);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_crcok130_write(_start, _buf)?;
                }
                if _start < 312 && _end > 308 {
                    let _offset_start = 308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_events_crcerror134_write(_start, _buf)?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_shorts200_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_intenclr308_write(_start, _buf)?;
                }
            }
            (1024..=1027, 1025..=1028) => {
                return Err(MemError::WriteViolation);
            }
            (1032..=1043, 1033..=1044) => {
                return Err(MemError::WriteViolation);
            }
            (1284..=1355, 1285..=1356) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_packetptr504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_frequency508_write(_start, _buf)?;
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_txpower50c_write(_start, _buf)?;
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().radio_mode510_write(_start, _buf)?;
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_pcnf0514_write(_start, _buf)?;
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_pcnf1518_write(_start, _buf)?;
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_base051c_write(_start, _buf)?;
                }
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_base1520_write(_start, _buf)?;
                }
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_prefix0524_write(_start, _buf)?;
                }
                if _start < 1324 && _end > 1320 {
                    let _offset_start = 1320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1324);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_prefix1528_write(_start, _buf)?;
                }
                if _start < 1328 && _end > 1324 {
                    let _offset_start = 1324u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1328);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1324);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_txaddress52c_write(_start, _buf)?;
                }
                if _start < 1332 && _end > 1328 {
                    let _offset_start = 1328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1332);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_rxaddresses530_write(_start, _buf)?;
                }
                if _start < 1336 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_crccnf534_write(_start, _buf)?;
                }
                if _start < 1340 && _end > 1336 {
                    let _offset_start = 1336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1340);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_crcpoly538_write(_start, _buf)?;
                }
                if _start < 1344 && _end > 1340 {
                    let _offset_start = 1340u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1344);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1340);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_crcinit53c_write(_start, _buf)?;
                }
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_unused0540_write(_start, _buf)?;
                }
                if _start < 1352 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1352);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().radio_tifs544_write(_start, _buf)?;
                }
                if _start < 1356 && _end > 1352 {
                    return Err(MemError::WriteViolation);
                }
            }
            (1360..=1367, 1361..=1368) => {
                if _start < 1364 && _end > 1360 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_datawhiteiv554_write(_start, _buf)?;
                }
            }
            (1376..=1379, 1377..=1380) => {
                if _start < 1380 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1380);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().radio_bcc560_write(_start, _buf)?;
                }
            }
            (1536..=1603, 1537..=1604) => {
                if _start < 1568 && _end > 1536 {
                    let _offset_start = 1536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1568);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1536);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .radio_dabn600_write(_dim, _start, _buf)?;
                        }
                    }
                }
                if _start < 1600 && _end > 1568 {
                    let _offset_start = 1568u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1600);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1568);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .radio_dapn620_write(_dim, _start, _buf)?;
                        }
                    }
                }
                if _start < 1604 && _end > 1600 {
                    let _offset_start = 1600u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1604);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1600);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_dacnf640_write(_start, _buf)?;
                }
            }
            (1616..=1619, 1617..=1620) => {
                if _start < 1620 && _end > 1616 {
                    let _offset_start = 1616u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1620);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1616);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_modecnf0650_write(_start, _buf)?;
                }
            }
            (4092..=4095, 4093..=4096) => {
                if _start < 4096 && _end > 4092 {
                    let _offset_start = 4092u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4096);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4092);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .radio_powerffc_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Apb2(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Apb2 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb2::Apb2::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                return Err(MemError::ReadViolation);
            }
            (28..=31, 29..=32) => {
                return Err(MemError::ReadViolation);
            }
            (44..=47, 45..=48) => {
                return Err(MemError::ReadViolation);
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_cts100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_ncts104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_rxdrdy108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_endrx110_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (284..=295, 285..=296) => {
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_txdrdy11c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 292 && _end > 288 {
                    let _offset_start = 288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_endtx120_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 296 && _end > 292 {
                    let _offset_start = 292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_error124_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (324..=327, 325..=328) => {
                if _start < 328 && _end > 324 {
                    let _offset_start = 324u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(328);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(324);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_rxto144_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (332..=339, 333..=340) => {
                if _start < 336 && _end > 332 {
                    let _offset_start = 332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_rxstarted14c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _offset_start = 336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(340);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_txstarted150_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (344..=347, 345..=348) => {
                if _start < 348 && _end > 344 {
                    let _offset_start = 344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_events_txstopped158_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_shorts200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_inten300_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1152..=1155, 1153..=1156) => {
                if _start < 1156 && _end > 1152 {
                    let _offset_start = 1152u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1156);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1152);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_errorsrc480_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_enable500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1304 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_psel_rts0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_psel_txd4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_psel_cts8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_psel_rxdc_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_rxd518_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    return Err(MemError::ReadViolation);
                }
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_baudrate524_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1332..=1343, 1333..=1344) => {
                if _start < 1344 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1344);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(12);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_rxd_ptr0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_rxd_maxcnt4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_rxd_amount8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1348..=1359, 1349..=1360) => {
                if _start < 1360 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(12);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_txd_ptr0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_txd_maxcnt4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb2_txd_amount8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1388..=1391, 1389..=1392) => {
                if _start < 1392 && _end > 1388 {
                    let _offset_start = 1388u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1392);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1388);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb2_config56c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb2::Apb2::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_tasks_startrx0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_tasks_stoprx4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_tasks_starttx8_write(_start, _buf)?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_tasks_stoptxc_write(_start, _buf)?;
                }
            }
            (28..=31, 29..=32) => {
                if _start < 32 && _end > 28 {
                    let _offset_start = 28u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(32);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(28);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_tasks_suspend1c_write(_start, _buf)?;
                }
            }
            (44..=47, 45..=48) => {
                if _start < 48 && _end > 44 {
                    let _offset_start = 44u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(48);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(44);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_tasks_flushrx2c_write(_start, _buf)?;
                }
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_cts100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_ncts104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_rxdrdy108_write(_start, _buf)?;
                }
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_endrx110_write(_start, _buf)?;
                }
            }
            (284..=295, 285..=296) => {
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_txdrdy11c_write(_start, _buf)?;
                }
                if _start < 292 && _end > 288 {
                    let _offset_start = 288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_endtx120_write(_start, _buf)?;
                }
                if _start < 296 && _end > 292 {
                    let _offset_start = 292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_error124_write(_start, _buf)?;
                }
            }
            (324..=327, 325..=328) => {
                if _start < 328 && _end > 324 {
                    let _offset_start = 324u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(328);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(324);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_rxto144_write(_start, _buf)?;
                }
            }
            (332..=339, 333..=340) => {
                if _start < 336 && _end > 332 {
                    let _offset_start = 332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_rxstarted14c_write(_start, _buf)?;
                }
                if _start < 340 && _end > 336 {
                    let _offset_start = 336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(340);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_txstarted150_write(_start, _buf)?;
                }
            }
            (344..=347, 345..=348) => {
                if _start < 348 && _end > 344 {
                    let _offset_start = 344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_events_txstopped158_write(_start, _buf)?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_shorts200_write(_start, _buf)?;
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb2_inten300_write(_start, _buf)?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_intenclr308_write(_start, _buf)?;
                }
            }
            (1152..=1155, 1153..=1156) => {
                if _start < 1156 && _end > 1152 {
                    let _offset_start = 1152u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1156);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1152);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_errorsrc480_write(_start, _buf)?;
                }
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_enable500_write(_start, _buf)?;
                }
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1304 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb2_psel_rts0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb2_psel_txd4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb2_psel_cts8_write(_start, _buf)?;
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb2_psel_rxdc_write(_start, _buf)?;
                    }
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb2_txd51c_write(_start, _buf)?;
                }
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_baudrate524_write(_start, _buf)?;
                }
            }
            (1332..=1343, 1333..=1344) => {
                if _start < 1344 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1344);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(12);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb2_rxd_ptr0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb2_rxd_maxcnt4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        return Err(MemError::WriteViolation);
                    }
                }
            }
            (1348..=1359, 1349..=1360) => {
                if _start < 1360 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(12);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb2_txd_ptr0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb2_txd_maxcnt4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        return Err(MemError::WriteViolation);
                    }
                }
            }
            (1388..=1391, 1389..=1392) => {
                if _start < 1392 && _end > 1388 {
                    let _offset_start = 1388u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1392);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1388);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb2_config56c_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Apb3(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Apb3 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb3::Apb3::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                return Err(MemError::ReadViolation);
            }
            (8..=11, 9..=12) => {
                return Err(MemError::ReadViolation);
            }
            (16..=23, 17..=24) => {
                return Err(MemError::ReadViolation);
            }
            (28..=43, 29..=44) => {
                return Err(MemError::ReadViolation);
            }
            (48..=55, 49..=56) => {
                return Err(MemError::ReadViolation);
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_stopped104_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_ready108_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_endrx110_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (280..=299, 281..=300) => {
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_end118_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_txdsent11c_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 292 && _end > 288 {
                    let _offset_start = 288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_endtx120_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 296 && _end > 292 {
                    let _offset_start = 292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_error124_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 300 && _end > 296 {
                    let _offset_start = 296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_acquired128_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    let _offset_start = 312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(316);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_bb138_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (328..=339, 329..=340) => {
                if _start < 332 && _end > 328 {
                    let _offset_start = 328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(332);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_suspended148_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 336 && _end > 332 {
                    let _offset_start = 332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_started14c_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _offset_start = 336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(340);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_txstarted150_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (348..=363, 349..=364) => {
                if _start < 352 && _end > 348 {
                    let _offset_start = 348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(352);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_lastrx15c_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 356 && _end > 352 {
                    let _offset_start = 352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(356);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_lasttx160_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 360 && _end > 356 {
                    let _offset_start = 356u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(360);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(356);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_write164_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 364 && _end > 360 {
                    let _offset_start = 360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(364);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_events_read168_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_shorts200_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_inten300_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_intenset304_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_intenclr308_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_semstat400_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1088..=1091, 1089..=1092) => {
                if _start < 1092 && _end > 1088 {
                    let _offset_start = 1088u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1092);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1088);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_status440_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1220..=1223, 1221..=1224) => {
                if _start < 1224 && _end > 1220 {
                    let _offset_start = 1220u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1224);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1220);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_errorsrc4c4_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1232..=1239, 1233..=1240) => {
                if _start < 1236 && _end > 1232 {
                    let _offset_start = 1232u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1236);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1232);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_errorsrc4d0_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1240 && _end > 1236 {
                    let _offset_start = 1236u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1240);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1236);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_match4d4_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_enable500_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1304 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_psel_sck0_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_psel_miso4_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_psel_mosi8_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_psel_csnc_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_rxd518_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_txd51c_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_frequency524_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1332..=1367, 1333..=1368) => {
                if _start < 1348 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_rxd_ptr0_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_rxd_maxcnt4_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_rxd_amount8_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_rxd_listc_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1364 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_txd_ptr0_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_txd_maxcnt4_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_txd_amount8_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb3_txd_listc_read(_instance_page)?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_config554_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _offset_start = 1372u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1376);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1372);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_def55c_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1416..=1423, 1417..=1424) => {
                if _start < 1424 && _end > 1416 {
                    let _offset_start = 1416u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1424);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1416);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .apb3_addressn588_read(_instance_page, _dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (1428..=1431, 1429..=1432) => {
                if _start < 1432 && _end > 1428 {
                    let _offset_start = 1428u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1432);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1428);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_config594_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1472..=1475, 1473..=1476) => {
                if _start < 1476 && _end > 1472 {
                    let _offset_start = 1472u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1476);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1472);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb3_orc5c0_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb3::Apb3::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_startrx0_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (8..=11, 9..=12) => {
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_starttx8_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (16..=23, 17..=24) => {
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_start10_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_stop14_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (28..=43, 29..=44) => {
                if _start < 32 && _end > 28 {
                    let _offset_start = 28u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(32);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(28);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_suspend1c_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 36 && _end > 32 {
                    let _offset_start = 32u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(36);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(32);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_resume20_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 40 && _end > 36 {
                    let _offset_start = 36u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(40);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(36);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_acquire24_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 44 && _end > 40 {
                    let _offset_start = 40u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(44);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(40);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_release28_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (48..=55, 49..=56) => {
                if _start < 52 && _end > 48 {
                    let _offset_start = 48u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(52);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(48);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_preparerx30_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 56 && _end > 52 {
                    let _offset_start = 52u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(56);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(52);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_tasks_preparetx34_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_stopped104_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_ready108_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_endrx110_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (280..=299, 281..=300) => {
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_end118_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_txdsent11c_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 292 && _end > 288 {
                    let _offset_start = 288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_endtx120_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 296 && _end > 292 {
                    let _offset_start = 292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_error124_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 300 && _end > 296 {
                    let _offset_start = 296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_acquired128_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    let _offset_start = 312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(316);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_bb138_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (328..=339, 329..=340) => {
                if _start < 332 && _end > 328 {
                    let _offset_start = 328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(332);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_suspended148_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 336 && _end > 332 {
                    let _offset_start = 332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_started14c_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 340 && _end > 336 {
                    let _offset_start = 336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(340);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_txstarted150_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (348..=363, 349..=364) => {
                if _start < 352 && _end > 348 {
                    let _offset_start = 348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(352);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_lastrx15c_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 356 && _end > 352 {
                    let _offset_start = 352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(356);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_lasttx160_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 360 && _end > 356 {
                    let _offset_start = 356u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(360);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(356);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_write164_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 364 && _end > 360 {
                    let _offset_start = 360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(364);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_events_read168_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_shorts200_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_inten300_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_intenset304_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_intenclr308_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1024..=1027, 1025..=1028) => {
                return Err(MemError::WriteViolation);
            }
            (1088..=1091, 1089..=1092) => {
                if _start < 1092 && _end > 1088 {
                    let _offset_start = 1088u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1092);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1088);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_status440_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1220..=1223, 1221..=1224) => {
                if _start < 1224 && _end > 1220 {
                    let _offset_start = 1220u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1224);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1220);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_errorsrc4c4_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1232..=1239, 1233..=1240) => {
                if _start < 1236 && _end > 1232 {
                    let _offset_start = 1232u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1236);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1232);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_errorsrc4d0_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 1240 && _end > 1236 {
                    return Err(MemError::WriteViolation);
                }
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_enable500_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1304 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_psel_sck0_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_psel_miso4_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_psel_mosi8_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_psel_csnc_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_txd51c_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_frequency524_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1332..=1367, 1333..=1368) => {
                if _start < 1348 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_rxd_ptr0_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_rxd_maxcnt4_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                    if _start < 12 && _end > 8 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_rxd_listc_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                }
                if _start < 1364 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_txd_ptr0_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_txd_maxcnt4_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                    if _start < 12 && _end > 8 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0.lock().unwrap().apb3_txd_listc_write(
                            _instance_page,
                            _start,
                            _buf,
                        )?;
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_config554_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _offset_start = 1372u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1376);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1372);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_def55c_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1416..=1423, 1417..=1424) => {
                if _start < 1424 && _end > 1416 {
                    let _offset_start = 1416u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1424);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1416);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0.lock().unwrap().apb3_addressn588_write(
                                _instance_page,
                                _dim,
                                _start,
                                _buf,
                            )?;
                        }
                    }
                }
            }
            (1428..=1431, 1429..=1432) => {
                if _start < 1432 && _end > 1428 {
                    let _offset_start = 1428u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1432);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1428);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_config594_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1472..=1475, 1473..=1476) => {
                if _start < 1476 && _end > 1472 {
                    let _offset_start = 1472u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1476);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1472);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb3_orc5c0_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Nfct(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Nfct {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::nfct::Nfct::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                return Err(MemError::ReadViolation);
            }
            (28..=31, 29..=32) => {
                return Err(MemError::ReadViolation);
            }
            (36..=43, 37..=44) => {
                return Err(MemError::ReadViolation);
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_ready100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_fielddetected104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_fieldlost108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_txframestart10c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_txframeend110_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_rxframestart114_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_rxframeend118_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_error11c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (296..=307, 297..=308) => {
                if _start < 300 && _end > 296 {
                    let _offset_start = 296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_rxerror128_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 304 && _end > 300 {
                    let _offset_start = 300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_endrx12c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 308 && _end > 304 {
                    let _offset_start = 304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_endtx130_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    let _offset_start = 312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(316);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_autocolresstarted138_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (328..=339, 329..=340) => {
                if _start < 332 && _end > 328 {
                    let _offset_start = 328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(332);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_collision148_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 336 && _end > 332 {
                    let _offset_start = 332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_selected14c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 340 && _end > 336 {
                    let _offset_start = 336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(340);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_events_started150_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_shorts200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_inten300_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1028..=1031, 1029..=1032) => {
                if _start < 1032 && _end > 1028 {
                    let _offset_start = 1028u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1032);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1028);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_errorstatus404_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1036..=1039, 1037..=1040) => {
                if _start < 1040 && _end > 1036 {
                    let _offset_start = 1036u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1040);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1036);
                    let _end = (_start + _buf.len() as u64).max(4);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .nfct_framestatus_rx0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1072..=1075, 1073..=1076) => {
                if _start < 1076 && _end > 1072 {
                    let _offset_start = 1072u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1076);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1072);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_currentloadctrl430_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1084..=1087, 1085..=1088) => {
                if _start < 1088 && _end > 1084 {
                    let _offset_start = 1084u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1088);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1084);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_fieldpresent43c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1319, 1285..=1320) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_framedelaymin504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_framedelaymax508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_framedelaymode50c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_packetptr510_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_maxlen514_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1312 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(8);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .nfct_txd_frameconfig0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .nfct_txd_amount4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1320 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(8);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .nfct_rxd_frameconfig0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .nfct_rxd_amount4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1424..=1435, 1425..=1436) => {
                if _start < 1428 && _end > 1424 {
                    let _offset_start = 1424u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1428);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1424);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_nfcid1_last590_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1432 && _end > 1428 {
                    let _offset_start = 1428u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1432);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1428);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_nfcid1_2nd_last594_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1436 && _end > 1432 {
                    let _offset_start = 1432u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1436);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1432);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_nfcid1_3rd_last598_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1440..=1447, 1441..=1448) => {
                if _start < 1444 && _end > 1440 {
                    let _offset_start = 1440u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1444);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1440);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_sensres5a0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1448 && _end > 1444 {
                    let _offset_start = 1444u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1448);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1444);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nfct_selres5a4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::nfct::Nfct::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_tasks_activate0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_tasks_disable4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_tasks_sense8_write(_start, _buf)?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_tasks_starttxc_write(_start, _buf)?;
                }
            }
            (28..=31, 29..=32) => {
                if _start < 32 && _end > 28 {
                    let _offset_start = 28u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(32);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(28);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_tasks_enablerxdata1c_write(_start, _buf)?;
                }
            }
            (36..=43, 37..=44) => {
                if _start < 40 && _end > 36 {
                    let _offset_start = 36u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(40);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(36);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_tasks_goidle24_write(_start, _buf)?;
                }
                if _start < 44 && _end > 40 {
                    let _offset_start = 40u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(44);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(40);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_tasks_gosleep28_write(_start, _buf)?;
                }
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_ready100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_fielddetected104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_fieldlost108_write(_start, _buf)?;
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_txframestart10c_write(_start, _buf)?;
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_txframeend110_write(_start, _buf)?;
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_rxframestart114_write(_start, _buf)?;
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_rxframeend118_write(_start, _buf)?;
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_error11c_write(_start, _buf)?;
                }
            }
            (296..=307, 297..=308) => {
                if _start < 300 && _end > 296 {
                    let _offset_start = 296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_rxerror128_write(_start, _buf)?;
                }
                if _start < 304 && _end > 300 {
                    let _offset_start = 300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_endrx12c_write(_start, _buf)?;
                }
                if _start < 308 && _end > 304 {
                    let _offset_start = 304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(308);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_endtx130_write(_start, _buf)?;
                }
            }
            (312..=315, 313..=316) => {
                if _start < 316 && _end > 312 {
                    let _offset_start = 312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(316);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_autocolresstarted138_write(_start, _buf)?;
                }
            }
            (328..=339, 329..=340) => {
                if _start < 332 && _end > 328 {
                    let _offset_start = 328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(332);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_collision148_write(_start, _buf)?;
                }
                if _start < 336 && _end > 332 {
                    let _offset_start = 332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_selected14c_write(_start, _buf)?;
                }
                if _start < 340 && _end > 336 {
                    let _offset_start = 336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(340);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_events_started150_write(_start, _buf)?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_shorts200_write(_start, _buf)?;
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().nfct_inten300_write(_start, _buf)?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_intenclr308_write(_start, _buf)?;
                }
            }
            (1028..=1031, 1029..=1032) => {
                if _start < 1032 && _end > 1028 {
                    let _offset_start = 1028u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1032);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1028);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_errorstatus404_write(_start, _buf)?;
                }
            }
            (1036..=1039, 1037..=1040) => {
                if _start < 1040 && _end > 1036 {
                    let _offset_start = 1036u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1040);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1036);
                    let _end = (_start + _buf.len() as u64).max(4);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .nfct_framestatus_rx0_write(_start, _buf)?;
                    }
                }
            }
            (1072..=1075, 1073..=1076) => {
                return Err(MemError::WriteViolation);
            }
            (1084..=1087, 1085..=1088) => {
                return Err(MemError::WriteViolation);
            }
            (1284..=1319, 1285..=1320) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_framedelaymin504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_framedelaymax508_write(_start, _buf)?;
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_framedelaymode50c_write(_start, _buf)?;
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_packetptr510_write(_start, _buf)?;
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_maxlen514_write(_start, _buf)?;
                }
                if _start < 1312 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(8);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .nfct_txd_frameconfig0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .nfct_txd_amount4_write(_start, _buf)?;
                    }
                }
                if _start < 1320 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(8);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .nfct_rxd_frameconfig0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        return Err(MemError::WriteViolation);
                    }
                }
            }
            (1424..=1435, 1425..=1436) => {
                if _start < 1428 && _end > 1424 {
                    let _offset_start = 1424u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1428);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1424);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_nfcid1_last590_write(_start, _buf)?;
                }
                if _start < 1432 && _end > 1428 {
                    let _offset_start = 1428u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1432);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1428);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_nfcid1_2nd_last594_write(_start, _buf)?;
                }
                if _start < 1436 && _end > 1432 {
                    let _offset_start = 1432u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1436);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1432);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_nfcid1_3rd_last598_write(_start, _buf)?;
                }
            }
            (1440..=1447, 1441..=1448) => {
                if _start < 1444 && _end > 1440 {
                    let _offset_start = 1440u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1444);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1440);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_sensres5a0_write(_start, _buf)?;
                }
                if _start < 1448 && _end > 1444 {
                    let _offset_start = 1444u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1448);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1444);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nfct_selres5a4_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Gpiote(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Gpiote {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::p0::P0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=31, 1..=32) => {
                return Err(MemError::ReadViolation);
            }
            (48..=79, 49..=80) => {
                return Err(MemError::ReadViolation);
            }
            (96..=127, 97..=128) => {
                return Err(MemError::ReadViolation);
            }
            (256..=287, 257..=288) => {
                if _start < 288 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .gpiote_events_inn100_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (380..=383, 381..=384) => {
                if _start < 384 && _end > 380 {
                    let _offset_start = 380u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(384);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(380);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .gpiote_events_port17c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .gpiote_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .gpiote_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1296..=1327, 1297..=1328) => {
                if _start < 1328 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1328);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .gpiote_confign510_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::p0::P0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=31, 1..=32) => {
                if _start < 32 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(32);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .gpiote_tasks_outn0_write(_dim, _start, _buf)?;
                        }
                    }
                }
            }
            (48..=79, 49..=80) => {
                if _start < 80 && _end > 48 {
                    let _offset_start = 48u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(80);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(48);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0.lock().unwrap().gpiote_tasks_setn30_write(
                                _dim, _start, _buf,
                            )?;
                        }
                    }
                }
            }
            (96..=127, 97..=128) => {
                if _start < 128 && _end > 96 {
                    let _offset_start = 96u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(128);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(96);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0.lock().unwrap().gpiote_tasks_clrn60_write(
                                _dim, _start, _buf,
                            )?;
                        }
                    }
                }
            }
            (256..=287, 257..=288) => {
                if _start < 288 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0.lock().unwrap().gpiote_events_inn100_write(
                                _dim, _start, _buf,
                            )?;
                        }
                    }
                }
            }
            (380..=383, 381..=384) => {
                if _start < 384 && _end > 380 {
                    let _offset_start = 380u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(384);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(380);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .gpiote_events_port17c_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .gpiote_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .gpiote_intenclr308_write(_start, _buf)?;
                }
            }
            (1296..=1327, 1297..=1328) => {
                if _start < 1328 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1328);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .gpiote_confign510_write(_dim, _start, _buf)?;
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Saadc(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Saadc {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::saadc::Saadc::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                return Err(MemError::ReadViolation);
            }
            (256..=343, 257..=344) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_events_started100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_events_end104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_events_done108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_events_resultdone10c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_events_calibratedone110_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_events_stopped114_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 344 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(344);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(64);
                    for _events_chn in 0..8usize {
                        let _dim_offset = _events_chn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .saadc_events_chn_limith0_read(
                                            _events_chn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .saadc_events_chn_limitl4_read(
                                            _events_chn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_inten300_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_status400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_enable500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1296..=1423, 1297..=1424) => {
                if _start < 1424 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1424);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(128);
                    for _chn in 0..8usize {
                        let _dim_offset = _chn as u64 * 16;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 16;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(16);
                            if _start < 16 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .saadc_chn_pselp0_read(_chn as usize)?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .saadc_chn_pseln4_read(_chn as usize)?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 12 && _end > 8 {
                                    let _offset_start =
                                        8u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(12);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(8);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .saadc_chn_config8_read(_chn as usize)?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 16 && _end > 12 {
                                    let _offset_start =
                                        12u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(16);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(12);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .saadc_chn_limitc_read(_chn as usize)?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            (1520..=1531, 1521..=1532) => {
                if _start < 1524 && _end > 1520 {
                    let _offset_start = 1520u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1524);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1520);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_resolution5f0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1528 && _end > 1524 {
                    let _offset_start = 1524u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1528);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1524);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_oversample5f4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1532 && _end > 1528 {
                    let _offset_start = 1528u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1532);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1528);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .saadc_samplerate5f8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1580..=1591, 1581..=1592) => {
                if _start < 1592 && _end > 1580 {
                    let _offset_start = 1580u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1592);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1580);
                    let _end = (_start + _buf.len() as u64).max(12);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .saadc_result_ptr0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .saadc_result_maxcnt4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .saadc_result_amount8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::saadc::Saadc::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_tasks_start0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_tasks_sample4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_tasks_stop8_write(_start, _buf)?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_tasks_calibrateoffsetc_write(_start, _buf)?;
                }
            }
            (256..=343, 257..=344) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_events_started100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_events_end104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_events_done108_write(_start, _buf)?;
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_events_resultdone10c_write(_start, _buf)?;
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_events_calibratedone110_write(_start, _buf)?;
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_events_stopped114_write(_start, _buf)?;
                }
                if _start < 344 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(344);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(64);
                    for _events_chn in 0..8usize {
                        let _dim_offset = _events_chn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .saadc_events_chn_limith0_write(
                                            _events_chn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .saadc_events_chn_limitl4_write(
                                            _events_chn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_inten300_write(_start, _buf)?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_intenclr308_write(_start, _buf)?;
                }
            }
            (1024..=1027, 1025..=1028) => {
                return Err(MemError::WriteViolation);
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_enable500_write(_start, _buf)?;
                }
            }
            (1296..=1423, 1297..=1424) => {
                if _start < 1424 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1424);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(128);
                    for _chn in 0..8usize {
                        let _dim_offset = _chn as u64 * 16;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 16;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(16);
                            if _start < 16 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .saadc_chn_pselp0_write(
                                            _chn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .saadc_chn_pseln4_write(
                                            _chn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 12 && _end > 8 {
                                    let _offset_start =
                                        8u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(12);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(8);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .saadc_chn_config8_write(
                                            _chn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 16 && _end > 12 {
                                    let _offset_start =
                                        12u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(16);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(12);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .saadc_chn_limitc_write(
                                            _chn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            (1520..=1531, 1521..=1532) => {
                if _start < 1524 && _end > 1520 {
                    let _offset_start = 1520u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1524);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1520);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_resolution5f0_write(_start, _buf)?;
                }
                if _start < 1528 && _end > 1524 {
                    let _offset_start = 1524u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1528);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1524);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_oversample5f4_write(_start, _buf)?;
                }
                if _start < 1532 && _end > 1528 {
                    let _offset_start = 1528u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1532);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1528);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .saadc_samplerate5f8_write(_start, _buf)?;
                }
            }
            (1580..=1591, 1581..=1592) => {
                if _start < 1592 && _end > 1580 {
                    let _offset_start = 1580u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1592);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1580);
                    let _end = (_start + _buf.len() as u64).max(12);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .saadc_result_ptr0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .saadc_result_maxcnt4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        return Err(MemError::WriteViolation);
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Timer0(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Timer0 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::timer0::Timer0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                return Err(MemError::ReadViolation);
            }
            (64..=79, 65..=80) => {
                return Err(MemError::ReadViolation);
            }
            (320..=335, 321..=336) => {
                if _start < 336 && _end > 320 {
                    let _offset_start = 320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .timer0_events_comparen140_read(
                                    _instance_page,
                                    _dim,
                                )?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer0_shorts200_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer0_intenset304_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer0_intenclr308_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer0_mode504_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer0_bitmode508_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer0_prescaler510_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1360 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .timer0_ccn540_read(_instance_page, _dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::timer0::Timer0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_tasks_start0_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_tasks_stop4_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_tasks_count8_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_tasks_clearc_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_tasks_shutdown10_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (64..=79, 65..=80) => {
                if _start < 80 && _end > 64 {
                    let _offset_start = 64u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(80);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(64);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .timer0_tasks_capturen40_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
            }
            (320..=335, 321..=336) => {
                if _start < 336 && _end > 320 {
                    let _offset_start = 320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .timer0_events_comparen140_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_shorts200_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_intenset304_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_intenclr308_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_mode504_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_bitmode508_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer0_prescaler510_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1360 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0.lock().unwrap().timer0_ccn540_write(
                                _instance_page,
                                _dim,
                                _start,
                                _buf,
                            )?;
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Rtc0(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Rtc0 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::rtc0::Rtc0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                return Err(MemError::ReadViolation);
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_events_tick100_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_events_ovrflw104_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (320..=335, 321..=336) => {
                if _start < 336 && _end > 320 {
                    let _offset_start = 320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .rtc0_events_comparen140_read(
                                    _instance_page,
                                    _dim,
                                )?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_intenset304_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_intenclr308_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (832..=843, 833..=844) => {
                if _start < 836 && _end > 832 {
                    let _offset_start = 832u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(836);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(832);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_evten340_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 840 && _end > 836 {
                    let _offset_start = 836u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(840);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(836);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_evtenset344_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 844 && _end > 840 {
                    let _offset_start = 840u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(844);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(840);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_evtenclr348_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_counter504_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rtc0_prescaler508_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1360 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .rtc0_ccn540_read(_instance_page, _dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::rtc0::Rtc0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=15, 1..=16) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_tasks_start0_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_tasks_stop4_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_tasks_clear8_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_tasks_trigovrflwc_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_events_tick100_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_events_ovrflw104_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (320..=335, 321..=336) => {
                if _start < 336 && _end > 320 {
                    let _offset_start = 320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .rtc0_events_comparen140_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_intenset304_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_intenclr308_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (832..=843, 833..=844) => {
                if _start < 836 && _end > 832 {
                    let _offset_start = 832u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(836);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(832);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_evten340_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 840 && _end > 836 {
                    let _offset_start = 836u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(840);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(836);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_evtenset344_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 844 && _end > 840 {
                    let _offset_start = 840u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(844);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(840);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_evtenclr348_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rtc0_prescaler508_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1344..=1359, 1345..=1360) => {
                if _start < 1360 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..4usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0.lock().unwrap().rtc0_ccn540_write(
                                _instance_page,
                                _dim,
                                _start,
                                _buf,
                            )?;
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Temp(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Temp {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::temp::Temp::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                return Err(MemError::ReadViolation);
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .temp_events_datardy100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .temp_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .temp_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1288..=1291, 1289..=1292) => {
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .temp_temp508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1312..=1335, 1313..=1336) => {
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_a0520_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_a1524_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _offset_start = 1320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1324);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_a2528_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1328 && _end > 1324 {
                    let _offset_start = 1324u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1328);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1324);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_a352c_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1332 && _end > 1328 {
                    let _offset_start = 1328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1332);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_a4530_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_a5534_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1344..=1367, 1345..=1368) => {
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_b0540_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1352);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_b1544_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _offset_start = 1352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1356);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_b2548_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _offset_start = 1356u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1356);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_b354c_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1364 && _end > 1360 {
                    let _offset_start = 1360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_b4550_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_b5554_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1376..=1395, 1377..=1396) => {
                if _start < 1380 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1380);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_t0560_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1384 && _end > 1380 {
                    let _offset_start = 1380u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1384);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1380);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_t1564_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1388 && _end > 1384 {
                    let _offset_start = 1384u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1388);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1384);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_t2568_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1392 && _end > 1388 {
                    let _offset_start = 1388u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1392);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1388);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_t356c_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1396 && _end > 1392 {
                    let _offset_start = 1392u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1396);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1392);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().temp_t4570_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::temp::Temp::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .temp_tasks_start0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .temp_tasks_stop4_write(_start, _buf)?;
                }
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .temp_events_datardy100_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .temp_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .temp_intenclr308_write(_start, _buf)?;
                }
            }
            (1288..=1291, 1289..=1292) => {
                return Err(MemError::WriteViolation);
            }
            (1312..=1335, 1313..=1336) => {
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_a0520_write(_start, _buf)?;
                }
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_a1524_write(_start, _buf)?;
                }
                if _start < 1324 && _end > 1320 {
                    let _offset_start = 1320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1324);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_a2528_write(_start, _buf)?;
                }
                if _start < 1328 && _end > 1324 {
                    let _offset_start = 1324u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1328);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1324);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_a352c_write(_start, _buf)?;
                }
                if _start < 1332 && _end > 1328 {
                    let _offset_start = 1328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1332);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_a4530_write(_start, _buf)?;
                }
                if _start < 1336 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_a5534_write(_start, _buf)?;
                }
            }
            (1344..=1367, 1345..=1368) => {
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_b0540_write(_start, _buf)?;
                }
                if _start < 1352 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1352);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_b1544_write(_start, _buf)?;
                }
                if _start < 1356 && _end > 1352 {
                    let _offset_start = 1352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1356);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_b2548_write(_start, _buf)?;
                }
                if _start < 1360 && _end > 1356 {
                    let _offset_start = 1356u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1356);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_b354c_write(_start, _buf)?;
                }
                if _start < 1364 && _end > 1360 {
                    let _offset_start = 1360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_b4550_write(_start, _buf)?;
                }
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_b5554_write(_start, _buf)?;
                }
            }
            (1376..=1395, 1377..=1396) => {
                if _start < 1380 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1380);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_t0560_write(_start, _buf)?;
                }
                if _start < 1384 && _end > 1380 {
                    let _offset_start = 1380u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1384);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1380);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_t1564_write(_start, _buf)?;
                }
                if _start < 1388 && _end > 1384 {
                    let _offset_start = 1384u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1388);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1384);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_t2568_write(_start, _buf)?;
                }
                if _start < 1392 && _end > 1388 {
                    let _offset_start = 1388u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1392);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1388);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_t356c_write(_start, _buf)?;
                }
                if _start < 1396 && _end > 1392 {
                    let _offset_start = 1392u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1396);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1392);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().temp_t4570_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Rng(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Rng {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::rng::Rng::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                return Err(MemError::ReadViolation);
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rng_events_valrdy100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rng_shorts200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rng_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rng_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rng_config504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .rng_value508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::rng::Rng::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .rng_tasks_start0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .rng_tasks_stop4_write(_start, _buf)?;
                }
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .rng_events_valrdy100_write(_start, _buf)?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rng_shorts200_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .rng_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .rng_intenclr308_write(_start, _buf)?;
                }
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().rng_config504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    return Err(MemError::WriteViolation);
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Ecb(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Ecb {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::ecb::Ecb::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                return Err(MemError::ReadViolation);
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ecb_events_endecb100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ecb_events_errorecb104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ecb_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ecb_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1287, 1285..=1288) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ecb_ecbdataptr504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::ecb::Ecb::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ecb_tasks_startecb0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ecb_tasks_stopecb4_write(_start, _buf)?;
                }
            }
            (256..=263, 257..=264) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ecb_events_endecb100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ecb_events_errorecb104_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ecb_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ecb_intenclr308_write(_start, _buf)?;
                }
            }
            (1284..=1287, 1285..=1288) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ecb_ecbdataptr504_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Apb15(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Apb15 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb15::Apb15::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                return Err(MemError::ReadViolation);
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_events_endksgen100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_events_endcrypt104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_events_error108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_shorts200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_micstatus400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_enable500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_mode504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_cnfptr508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_inptr50c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_outptr510_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb15_scratchptr514_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb15::Apb15::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_tasks_start0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_tasks_crypt4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_tasks_stop8_write(_start, _buf)?;
                }
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_events_endksgen100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_events_endcrypt104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_events_error108_write(_start, _buf)?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_shorts200_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_intenclr308_write(_start, _buf)?;
                }
            }
            (1024..=1027, 1025..=1028) => {
                return Err(MemError::WriteViolation);
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_enable500_write(_start, _buf)?;
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb15_mode504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_cnfptr508_write(_start, _buf)?;
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_inptr50c_write(_start, _buf)?;
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_outptr510_write(_start, _buf)?;
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb15_scratchptr514_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Wdt(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Wdt {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::wdt::Wdt::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                return Err(MemError::ReadViolation);
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .wdt_events_timeout100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .wdt_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .wdt_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1031, 1025..=1032) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .wdt_runstatus400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1032 && _end > 1028 {
                    let _offset_start = 1028u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1032);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1028);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .wdt_reqstatus404_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1295, 1285..=1296) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().wdt_crv504_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .wdt_rren508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .wdt_config50c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1536..=1567, 1537..=1568) => {
                return Err(MemError::ReadViolation);
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::wdt::Wdt::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .wdt_tasks_start0_write(_start, _buf)?;
                }
            }
            (256..=259, 257..=260) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .wdt_events_timeout100_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .wdt_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .wdt_intenclr308_write(_start, _buf)?;
                }
            }
            (1024..=1031, 1025..=1032) => {
                return Err(MemError::WriteViolation);
            }
            (1284..=1295, 1285..=1296) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().wdt_crv504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().wdt_rren508_write(_start, _buf)?;
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().wdt_config50c_write(_start, _buf)?;
                }
            }
            (1536..=1567, 1537..=1568) => {
                if _start < 1568 && _end > 1536 {
                    let _offset_start = 1536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1568);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1536);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..8usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .wdt_rrn600_write(_dim, _start, _buf)?;
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Qdec(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Qdec {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::qdec::Qdec::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                return Err(MemError::ReadViolation);
            }
            (256..=275, 257..=276) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_events_samplerdy100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_events_reportrdy104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_events_accof108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_events_dblrdy10c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_events_stopped110_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_shorts200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_enable500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_ledpol504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_sampleper508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_sample50c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_reportper510_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_acc514_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_accread518_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1320 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(12);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .qdec_psel_led0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .qdec_psel_a4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .qdec_psel_b8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _offset_start = 1320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1324);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_dbfen528_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1344..=1355, 1345..=1356) => {
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_ledpre540_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1352 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1352);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_accdbl544_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1356 && _end > 1352 {
                    let _offset_start = 1352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1356);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .qdec_accdblread548_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::qdec::Qdec::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_tasks_start0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_tasks_stop4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_tasks_readclracc8_write(_start, _buf)?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_tasks_rdclraccc_write(_start, _buf)?;
                }
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_tasks_rdclrdbl10_write(_start, _buf)?;
                }
            }
            (256..=275, 257..=276) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_events_samplerdy100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_events_reportrdy104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_events_accof108_write(_start, _buf)?;
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_events_dblrdy10c_write(_start, _buf)?;
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_events_stopped110_write(_start, _buf)?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_shorts200_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_intenclr308_write(_start, _buf)?;
                }
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_enable500_write(_start, _buf)?;
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_ledpol504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_sampleper508_write(_start, _buf)?;
                }
                if _start < 1296 && _end > 1292 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_reportper510_write(_start, _buf)?;
                }
                if _start < 1304 && _end > 1300 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1320 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(12);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .qdec_psel_led0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .qdec_psel_a4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .qdec_psel_b8_write(_start, _buf)?;
                    }
                }
                if _start < 1324 && _end > 1320 {
                    let _offset_start = 1320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1324);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().qdec_dbfen528_write(_start, _buf)?;
                }
            }
            (1344..=1355, 1345..=1356) => {
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .qdec_ledpre540_write(_start, _buf)?;
                }
                if _start < 1352 && _end > 1348 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1356 && _end > 1352 {
                    return Err(MemError::WriteViolation);
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Apb19(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Apb19 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb19::Apb19::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                return Err(MemError::ReadViolation);
            }
            (256..=271, 257..=272) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_events_ready100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_events_down104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_events_up108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_events_cross10c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_shorts200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_inten300_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_result400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1295, 1281..=1296) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_enable500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_psel504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_refsel508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_extrefsel50c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1312..=1315, 1313..=1316) => {
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_anadetect520_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1328..=1343, 1329..=1344) => {
                if _start < 1332 && _end > 1328 {
                    let _offset_start = 1328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1332);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_th530_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1336 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_mode534_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1340 && _end > 1336 {
                    let _offset_start = 1336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1340);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_hyst538_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1344 && _end > 1340 {
                    let _offset_start = 1340u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1344);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1340);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb19_isource53c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb19::Apb19::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=11, 1..=12) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_tasks_start0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_tasks_stop4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_tasks_sample8_write(_start, _buf)?;
                }
            }
            (256..=271, 257..=272) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_events_ready100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_events_down104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_events_up108_write(_start, _buf)?;
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_events_cross10c_write(_start, _buf)?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_shorts200_write(_start, _buf)?;
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_inten300_write(_start, _buf)?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_intenclr308_write(_start, _buf)?;
                }
            }
            (1024..=1027, 1025..=1028) => {
                return Err(MemError::WriteViolation);
            }
            (1280..=1295, 1281..=1296) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_enable500_write(_start, _buf)?;
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb19_psel504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_refsel508_write(_start, _buf)?;
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_extrefsel50c_write(_start, _buf)?;
                }
            }
            (1312..=1315, 1313..=1316) => {
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_anadetect520_write(_start, _buf)?;
                }
            }
            (1328..=1343, 1329..=1344) => {
                if _start < 1332 && _end > 1328 {
                    let _offset_start = 1328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1332);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb19_th530_write(_start, _buf)?;
                }
                if _start < 1336 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb19_mode534_write(_start, _buf)?;
                }
                if _start < 1340 && _end > 1336 {
                    let _offset_start = 1336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1340);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb19_hyst538_write(_start, _buf)?;
                }
                if _start < 1344 && _end > 1340 {
                    let _offset_start = 1340u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1344);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1340);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb19_isource53c_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Apb20(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Apb20 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb20::Apb20::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=63, 1..=64) => {
                return Err(MemError::ReadViolation);
            }
            (256..=319, 257..=320) => {
                if _start < 320 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..16usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .apb20_events_triggeredn100_read(
                                    _instance_page,
                                    _dim,
                                )?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb20_inten300_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb20_intenset304_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb20_intenclr308_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb20::Apb20::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=63, 1..=64) => {
                if _start < 64 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(64);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..16usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .apb20_tasks_triggern0_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
            }
            (256..=319, 257..=320) => {
                if _start < 320 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..16usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .apb20_events_triggeredn100_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb20_inten300_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb20_intenset304_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb20_intenclr308_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Timer3(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Timer3 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::timer3::Timer3::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                return Err(MemError::ReadViolation);
            }
            (64..=87, 65..=88) => {
                return Err(MemError::ReadViolation);
            }
            (320..=343, 321..=344) => {
                if _start < 344 && _end > 320 {
                    let _offset_start = 320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(344);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..6usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .timer3_events_comparen140_read(
                                    _instance_page,
                                    _dim,
                                )?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer3_shorts200_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer3_intenset304_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer3_intenclr308_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer3_mode504_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer3_bitmode508_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .timer3_prescaler510_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1344..=1367, 1345..=1368) => {
                if _start < 1368 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..6usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .timer3_ccn540_read(_instance_page, _dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::timer3::Timer3::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=19, 1..=20) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_tasks_start0_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_tasks_stop4_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_tasks_count8_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_tasks_clearc_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_tasks_shutdown10_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (64..=87, 65..=88) => {
                if _start < 88 && _end > 64 {
                    let _offset_start = 64u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(88);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(64);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..6usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .timer3_tasks_capturen40_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
            }
            (320..=343, 321..=344) => {
                if _start < 344 && _end > 320 {
                    let _offset_start = 320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(344);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(320);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..6usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .timer3_events_comparen140_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_shorts200_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_intenset304_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_intenclr308_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1284..=1291, 1285..=1292) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_mode504_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_bitmode508_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1296..=1299, 1297..=1300) => {
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().timer3_prescaler510_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1344..=1367, 1345..=1368) => {
                if _start < 1368 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..6usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0.lock().unwrap().timer3_ccn540_write(
                                _instance_page,
                                _dim,
                                _start,
                                _buf,
                            )?;
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Pwm0(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Pwm0 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::pwm0::Pwm0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=19, 5..=20) => {
                return Err(MemError::ReadViolation);
            }
            (260..=287, 261..=288) => {
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_events_stopped104_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 272 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .pwm0_events_seqstartedn108_read(
                                    _instance_page,
                                    _dim,
                                )?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 280 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .pwm0_events_seqendn110_read(
                                    _instance_page,
                                    _dim,
                                )?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_events_pwmperiodend118_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_events_loopsdone11c_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_shorts200_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_inten300_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_intenset304_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_intenclr308_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_enable500_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_mode504_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_countertop508_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_prescaler50c_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_decoder510_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pwm0_loop514_read(_instance_page)?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1312..=1391, 1313..=1392) => {
                if _start < 1376 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1376);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(64);
                    for _seqn in 0..2usize {
                        let _dim_offset = _seqn as u64 * 32;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 32;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(32);
                            if _start < 16 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .pwm0_seqn_ptr0_read(
                                            _instance_page,
                                            _seqn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .pwm0_seqn_cnt4_read(
                                            _instance_page,
                                            _seqn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 12 && _end > 8 {
                                    let _offset_start =
                                        8u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(12);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(8);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .pwm0_seqn_refresh8_read(
                                            _instance_page,
                                            _seqn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 16 && _end > 12 {
                                    let _offset_start =
                                        12u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(16);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(12);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .pwm0_seqn_enddelayc_read(
                                            _instance_page,
                                            _seqn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
                if _start < 1392 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1392);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 16 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        for _dim in 0..4usize {
                            let _dim_offset = _dim as u64 * 4;
                            let _reg_start = _dim_offset;
                            let _reg_end = _reg_start + 4;
                            if _start < _reg_end && _end > _reg_start {
                                let _offset_start =
                                    _reg_start.saturating_sub(_start);
                                let _offset_end = _buf.len() as u64
                                    - _end.saturating_sub(_reg_end);
                                let _buf = &mut _buf[_offset_start as usize
                                    .._offset_end as usize];
                                let _start = _start.saturating_sub(_reg_start);
                                let _end = (_end - _reg_end).min(4);
                                let _end = (_start + _buf.len() as u64).max(4);
                                let value = self
                                    .0
                                    .lock()
                                    .unwrap()
                                    .pwm0_psel_outn0_read(_instance_page, _dim)?
                                    .to_ne_bytes();
                                for _byte in _start.._end {
                                    _buf[_byte as usize] =
                                        value[_byte as usize];
                                }
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::pwm0::Pwm0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=19, 5..=20) => {
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_tasks_stop4_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 16 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .pwm0_tasks_seqstartn8_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_tasks_nextstep10_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (260..=287, 261..=288) => {
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_events_stopped104_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 272 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .pwm0_events_seqstartedn108_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
                if _start < 280 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..2usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .pwm0_events_seqendn110_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                        }
                    }
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_events_pwmperiodend118_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_events_loopsdone11c_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_shorts200_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_inten300_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_intenset304_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_intenclr308_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1280..=1303, 1281..=1304) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_enable500_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_mode504_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_countertop508_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_prescaler50c_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_decoder510_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pwm0_loop514_write(
                        _instance_page,
                        _start,
                        _buf,
                    )?;
                }
            }
            (1312..=1391, 1313..=1392) => {
                if _start < 1376 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1376);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(64);
                    for _seqn in 0..2usize {
                        let _dim_offset = _seqn as u64 * 32;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 32;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(32);
                            if _start < 16 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .pwm0_seqn_ptr0_write(
                                            _instance_page,
                                            _seqn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .pwm0_seqn_cnt4_write(
                                            _instance_page,
                                            _seqn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 12 && _end > 8 {
                                    let _offset_start =
                                        8u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(12);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(8);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .pwm0_seqn_refresh8_write(
                                            _instance_page,
                                            _seqn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 16 && _end > 12 {
                                    let _offset_start =
                                        12u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(16);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(12);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .pwm0_seqn_enddelayc_write(
                                            _instance_page,
                                            _seqn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
                if _start < 1392 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1392);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 16 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        for _dim in 0..4usize {
                            let _dim_offset = _dim as u64 * 4;
                            let _reg_start = _dim_offset;
                            let _reg_end = _reg_start + 4;
                            if _start < _reg_end && _end > _reg_start {
                                let _offset_start =
                                    _reg_start.saturating_sub(_start);
                                let _offset_end = _buf.len() as u64
                                    - _end.saturating_sub(_reg_end);
                                let _buf = &_buf[_offset_start as usize
                                    .._offset_end as usize];
                                let _start = _start.saturating_sub(_reg_start);
                                let _end = (_end - _reg_end).min(4);
                                let _end = (_start + _buf.len() as u64).max(4);
                                self.0.lock().unwrap().pwm0_psel_outn0_write(
                                    _instance_page,
                                    _dim,
                                    _start,
                                    _buf,
                                )?;
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Pdm(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Pdm {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::pdm::Pdm::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                return Err(MemError::ReadViolation);
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_events_started100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_events_stopped104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_events_end108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_inten300_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_enable500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_pdmclkctrl504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_mode508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1304..=1311, 1305..=1312) => {
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_gainl518_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .pdm_gainr51c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1344..=1351, 1345..=1352) => {
                if _start < 1352 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1352);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(8);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .pdm_psel_clk0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .pdm_psel_din4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1376..=1383, 1377..=1384) => {
                if _start < 1384 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1384);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(8);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .pdm_sample_ptr0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .pdm_sample_maxcnt4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::pdm::Pdm::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .pdm_tasks_start0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .pdm_tasks_stop4_write(_start, _buf)?;
                }
            }
            (256..=267, 257..=268) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .pdm_events_started100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .pdm_events_stopped104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .pdm_events_end108_write(_start, _buf)?;
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pdm_inten300_write(_start, _buf)?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .pdm_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .pdm_intenclr308_write(_start, _buf)?;
                }
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pdm_enable500_write(_start, _buf)?;
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .pdm_pdmclkctrl504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pdm_mode508_write(_start, _buf)?;
                }
            }
            (1304..=1311, 1305..=1312) => {
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pdm_gainl518_write(_start, _buf)?;
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().pdm_gainr51c_write(_start, _buf)?;
                }
            }
            (1344..=1351, 1345..=1352) => {
                if _start < 1352 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1352);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(8);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .pdm_psel_clk0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .pdm_psel_din4_write(_start, _buf)?;
                    }
                }
            }
            (1376..=1383, 1377..=1384) => {
                if _start < 1384 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1384);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(8);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .pdm_sample_ptr0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .pdm_sample_maxcnt4_write(_start, _buf)?;
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Nvmc(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Nvmc {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::nvmc::Nvmc::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_ready400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1284..=1303, 1285..=1304) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_config504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_erasepage508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_eraseall50c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_erasepcr0510_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_eraseuicr514_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1344..=1347, 1345..=1348) => {
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_icachecnf540_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1352..=1359, 1353..=1360) => {
                if _start < 1356 && _end > 1352 {
                    let _offset_start = 1352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1356);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_ihit548_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1360 && _end > 1356 {
                    let _offset_start = 1356u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1356);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .nvmc_imiss54c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::nvmc::Nvmc::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1024..=1027, 1025..=1028) => {
                return Err(MemError::WriteViolation);
            }
            (1284..=1303, 1285..=1304) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nvmc_config504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nvmc_erasepage508_write(_start, _buf)?;
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nvmc_eraseall50c_write(_start, _buf)?;
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nvmc_erasepcr0510_write(_start, _buf)?;
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nvmc_eraseuicr514_write(_start, _buf)?;
                }
            }
            (1344..=1347, 1345..=1348) => {
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .nvmc_icachecnf540_write(_start, _buf)?;
                }
            }
            (1352..=1359, 1353..=1360) => {
                if _start < 1356 && _end > 1352 {
                    let _offset_start = 1352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1356);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().nvmc_ihit548_write(_start, _buf)?;
                }
                if _start < 1360 && _end > 1356 {
                    let _offset_start = 1356u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1360);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1356);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().nvmc_imiss54c_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Ppi(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Ppi {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::ppi::Ppi::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=47, 1..=48) => {
                return Err(MemError::ReadViolation);
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ppi_chen500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ppi_chenset504_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .ppi_chenclr508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1296..=1455, 1297..=1456) => {
                if _start < 1456 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1456);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(160);
                    for _chn in 0..20usize {
                        let _dim_offset = _chn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .ppi_chn_eep0_read(_chn as usize)?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .ppi_chn_tep4_read(_chn as usize)?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            (2048..=2071, 2049..=2072) => {
                if _start < 2072 && _end > 2048 {
                    let _offset_start = 2048u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(2072);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(2048);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..6usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .ppi_chgn800_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            (2320..=2447, 2321..=2448) => {
                if _start < 2448 && _end > 2320 {
                    let _offset_start = 2320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(2448);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(2320);
                    let _end = (_start + _buf.len() as u64).max(128);
                    for _forkn in 0..32usize {
                        let _dim_offset = _forkn as u64 * 4;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 4;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(4);
                            if _start < 4 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .ppi_forkn_tep0_read(_forkn as usize)?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::ppi::Ppi::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=47, 1..=48) => {
                if _start < 48 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(48);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(48);
                    for _tasks_chgn in 0..6usize {
                        let _dim_offset = _tasks_chgn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .ppi_tasks_chgn_en0_write(
                                            _tasks_chgn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .ppi_tasks_chgn_dis4_write(
                                            _tasks_chgn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            (1280..=1291, 1281..=1292) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().ppi_chen500_write(_start, _buf)?;
                }
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ppi_chenset504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .ppi_chenclr508_write(_start, _buf)?;
                }
            }
            (1296..=1455, 1297..=1456) => {
                if _start < 1456 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1456);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(160);
                    for _chn in 0..20usize {
                        let _dim_offset = _chn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0.lock().unwrap().ppi_chn_eep0_write(
                                        _chn as usize,
                                        _start,
                                        _buf,
                                    )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0.lock().unwrap().ppi_chn_tep4_write(
                                        _chn as usize,
                                        _start,
                                        _buf,
                                    )?;
                                }
                            }
                        }
                    }
                }
            }
            (2048..=2071, 2049..=2072) => {
                if _start < 2072 && _end > 2048 {
                    let _offset_start = 2048u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(2072);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(2048);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..6usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .ppi_chgn800_write(_dim, _start, _buf)?;
                        }
                    }
                }
            }
            (2320..=2447, 2321..=2448) => {
                if _start < 2448 && _end > 2320 {
                    let _offset_start = 2320u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(2448);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(2320);
                    let _end = (_start + _buf.len() as u64).max(128);
                    for _forkn in 0..32usize {
                        let _dim_offset = _forkn as u64 * 4;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 4;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(4);
                            if _start < 4 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .ppi_forkn_tep0_write(
                                            _forkn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Mwu(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Mwu {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::mwu::Mwu::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (256..=287, 257..=288) => {
                if _start < 288 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(32);
                    for _events_regionn in 0..4usize {
                        let _dim_offset = _events_regionn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_events_regionn_wa0_read(
                                            _events_regionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_events_regionn_ra4_read(
                                            _events_regionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            (352..=367, 353..=368) => {
                if _start < 368 && _end > 352 {
                    let _offset_start = 352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(368);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(352);
                    let _end = (_start + _buf.len() as u64).max(16);
                    for _events_pregionn in 0..2usize {
                        let _dim_offset = _events_pregionn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_events_pregionn_wa0_read(
                                            _events_pregionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_events_pregionn_ra4_read(
                                            _events_pregionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_inten300_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (800..=811, 801..=812) => {
                if _start < 804 && _end > 800 {
                    let _offset_start = 800u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(804);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(800);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_nmien320_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 808 && _end > 804 {
                    let _offset_start = 804u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(808);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(804);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_nmienset324_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 812 && _end > 808 {
                    let _offset_start = 808u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(812);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(808);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_nmienclr328_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1039, 1025..=1040) => {
                if _start < 1040 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1040);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(16);
                    for _perregionn in 0..2usize {
                        let _dim_offset = _perregionn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_perregionn_substatwa0_read(
                                            _perregionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_perregionn_substatra4_read(
                                            _perregionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            (1296..=1307, 1297..=1308) => {
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_regionen510_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_regionenset514_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .mwu_regionenclr518_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1536..=1599, 1537..=1600) => {
                if _start < 1600 && _end > 1536 {
                    let _offset_start = 1536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1600);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1536);
                    let _end = (_start + _buf.len() as u64).max(64);
                    for _regionn in 0..4usize {
                        let _dim_offset = _regionn as u64 * 16;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 16;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(16);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_regionn_start0_read(
                                            _regionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_regionn_end4_read(
                                            _regionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            (1728..=1759, 1729..=1760) => {
                if _start < 1760 && _end > 1728 {
                    let _offset_start = 1728u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1760);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1728);
                    let _end = (_start + _buf.len() as u64).max(32);
                    for _pregionn in 0..2usize {
                        let _dim_offset = _pregionn as u64 * 16;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 16;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(16);
                            if _start < 12 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_pregionn_start0_read(
                                            _pregionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_pregionn_end4_read(
                                            _pregionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                                if _start < 12 && _end > 8 {
                                    let _offset_start =
                                        8u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(12);
                                    let _buf = &mut _buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(8);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    let value = self
                                        .0
                                        .lock()
                                        .unwrap()
                                        .mwu_pregionn_subs8_read(
                                            _pregionn as usize,
                                        )?
                                        .to_ne_bytes();
                                    for _byte in _start.._end {
                                        _buf[_byte as usize] =
                                            value[_byte as usize];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::mwu::Mwu::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (256..=287, 257..=288) => {
                if _start < 288 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(32);
                    for _events_regionn in 0..4usize {
                        let _dim_offset = _events_regionn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_events_regionn_wa0_write(
                                            _events_regionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_events_regionn_ra4_write(
                                            _events_regionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            (352..=367, 353..=368) => {
                if _start < 368 && _end > 352 {
                    let _offset_start = 352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(368);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(352);
                    let _end = (_start + _buf.len() as u64).max(16);
                    for _events_pregionn in 0..2usize {
                        let _dim_offset = _events_pregionn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_events_pregionn_wa0_write(
                                            _events_pregionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_events_pregionn_ra4_write(
                                            _events_pregionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().mwu_inten300_write(_start, _buf)?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .mwu_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .mwu_intenclr308_write(_start, _buf)?;
                }
            }
            (800..=811, 801..=812) => {
                if _start < 804 && _end > 800 {
                    let _offset_start = 800u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(804);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(800);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().mwu_nmien320_write(_start, _buf)?;
                }
                if _start < 808 && _end > 804 {
                    let _offset_start = 804u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(808);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(804);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .mwu_nmienset324_write(_start, _buf)?;
                }
                if _start < 812 && _end > 808 {
                    let _offset_start = 808u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(812);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(808);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .mwu_nmienclr328_write(_start, _buf)?;
                }
            }
            (1024..=1039, 1025..=1040) => {
                if _start < 1040 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1040);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(16);
                    for _perregionn in 0..2usize {
                        let _dim_offset = _perregionn as u64 * 8;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 8;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(8);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_perregionn_substatwa0_write(
                                            _perregionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_perregionn_substatra4_write(
                                            _perregionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            (1296..=1307, 1297..=1308) => {
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .mwu_regionen510_write(_start, _buf)?;
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .mwu_regionenset514_write(_start, _buf)?;
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .mwu_regionenclr518_write(_start, _buf)?;
                }
            }
            (1536..=1599, 1537..=1600) => {
                if _start < 1600 && _end > 1536 {
                    let _offset_start = 1536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1600);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1536);
                    let _end = (_start + _buf.len() as u64).max(64);
                    for _regionn in 0..4usize {
                        let _dim_offset = _regionn as u64 * 16;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 16;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(16);
                            if _start < 8 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    let _offset_start =
                                        0u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(4);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(0);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_regionn_start0_write(
                                            _regionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                                if _start < 8 && _end > 4 {
                                    let _offset_start =
                                        4u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(8);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(4);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_regionn_end4_write(
                                            _regionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            (1728..=1759, 1729..=1760) => {
                if _start < 1760 && _end > 1728 {
                    let _offset_start = 1728u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1760);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1728);
                    let _end = (_start + _buf.len() as u64).max(32);
                    for _pregionn in 0..2usize {
                        let _dim_offset = _pregionn as u64 * 16;
                        let _cluster_start = _dim_offset;
                        let _cluster_end = _cluster_start + 16;
                        if _start < _cluster_end && _end > _cluster_start {
                            let _offset_start =
                                _cluster_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_cluster_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_cluster_start);
                            let _end = (_start + _buf.len() as u64).max(16);
                            if _start < 12 && _end > 0 {
                                if _start < 4 && _end > 0 {
                                    return Err(MemError::WriteViolation);
                                }
                                if _start < 8 && _end > 4 {
                                    return Err(MemError::WriteViolation);
                                }
                                if _start < 12 && _end > 8 {
                                    let _offset_start =
                                        8u64.saturating_sub(_start);
                                    let _offset_end = _buf.len() as u64
                                        - _end.saturating_sub(12);
                                    let _buf = &_buf[_offset_start as usize
                                        .._offset_end as usize];
                                    let _start = _start.saturating_sub(8);
                                    let _end =
                                        (_start + _buf.len() as u64).max(4);
                                    self.0
                                        .lock()
                                        .unwrap()
                                        .mwu_pregionn_subs8_write(
                                            _pregionn as usize,
                                            _start,
                                            _buf,
                                        )?;
                                }
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct I2s(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for I2s {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::i2s::I2s::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                return Err(MemError::ReadViolation);
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .i2s_events_rxptrupd104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .i2s_events_stopped108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (276..=279, 277..=280) => {
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .i2s_events_txptrupd114_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .i2s_inten300_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .i2s_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .i2s_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .i2s_enable500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1324 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1324);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(40);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_mode0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_rxen4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_txen8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_mckenc_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 20 && _end > 16 {
                        let _offset_start = 16u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(20);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(16);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_mckfreq10_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 24 && _end > 20 {
                        let _offset_start = 20u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(24);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(20);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_ratio14_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 28 && _end > 24 {
                        let _offset_start = 24u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(28);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(24);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_swidth18_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 32 && _end > 28 {
                        let _offset_start = 28u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(32);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(28);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_align1c_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 36 && _end > 32 {
                        let _offset_start = 32u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(36);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(32);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_format20_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 40 && _end > 36 {
                        let _offset_start = 36u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(40);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(36);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_config_channels24_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let _offset_start = 1336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1340);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_rxd_ptr0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1344..=1347, 1345..=1348) => {
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_txd_ptr0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1360..=1363, 1361..=1364) => {
                if _start < 1364 && _end > 1360 {
                    let _offset_start = 1360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_rxtxd_maxcnt0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            (1376..=1395, 1377..=1396) => {
                if _start < 1396 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1396);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(20);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_psel_mck0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_psel_sck4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_psel_lrck8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_psel_sdinc_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 20 && _end > 16 {
                        let _offset_start = 16u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(20);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(16);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .i2s_psel_sdout10_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::i2s::I2s::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=7, 1..=8) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .i2s_tasks_start0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .i2s_tasks_stop4_write(_start, _buf)?;
                }
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .i2s_events_rxptrupd104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .i2s_events_stopped108_write(_start, _buf)?;
                }
            }
            (276..=279, 277..=280) => {
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .i2s_events_txptrupd114_write(_start, _buf)?;
                }
            }
            (768..=779, 769..=780) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().i2s_inten300_write(_start, _buf)?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .i2s_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .i2s_intenclr308_write(_start, _buf)?;
                }
            }
            (1280..=1323, 1281..=1324) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().i2s_enable500_write(_start, _buf)?;
                }
                if _start < 1324 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1324);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(40);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_mode0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_rxen4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_txen8_write(_start, _buf)?;
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_mckenc_write(_start, _buf)?;
                    }
                    if _start < 20 && _end > 16 {
                        let _offset_start = 16u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(20);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(16);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_mckfreq10_write(_start, _buf)?;
                    }
                    if _start < 24 && _end > 20 {
                        let _offset_start = 20u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(24);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(20);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_ratio14_write(_start, _buf)?;
                    }
                    if _start < 28 && _end > 24 {
                        let _offset_start = 24u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(28);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(24);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_swidth18_write(_start, _buf)?;
                    }
                    if _start < 32 && _end > 28 {
                        let _offset_start = 28u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(32);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(28);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_align1c_write(_start, _buf)?;
                    }
                    if _start < 36 && _end > 32 {
                        let _offset_start = 32u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(36);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(32);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_format20_write(_start, _buf)?;
                    }
                    if _start < 40 && _end > 36 {
                        let _offset_start = 36u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(40);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(36);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_config_channels24_write(_start, _buf)?;
                    }
                }
            }
            (1336..=1339, 1337..=1340) => {
                if _start < 1340 && _end > 1336 {
                    let _offset_start = 1336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1340);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_rxd_ptr0_write(_start, _buf)?;
                    }
                }
            }
            (1344..=1347, 1345..=1348) => {
                if _start < 1348 && _end > 1344 {
                    let _offset_start = 1344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_txd_ptr0_write(_start, _buf)?;
                    }
                }
            }
            (1360..=1363, 1361..=1364) => {
                if _start < 1364 && _end > 1360 {
                    let _offset_start = 1360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_rxtxd_maxcnt0_write(_start, _buf)?;
                    }
                }
            }
            (1376..=1395, 1377..=1396) => {
                if _start < 1396 && _end > 1376 {
                    let _offset_start = 1376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1396);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1376);
                    let _end = (_start + _buf.len() as u64).max(20);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_psel_mck0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_psel_sck4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_psel_lrck8_write(_start, _buf)?;
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_psel_sdinc_write(_start, _buf)?;
                    }
                    if _start < 20 && _end > 16 {
                        let _offset_start = 16u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(20);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(16);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .i2s_psel_sdout10_write(_start, _buf)?;
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Fpu(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Fpu {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::fpu::Fpu::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .fpu_unused0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::fpu::Fpu::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=3, 1..=4) => {
                return Err(MemError::WriteViolation);
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct P0(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for P0 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::p0::P0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1284..=1319, 1285..=1320) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().p0_out504_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .p0_outset508_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .p0_outclr50c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1300 && _end > 1296 {
                    let _offset_start = 1296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().p0_in510_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().p0_dir514_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .p0_dirset518_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .p0_dirclr51c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .p0_latch520_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .p0_detectmode524_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1792..=1919, 1793..=1920) => {
                if _start < 1920 && _end > 1792 {
                    let _offset_start = 1792u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1920);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1792);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..32usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &mut _buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            let value = self
                                .0
                                .lock()
                                .unwrap()
                                .p0_pin_cnfn700_read(_dim)?
                                .to_ne_bytes();
                            for _byte in _start.._end {
                                _buf[_byte as usize] = value[_byte as usize];
                            }
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::p0::P0::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (1284..=1319, 1285..=1320) => {
                if _start < 1288 && _end > 1284 {
                    let _offset_start = 1284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().p0_out504_write(_start, _buf)?;
                }
                if _start < 1292 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().p0_outset508_write(_start, _buf)?;
                }
                if _start < 1296 && _end > 1292 {
                    let _offset_start = 1292u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1296);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1292);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().p0_outclr50c_write(_start, _buf)?;
                }
                if _start < 1300 && _end > 1296 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1304 && _end > 1300 {
                    let _offset_start = 1300u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1300);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().p0_dir514_write(_start, _buf)?;
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().p0_dirset518_write(_start, _buf)?;
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().p0_dirclr51c_write(_start, _buf)?;
                }
                if _start < 1316 && _end > 1312 {
                    let _offset_start = 1312u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1316);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1312);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().p0_latch520_write(_start, _buf)?;
                }
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .p0_detectmode524_write(_start, _buf)?;
                }
            }
            (1792..=1919, 1793..=1920) => {
                if _start < 1920 && _end > 1792 {
                    let _offset_start = 1792u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1920);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1792);
                    let _end = (_start + _buf.len() as u64).max(4);
                    for _dim in 0..32usize {
                        let _dim_offset = _dim as u64 * 4;
                        let _reg_start = _dim_offset;
                        let _reg_end = _reg_start + 4;
                        if _start < _reg_end && _end > _reg_start {
                            let _offset_start =
                                _reg_start.saturating_sub(_start);
                            let _offset_end = _buf.len() as u64
                                - _end.saturating_sub(_reg_end);
                            let _buf = &_buf
                                [_offset_start as usize.._offset_end as usize];
                            let _start = _start.saturating_sub(_reg_start);
                            let _end = (_end - _reg_end).min(4);
                            let _end = (_start + _buf.len() as u64).max(4);
                            self.0
                                .lock()
                                .unwrap()
                                .p0_pin_cnfn700_write(_dim, _start, _buf)?;
                        }
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Dwt(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Dwt {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::dwt::Dwt::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=43, 1..=44) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_ctrl0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_cyccnt4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_cpicnt8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_exccntc_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_sleepcnt10_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_lsucnt14_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 28 && _end > 24 {
                    let _offset_start = 24u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(28);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(24);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_foldcnt18_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 32 && _end > 28 {
                    let _offset_start = 28u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(32);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(28);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_pcsr1c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 36 && _end > 32 {
                    let _offset_start = 32u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(36);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(32);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_comp020_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 40 && _end > 36 {
                    let _offset_start = 36u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(40);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(36);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_mask024_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 44 && _end > 40 {
                    let _offset_start = 40u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(44);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(40);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_function028_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (48..=59, 49..=60) => {
                if _start < 52 && _end > 48 {
                    let _offset_start = 48u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(52);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(48);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_comp130_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 56 && _end > 52 {
                    let _offset_start = 52u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(56);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(52);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_mask134_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 60 && _end > 56 {
                    let _offset_start = 56u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(60);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(56);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_function138_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (64..=75, 65..=76) => {
                if _start < 68 && _end > 64 {
                    let _offset_start = 64u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(68);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(64);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_comp240_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 72 && _end > 68 {
                    let _offset_start = 68u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(72);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(68);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_mask244_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 76 && _end > 72 {
                    let _offset_start = 72u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(76);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(72);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_function248_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (80..=91, 81..=92) => {
                if _start < 84 && _end > 80 {
                    let _offset_start = 80u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(84);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(80);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_comp350_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 88 && _end > 84 {
                    let _offset_start = 84u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(88);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(84);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_mask354_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 92 && _end > 88 {
                    let _offset_start = 88u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(92);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(88);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .dwt_dwt_function358_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::dwt::Dwt::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (..=43, 1..=44) => {
                if _start < 4 && _end > 0 {
                    let _offset_start = 0u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(4);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(0);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().dwt_dwt_ctrl0_write(_start, _buf)?;
                }
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_cyccnt4_write(_start, _buf)?;
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_cpicnt8_write(_start, _buf)?;
                }
                if _start < 16 && _end > 12 {
                    let _offset_start = 12u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(16);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(12);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_exccntc_write(_start, _buf)?;
                }
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_sleepcnt10_write(_start, _buf)?;
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_lsucnt14_write(_start, _buf)?;
                }
                if _start < 28 && _end > 24 {
                    let _offset_start = 24u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(28);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(24);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_foldcnt18_write(_start, _buf)?;
                }
                if _start < 32 && _end > 28 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 36 && _end > 32 {
                    let _offset_start = 32u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(36);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(32);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_comp020_write(_start, _buf)?;
                }
                if _start < 40 && _end > 36 {
                    let _offset_start = 36u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(40);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(36);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_mask024_write(_start, _buf)?;
                }
                if _start < 44 && _end > 40 {
                    let _offset_start = 40u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(44);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(40);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_function028_write(_start, _buf)?;
                }
            }
            (48..=59, 49..=60) => {
                if _start < 52 && _end > 48 {
                    let _offset_start = 48u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(52);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(48);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_comp130_write(_start, _buf)?;
                }
                if _start < 56 && _end > 52 {
                    let _offset_start = 52u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(56);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(52);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_mask134_write(_start, _buf)?;
                }
                if _start < 60 && _end > 56 {
                    let _offset_start = 56u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(60);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(56);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_function138_write(_start, _buf)?;
                }
            }
            (64..=75, 65..=76) => {
                if _start < 68 && _end > 64 {
                    let _offset_start = 64u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(68);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(64);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_comp240_write(_start, _buf)?;
                }
                if _start < 72 && _end > 68 {
                    let _offset_start = 68u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(72);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(68);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_mask244_write(_start, _buf)?;
                }
                if _start < 76 && _end > 72 {
                    let _offset_start = 72u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(76);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(72);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_function248_write(_start, _buf)?;
                }
            }
            (80..=91, 81..=92) => {
                if _start < 84 && _end > 80 {
                    let _offset_start = 80u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(84);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(80);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_comp350_write(_start, _buf)?;
                }
                if _start < 88 && _end > 84 {
                    let _offset_start = 84u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(88);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(84);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_mask354_write(_start, _buf)?;
                }
                if _start < 92 && _end > 88 {
                    let _offset_start = 88u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(92);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(88);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .dwt_dwt_function358_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Scs(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Scs {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::scs::Scs::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=11, 5..=12) => {
                if _start < 8 && _end > 4 {
                    let _offset_start = 4u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(8);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(4);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().scs_ictr4_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().scs_actlr8_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (16..=31, 17..=32) => {
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_stcsr10_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_strvr14_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 28 && _end > 24 {
                    let _offset_start = 24u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(28);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(24);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_stcvr18_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 32 && _end > 28 {
                    let _offset_start = 28u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(32);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(28);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().scs_stcr1c_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser0100_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser1104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser2108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser310c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser4110_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser5114_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser6118_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser711c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (384..=415, 385..=416) => {
                if _start < 388 && _end > 384 {
                    let _offset_start = 384u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(388);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(384);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer0180_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 392 && _end > 388 {
                    let _offset_start = 388u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(392);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(388);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer1184_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 396 && _end > 392 {
                    let _offset_start = 392u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(396);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(392);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer2188_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 400 && _end > 396 {
                    let _offset_start = 396u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(400);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(396);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer318c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 404 && _end > 400 {
                    let _offset_start = 400u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(404);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(400);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer4190_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 408 && _end > 404 {
                    let _offset_start = 404u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(408);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(404);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer5194_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 412 && _end > 408 {
                    let _offset_start = 408u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(412);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(408);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer6198_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 416 && _end > 412 {
                    let _offset_start = 412u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(416);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(412);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer719c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=543, 513..=544) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr0200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 520 && _end > 516 {
                    let _offset_start = 516u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(520);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(516);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr1204_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 524 && _end > 520 {
                    let _offset_start = 520u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(524);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(520);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr2208_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 528 && _end > 524 {
                    let _offset_start = 524u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(528);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(524);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr320c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 532 && _end > 528 {
                    let _offset_start = 528u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(532);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(528);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr4210_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 536 && _end > 532 {
                    let _offset_start = 532u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(536);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(532);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr5214_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 540 && _end > 536 {
                    let _offset_start = 536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(540);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(536);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr6218_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 544 && _end > 540 {
                    let _offset_start = 540u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(544);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(540);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr721c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (640..=671, 641..=672) => {
                if _start < 644 && _end > 640 {
                    let _offset_start = 640u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(644);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(640);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr0280_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 648 && _end > 644 {
                    let _offset_start = 644u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(648);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(644);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr1284_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 652 && _end > 648 {
                    let _offset_start = 648u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(652);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(648);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr2288_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 656 && _end > 652 {
                    let _offset_start = 652u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(656);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(652);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr328c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 660 && _end > 656 {
                    let _offset_start = 656u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(660);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(656);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr4290_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 664 && _end > 660 {
                    let _offset_start = 660u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(664);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(660);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr5294_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 668 && _end > 664 {
                    let _offset_start = 664u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(668);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(664);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr6298_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 672 && _end > 668 {
                    let _offset_start = 668u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(672);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(668);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr729c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (768..=799, 769..=800) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr0300_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr1304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr2308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 784 && _end > 780 {
                    let _offset_start = 780u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(784);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(780);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr330c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 788 && _end > 784 {
                    let _offset_start = 784u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(788);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(784);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr4310_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 792 && _end > 788 {
                    let _offset_start = 788u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(792);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(788);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr5314_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 796 && _end > 792 {
                    let _offset_start = 792u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(796);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(792);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr6318_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 800 && _end > 796 {
                    let _offset_start = 796u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(800);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(796);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr731c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1263, 1025..=1264) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr0400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1032 && _end > 1028 {
                    let _offset_start = 1028u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1032);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1028);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr1404_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1036 && _end > 1032 {
                    let _offset_start = 1032u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1036);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1032);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr2408_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1040 && _end > 1036 {
                    let _offset_start = 1036u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1040);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1036);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr340c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1044 && _end > 1040 {
                    let _offset_start = 1040u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1044);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1040);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr4410_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1048 && _end > 1044 {
                    let _offset_start = 1044u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1048);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1044);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr5414_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1052 && _end > 1048 {
                    let _offset_start = 1048u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1052);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1048);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr6418_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1056 && _end > 1052 {
                    let _offset_start = 1052u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1056);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1052);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr741c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1060 && _end > 1056 {
                    let _offset_start = 1056u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1060);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1056);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr8420_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1064 && _end > 1060 {
                    let _offset_start = 1060u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1064);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1060);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr9424_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1068 && _end > 1064 {
                    let _offset_start = 1064u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1068);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1064);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr10428_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1072 && _end > 1068 {
                    let _offset_start = 1068u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1072);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1068);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr1142c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1076 && _end > 1072 {
                    let _offset_start = 1072u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1076);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1072);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr12430_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1080 && _end > 1076 {
                    let _offset_start = 1076u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1080);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1076);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr13434_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1084 && _end > 1080 {
                    let _offset_start = 1080u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1084);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1080);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr14438_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1088 && _end > 1084 {
                    let _offset_start = 1084u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1088);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1084);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr1543c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1092 && _end > 1088 {
                    let _offset_start = 1088u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1092);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1088);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr16440_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1096 && _end > 1092 {
                    let _offset_start = 1092u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1096);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1092);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr17444_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1100 && _end > 1096 {
                    let _offset_start = 1096u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1100);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1096);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr18448_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1104 && _end > 1100 {
                    let _offset_start = 1100u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1104);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1100);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr1944c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1108 && _end > 1104 {
                    let _offset_start = 1104u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1108);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1104);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr20450_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1112 && _end > 1108 {
                    let _offset_start = 1108u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1112);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1108);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr21454_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1116 && _end > 1112 {
                    let _offset_start = 1112u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1116);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1112);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr22458_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1120 && _end > 1116 {
                    let _offset_start = 1116u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1120);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1116);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr2345c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1124 && _end > 1120 {
                    let _offset_start = 1120u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1124);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1120);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr24460_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1128 && _end > 1124 {
                    let _offset_start = 1124u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1128);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1124);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr25464_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1132 && _end > 1128 {
                    let _offset_start = 1128u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1132);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1128);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr26468_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1136 && _end > 1132 {
                    let _offset_start = 1132u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1136);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1132);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr2746c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1140 && _end > 1136 {
                    let _offset_start = 1136u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1140);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1136);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr28470_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1144 && _end > 1140 {
                    let _offset_start = 1140u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1144);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1140);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr29474_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1148 && _end > 1144 {
                    let _offset_start = 1144u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1148);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1144);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr30478_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1152 && _end > 1148 {
                    let _offset_start = 1148u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1152);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1148);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr3147c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1156 && _end > 1152 {
                    let _offset_start = 1152u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1156);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1152);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr32480_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1160 && _end > 1156 {
                    let _offset_start = 1156u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1160);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1156);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr33484_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1164 && _end > 1160 {
                    let _offset_start = 1160u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1164);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1160);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr34488_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1168 && _end > 1164 {
                    let _offset_start = 1164u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1168);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1164);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr3548c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1172 && _end > 1168 {
                    let _offset_start = 1168u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1172);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1168);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr36490_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1176 && _end > 1172 {
                    let _offset_start = 1172u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1176);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1172);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr37494_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1180 && _end > 1176 {
                    let _offset_start = 1176u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1180);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1176);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr38498_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1184 && _end > 1180 {
                    let _offset_start = 1180u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1184);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1180);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr3949c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1188 && _end > 1184 {
                    let _offset_start = 1184u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1188);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1184);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr404a0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1192 && _end > 1188 {
                    let _offset_start = 1188u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1192);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1188);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr414a4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1196 && _end > 1192 {
                    let _offset_start = 1192u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1196);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1192);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr424a8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1200 && _end > 1196 {
                    let _offset_start = 1196u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1200);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1196);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr434ac_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1204 && _end > 1200 {
                    let _offset_start = 1200u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1204);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1200);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr444b0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1208 && _end > 1204 {
                    let _offset_start = 1204u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1208);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1204);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr454b4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1212 && _end > 1208 {
                    let _offset_start = 1208u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1212);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1208);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr464b8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1216 && _end > 1212 {
                    let _offset_start = 1212u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1216);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1212);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr474bc_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1220 && _end > 1216 {
                    let _offset_start = 1216u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1220);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1216);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr484c0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1224 && _end > 1220 {
                    let _offset_start = 1220u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1224);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1220);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr494c4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1228 && _end > 1224 {
                    let _offset_start = 1224u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1228);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1224);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr504c8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1232 && _end > 1228 {
                    let _offset_start = 1228u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1232);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1228);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr514cc_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1236 && _end > 1232 {
                    let _offset_start = 1232u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1236);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1232);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr524d0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1240 && _end > 1236 {
                    let _offset_start = 1236u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1240);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1236);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr534d4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1244 && _end > 1240 {
                    let _offset_start = 1240u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1244);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1240);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr544d8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1248 && _end > 1244 {
                    let _offset_start = 1244u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1248);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1244);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr554dc_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1252 && _end > 1248 {
                    let _offset_start = 1248u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1252);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1248);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr564e0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1256 && _end > 1252 {
                    let _offset_start = 1252u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1256);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1252);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr574e4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1260 && _end > 1256 {
                    let _offset_start = 1256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1260);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr584e8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1264 && _end > 1260 {
                    let _offset_start = 1260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr594ec_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (3328..=3443, 3329..=3444) => {
                if _start < 3332 && _end > 3328 {
                    let _offset_start = 3328u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3332);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3328);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_cpuidd00_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3336 && _end > 3332 {
                    let _offset_start = 3332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_icsrd04_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3340 && _end > 3336 {
                    let _offset_start = 3336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3340);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_vtord08_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3344 && _end > 3340 {
                    let _offset_start = 3340u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3344);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3340);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_aircrd0c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3348 && _end > 3344 {
                    let _offset_start = 3344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().scs_scrd10_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3352 && _end > 3348 {
                    let _offset_start = 3348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3352);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value =
                        self.0.lock().unwrap().scs_ccrd14_read()?.to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3356 && _end > 3352 {
                    let _offset_start = 3352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3356);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_shpr1d18_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3360 && _end > 3356 {
                    let _offset_start = 3356u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3360);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3356);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_shpr2d1c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3364 && _end > 3360 {
                    let _offset_start = 3360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3364);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_shpr3d20_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3368 && _end > 3364 {
                    let _offset_start = 3364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3368);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_shcsrd24_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3372 && _end > 3368 {
                    let _offset_start = 3368u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3372);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3368);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_cfsrd28_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3376 && _end > 3372 {
                    let _offset_start = 3372u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3376);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3372);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_hfsrd2c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3380 && _end > 3376 {
                    let _offset_start = 3376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3380);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3376);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_dfsrd30_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3384 && _end > 3380 {
                    let _offset_start = 3380u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3384);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3380);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mmfard34_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3388 && _end > 3384 {
                    let _offset_start = 3384u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3388);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3384);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_bfard38_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3392 && _end > 3388 {
                    let _offset_start = 3388u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3392);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3388);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_afsrd3c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3396 && _end > 3392 {
                    let _offset_start = 3392u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3396);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3392);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_pfr0d40_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3400 && _end > 3396 {
                    let _offset_start = 3396u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3400);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3396);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_pfr1d44_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3404 && _end > 3400 {
                    let _offset_start = 3400u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3404);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3400);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_dfr0d48_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3408 && _end > 3404 {
                    let _offset_start = 3404u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3408);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3404);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_afr0d4c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3412 && _end > 3408 {
                    let _offset_start = 3408u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3412);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3408);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_mmfr0d50_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3416 && _end > 3412 {
                    let _offset_start = 3412u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3416);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3412);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_mmfr1d54_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3420 && _end > 3416 {
                    let _offset_start = 3416u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3420);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3416);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_mmfr2d58_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3424 && _end > 3420 {
                    let _offset_start = 3420u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3424);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3420);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_mmfr3d5c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3428 && _end > 3424 {
                    let _offset_start = 3424u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3428);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3424);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_isar0d60_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3432 && _end > 3428 {
                    let _offset_start = 3428u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3432);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3428);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_isar1d64_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3436 && _end > 3432 {
                    let _offset_start = 3432u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3436);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3432);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_isar2d68_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3440 && _end > 3436 {
                    let _offset_start = 3436u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3440);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3436);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_isar3d6c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3444 && _end > 3440 {
                    let _offset_start = 3440u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3444);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3440);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_id_isar4d70_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (3464..=3467, 3465..=3468) => {
                if _start < 3468 && _end > 3464 {
                    let _offset_start = 3464u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3468);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3464);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_cpacrd88_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (3472..=3515, 3473..=3516) => {
                if _start < 3476 && _end > 3472 {
                    let _offset_start = 3472u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3476);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3472);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_typed90_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3480 && _end > 3476 {
                    let _offset_start = 3476u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3480);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3476);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_ctrld94_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3484 && _end > 3480 {
                    let _offset_start = 3480u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3484);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3480);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rnrd98_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3488 && _end > 3484 {
                    let _offset_start = 3484u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3488);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3484);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rbard9c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3492 && _end > 3488 {
                    let _offset_start = 3488u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3492);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3488);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rasrda0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3496 && _end > 3492 {
                    let _offset_start = 3492u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3496);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3492);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rbar_a1da4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3500 && _end > 3496 {
                    let _offset_start = 3496u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3500);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3496);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rasr_a1da8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3504 && _end > 3500 {
                    let _offset_start = 3500u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3504);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3500);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rbar_a2dac_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3508 && _end > 3504 {
                    let _offset_start = 3504u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3508);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3504);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rasr_a2db0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3512 && _end > 3508 {
                    let _offset_start = 3508u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3512);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3508);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rbar_a3db4_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3516 && _end > 3512 {
                    let _offset_start = 3512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mpu_rasr_a3db8_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (3580..=3583, 3581..=3584) => {
                if _start < 3584 && _end > 3580 {
                    let _offset_start = 3580u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3584);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3580);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_demcrdfc_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (3840..=3843, 3841..=3844) => {
                return Err(MemError::ReadViolation);
            }
            (3892..=3911, 3893..=3912) => {
                if _start < 3896 && _end > 3892 {
                    let _offset_start = 3892u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3896);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3892);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_fpccrf34_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3900 && _end > 3896 {
                    let _offset_start = 3896u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3900);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3896);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_fpcarf38_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3904 && _end > 3900 {
                    let _offset_start = 3900u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3904);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3900);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_fpdscrf3c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3908 && _end > 3904 {
                    let _offset_start = 3904u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3908);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3904);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mvfr0f40_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 3912 && _end > 3908 {
                    let _offset_start = 3908u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3912);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3908);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .scs_mvfr1f44_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::scs::Scs::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (4..=11, 5..=12) => {
                if _start < 8 && _end > 4 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 12 && _end > 8 {
                    let _offset_start = 8u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(12);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(8);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_actlr8_write(_start, _buf)?;
                }
            }
            (16..=31, 17..=32) => {
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_stcsr10_write(_start, _buf)?;
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_strvr14_write(_start, _buf)?;
                }
                if _start < 28 && _end > 24 {
                    let _offset_start = 24u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(28);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(24);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_stcvr18_write(_start, _buf)?;
                }
                if _start < 32 && _end > 28 {
                    return Err(MemError::WriteViolation);
                }
            }
            (256..=287, 257..=288) => {
                if _start < 260 && _end > 256 {
                    let _offset_start = 256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser0100_write(_start, _buf)?;
                }
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser1104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser2108_write(_start, _buf)?;
                }
                if _start < 272 && _end > 268 {
                    let _offset_start = 268u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(272);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(268);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser310c_write(_start, _buf)?;
                }
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser4110_write(_start, _buf)?;
                }
                if _start < 280 && _end > 276 {
                    let _offset_start = 276u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(280);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(276);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser5114_write(_start, _buf)?;
                }
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser6118_write(_start, _buf)?;
                }
                if _start < 288 && _end > 284 {
                    let _offset_start = 284u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(288);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(284);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iser711c_write(_start, _buf)?;
                }
            }
            (384..=415, 385..=416) => {
                if _start < 388 && _end > 384 {
                    let _offset_start = 384u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(388);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(384);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer0180_write(_start, _buf)?;
                }
                if _start < 392 && _end > 388 {
                    let _offset_start = 388u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(392);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(388);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer1184_write(_start, _buf)?;
                }
                if _start < 396 && _end > 392 {
                    let _offset_start = 392u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(396);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(392);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer2188_write(_start, _buf)?;
                }
                if _start < 400 && _end > 396 {
                    let _offset_start = 396u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(400);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(396);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer318c_write(_start, _buf)?;
                }
                if _start < 404 && _end > 400 {
                    let _offset_start = 400u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(404);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(400);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer4190_write(_start, _buf)?;
                }
                if _start < 408 && _end > 404 {
                    let _offset_start = 404u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(408);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(404);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer5194_write(_start, _buf)?;
                }
                if _start < 412 && _end > 408 {
                    let _offset_start = 408u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(412);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(408);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer6198_write(_start, _buf)?;
                }
                if _start < 416 && _end > 412 {
                    let _offset_start = 412u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(416);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(412);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icer719c_write(_start, _buf)?;
                }
            }
            (512..=543, 513..=544) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr0200_write(_start, _buf)?;
                }
                if _start < 520 && _end > 516 {
                    let _offset_start = 516u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(520);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(516);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr1204_write(_start, _buf)?;
                }
                if _start < 524 && _end > 520 {
                    let _offset_start = 520u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(524);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(520);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr2208_write(_start, _buf)?;
                }
                if _start < 528 && _end > 524 {
                    let _offset_start = 524u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(528);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(524);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr320c_write(_start, _buf)?;
                }
                if _start < 532 && _end > 528 {
                    let _offset_start = 528u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(532);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(528);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr4210_write(_start, _buf)?;
                }
                if _start < 536 && _end > 532 {
                    let _offset_start = 532u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(536);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(532);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr5214_write(_start, _buf)?;
                }
                if _start < 540 && _end > 536 {
                    let _offset_start = 536u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(540);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(536);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr6218_write(_start, _buf)?;
                }
                if _start < 544 && _end > 540 {
                    let _offset_start = 540u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(544);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(540);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ispr721c_write(_start, _buf)?;
                }
            }
            (640..=671, 641..=672) => {
                if _start < 644 && _end > 640 {
                    let _offset_start = 640u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(644);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(640);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr0280_write(_start, _buf)?;
                }
                if _start < 648 && _end > 644 {
                    let _offset_start = 644u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(648);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(644);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr1284_write(_start, _buf)?;
                }
                if _start < 652 && _end > 648 {
                    let _offset_start = 648u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(652);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(648);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr2288_write(_start, _buf)?;
                }
                if _start < 656 && _end > 652 {
                    let _offset_start = 652u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(656);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(652);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr328c_write(_start, _buf)?;
                }
                if _start < 660 && _end > 656 {
                    let _offset_start = 656u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(660);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(656);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr4290_write(_start, _buf)?;
                }
                if _start < 664 && _end > 660 {
                    let _offset_start = 660u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(664);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(660);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr5294_write(_start, _buf)?;
                }
                if _start < 668 && _end > 664 {
                    let _offset_start = 664u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(668);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(664);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr6298_write(_start, _buf)?;
                }
                if _start < 672 && _end > 668 {
                    let _offset_start = 668u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(672);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(668);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_icpr729c_write(_start, _buf)?;
                }
            }
            (768..=799, 769..=800) => {
                if _start < 772 && _end > 768 {
                    let _offset_start = 768u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(772);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(768);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr0300_write(_start, _buf)?;
                }
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr1304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr2308_write(_start, _buf)?;
                }
                if _start < 784 && _end > 780 {
                    let _offset_start = 780u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(784);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(780);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr330c_write(_start, _buf)?;
                }
                if _start < 788 && _end > 784 {
                    let _offset_start = 784u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(788);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(784);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr4310_write(_start, _buf)?;
                }
                if _start < 792 && _end > 788 {
                    let _offset_start = 788u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(792);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(788);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr5314_write(_start, _buf)?;
                }
                if _start < 796 && _end > 792 {
                    let _offset_start = 792u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(796);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(792);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr6318_write(_start, _buf)?;
                }
                if _start < 800 && _end > 796 {
                    let _offset_start = 796u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(800);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(796);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_iabr731c_write(_start, _buf)?;
                }
            }
            (1024..=1263, 1025..=1264) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr0400_write(_start, _buf)?;
                }
                if _start < 1032 && _end > 1028 {
                    let _offset_start = 1028u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1032);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1028);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr1404_write(_start, _buf)?;
                }
                if _start < 1036 && _end > 1032 {
                    let _offset_start = 1032u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1036);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1032);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr2408_write(_start, _buf)?;
                }
                if _start < 1040 && _end > 1036 {
                    let _offset_start = 1036u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1040);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1036);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr340c_write(_start, _buf)?;
                }
                if _start < 1044 && _end > 1040 {
                    let _offset_start = 1040u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1044);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1040);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr4410_write(_start, _buf)?;
                }
                if _start < 1048 && _end > 1044 {
                    let _offset_start = 1044u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1048);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1044);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr5414_write(_start, _buf)?;
                }
                if _start < 1052 && _end > 1048 {
                    let _offset_start = 1048u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1052);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1048);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr6418_write(_start, _buf)?;
                }
                if _start < 1056 && _end > 1052 {
                    let _offset_start = 1052u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1056);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1052);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr741c_write(_start, _buf)?;
                }
                if _start < 1060 && _end > 1056 {
                    let _offset_start = 1056u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1060);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1056);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr8420_write(_start, _buf)?;
                }
                if _start < 1064 && _end > 1060 {
                    let _offset_start = 1060u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1064);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1060);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr9424_write(_start, _buf)?;
                }
                if _start < 1068 && _end > 1064 {
                    let _offset_start = 1064u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1068);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1064);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr10428_write(_start, _buf)?;
                }
                if _start < 1072 && _end > 1068 {
                    let _offset_start = 1068u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1072);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1068);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr1142c_write(_start, _buf)?;
                }
                if _start < 1076 && _end > 1072 {
                    let _offset_start = 1072u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1076);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1072);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr12430_write(_start, _buf)?;
                }
                if _start < 1080 && _end > 1076 {
                    let _offset_start = 1076u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1080);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1076);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr13434_write(_start, _buf)?;
                }
                if _start < 1084 && _end > 1080 {
                    let _offset_start = 1080u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1084);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1080);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr14438_write(_start, _buf)?;
                }
                if _start < 1088 && _end > 1084 {
                    let _offset_start = 1084u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1088);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1084);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr1543c_write(_start, _buf)?;
                }
                if _start < 1092 && _end > 1088 {
                    let _offset_start = 1088u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1092);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1088);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr16440_write(_start, _buf)?;
                }
                if _start < 1096 && _end > 1092 {
                    let _offset_start = 1092u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1096);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1092);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr17444_write(_start, _buf)?;
                }
                if _start < 1100 && _end > 1096 {
                    let _offset_start = 1096u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1100);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1096);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr18448_write(_start, _buf)?;
                }
                if _start < 1104 && _end > 1100 {
                    let _offset_start = 1100u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1104);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1100);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr1944c_write(_start, _buf)?;
                }
                if _start < 1108 && _end > 1104 {
                    let _offset_start = 1104u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1108);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1104);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr20450_write(_start, _buf)?;
                }
                if _start < 1112 && _end > 1108 {
                    let _offset_start = 1108u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1112);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1108);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr21454_write(_start, _buf)?;
                }
                if _start < 1116 && _end > 1112 {
                    let _offset_start = 1112u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1116);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1112);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr22458_write(_start, _buf)?;
                }
                if _start < 1120 && _end > 1116 {
                    let _offset_start = 1116u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1120);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1116);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr2345c_write(_start, _buf)?;
                }
                if _start < 1124 && _end > 1120 {
                    let _offset_start = 1120u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1124);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1120);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr24460_write(_start, _buf)?;
                }
                if _start < 1128 && _end > 1124 {
                    let _offset_start = 1124u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1128);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1124);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr25464_write(_start, _buf)?;
                }
                if _start < 1132 && _end > 1128 {
                    let _offset_start = 1128u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1132);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1128);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr26468_write(_start, _buf)?;
                }
                if _start < 1136 && _end > 1132 {
                    let _offset_start = 1132u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1136);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1132);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr2746c_write(_start, _buf)?;
                }
                if _start < 1140 && _end > 1136 {
                    let _offset_start = 1136u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1140);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1136);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr28470_write(_start, _buf)?;
                }
                if _start < 1144 && _end > 1140 {
                    let _offset_start = 1140u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1144);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1140);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr29474_write(_start, _buf)?;
                }
                if _start < 1148 && _end > 1144 {
                    let _offset_start = 1144u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1148);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1144);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr30478_write(_start, _buf)?;
                }
                if _start < 1152 && _end > 1148 {
                    let _offset_start = 1148u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1152);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1148);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr3147c_write(_start, _buf)?;
                }
                if _start < 1156 && _end > 1152 {
                    let _offset_start = 1152u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1156);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1152);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr32480_write(_start, _buf)?;
                }
                if _start < 1160 && _end > 1156 {
                    let _offset_start = 1156u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1160);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1156);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr33484_write(_start, _buf)?;
                }
                if _start < 1164 && _end > 1160 {
                    let _offset_start = 1160u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1164);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1160);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr34488_write(_start, _buf)?;
                }
                if _start < 1168 && _end > 1164 {
                    let _offset_start = 1164u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1168);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1164);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr3548c_write(_start, _buf)?;
                }
                if _start < 1172 && _end > 1168 {
                    let _offset_start = 1168u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1172);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1168);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr36490_write(_start, _buf)?;
                }
                if _start < 1176 && _end > 1172 {
                    let _offset_start = 1172u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1176);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1172);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr37494_write(_start, _buf)?;
                }
                if _start < 1180 && _end > 1176 {
                    let _offset_start = 1176u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1180);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1176);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr38498_write(_start, _buf)?;
                }
                if _start < 1184 && _end > 1180 {
                    let _offset_start = 1180u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1184);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1180);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr3949c_write(_start, _buf)?;
                }
                if _start < 1188 && _end > 1184 {
                    let _offset_start = 1184u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1188);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1184);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr404a0_write(_start, _buf)?;
                }
                if _start < 1192 && _end > 1188 {
                    let _offset_start = 1188u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1192);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1188);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr414a4_write(_start, _buf)?;
                }
                if _start < 1196 && _end > 1192 {
                    let _offset_start = 1192u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1196);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1192);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr424a8_write(_start, _buf)?;
                }
                if _start < 1200 && _end > 1196 {
                    let _offset_start = 1196u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1200);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1196);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr434ac_write(_start, _buf)?;
                }
                if _start < 1204 && _end > 1200 {
                    let _offset_start = 1200u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1204);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1200);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr444b0_write(_start, _buf)?;
                }
                if _start < 1208 && _end > 1204 {
                    let _offset_start = 1204u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1208);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1204);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr454b4_write(_start, _buf)?;
                }
                if _start < 1212 && _end > 1208 {
                    let _offset_start = 1208u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1212);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1208);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr464b8_write(_start, _buf)?;
                }
                if _start < 1216 && _end > 1212 {
                    let _offset_start = 1212u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1216);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1212);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr474bc_write(_start, _buf)?;
                }
                if _start < 1220 && _end > 1216 {
                    let _offset_start = 1216u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1220);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1216);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr484c0_write(_start, _buf)?;
                }
                if _start < 1224 && _end > 1220 {
                    let _offset_start = 1220u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1224);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1220);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr494c4_write(_start, _buf)?;
                }
                if _start < 1228 && _end > 1224 {
                    let _offset_start = 1224u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1228);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1224);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr504c8_write(_start, _buf)?;
                }
                if _start < 1232 && _end > 1228 {
                    let _offset_start = 1228u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1232);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1228);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr514cc_write(_start, _buf)?;
                }
                if _start < 1236 && _end > 1232 {
                    let _offset_start = 1232u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1236);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1232);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr524d0_write(_start, _buf)?;
                }
                if _start < 1240 && _end > 1236 {
                    let _offset_start = 1236u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1240);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1236);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr534d4_write(_start, _buf)?;
                }
                if _start < 1244 && _end > 1240 {
                    let _offset_start = 1240u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1244);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1240);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr544d8_write(_start, _buf)?;
                }
                if _start < 1248 && _end > 1244 {
                    let _offset_start = 1244u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1248);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1244);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr554dc_write(_start, _buf)?;
                }
                if _start < 1252 && _end > 1248 {
                    let _offset_start = 1248u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1252);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1248);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr564e0_write(_start, _buf)?;
                }
                if _start < 1256 && _end > 1252 {
                    let _offset_start = 1252u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1256);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1252);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr574e4_write(_start, _buf)?;
                }
                if _start < 1260 && _end > 1256 {
                    let _offset_start = 1256u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1260);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1256);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr584e8_write(_start, _buf)?;
                }
                if _start < 1264 && _end > 1260 {
                    let _offset_start = 1260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_nvic_ipr594ec_write(_start, _buf)?;
                }
            }
            (3328..=3443, 3329..=3444) => {
                if _start < 3332 && _end > 3328 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3336 && _end > 3332 {
                    let _offset_start = 3332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_icsrd04_write(_start, _buf)?;
                }
                if _start < 3340 && _end > 3336 {
                    let _offset_start = 3336u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3340);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3336);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_vtord08_write(_start, _buf)?;
                }
                if _start < 3344 && _end > 3340 {
                    let _offset_start = 3340u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3344);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3340);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_aircrd0c_write(_start, _buf)?;
                }
                if _start < 3348 && _end > 3344 {
                    let _offset_start = 3344u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3344);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_scrd10_write(_start, _buf)?;
                }
                if _start < 3352 && _end > 3348 {
                    let _offset_start = 3348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3352);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3348);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_ccrd14_write(_start, _buf)?;
                }
                if _start < 3356 && _end > 3352 {
                    let _offset_start = 3352u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3356);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3352);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_shpr1d18_write(_start, _buf)?;
                }
                if _start < 3360 && _end > 3356 {
                    let _offset_start = 3356u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3360);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3356);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_shpr2d1c_write(_start, _buf)?;
                }
                if _start < 3364 && _end > 3360 {
                    let _offset_start = 3360u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3364);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3360);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_shpr3d20_write(_start, _buf)?;
                }
                if _start < 3368 && _end > 3364 {
                    let _offset_start = 3364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3368);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_shcsrd24_write(_start, _buf)?;
                }
                if _start < 3372 && _end > 3368 {
                    let _offset_start = 3368u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3372);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3368);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_cfsrd28_write(_start, _buf)?;
                }
                if _start < 3376 && _end > 3372 {
                    let _offset_start = 3372u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3376);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3372);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_hfsrd2c_write(_start, _buf)?;
                }
                if _start < 3380 && _end > 3376 {
                    let _offset_start = 3376u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3380);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3376);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_dfsrd30_write(_start, _buf)?;
                }
                if _start < 3384 && _end > 3380 {
                    let _offset_start = 3380u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3384);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3380);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_mmfard34_write(_start, _buf)?;
                }
                if _start < 3388 && _end > 3384 {
                    let _offset_start = 3384u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3388);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3384);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_bfard38_write(_start, _buf)?;
                }
                if _start < 3392 && _end > 3388 {
                    let _offset_start = 3388u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3392);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3388);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_afsrd3c_write(_start, _buf)?;
                }
                if _start < 3396 && _end > 3392 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3400 && _end > 3396 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3404 && _end > 3400 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3408 && _end > 3404 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3412 && _end > 3408 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3416 && _end > 3412 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3420 && _end > 3416 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3424 && _end > 3420 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3428 && _end > 3424 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3432 && _end > 3428 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3436 && _end > 3432 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3440 && _end > 3436 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3444 && _end > 3440 {
                    return Err(MemError::WriteViolation);
                }
            }
            (3464..=3467, 3465..=3468) => {
                if _start < 3468 && _end > 3464 {
                    let _offset_start = 3464u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3468);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3464);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_cpacrd88_write(_start, _buf)?;
                }
            }
            (3472..=3515, 3473..=3516) => {
                if _start < 3476 && _end > 3472 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3480 && _end > 3476 {
                    let _offset_start = 3476u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3480);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3476);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_ctrld94_write(_start, _buf)?;
                }
                if _start < 3484 && _end > 3480 {
                    let _offset_start = 3480u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3484);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3480);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rnrd98_write(_start, _buf)?;
                }
                if _start < 3488 && _end > 3484 {
                    let _offset_start = 3484u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3488);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3484);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rbard9c_write(_start, _buf)?;
                }
                if _start < 3492 && _end > 3488 {
                    let _offset_start = 3488u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3492);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3488);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rasrda0_write(_start, _buf)?;
                }
                if _start < 3496 && _end > 3492 {
                    let _offset_start = 3492u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3496);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3492);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rbar_a1da4_write(_start, _buf)?;
                }
                if _start < 3500 && _end > 3496 {
                    let _offset_start = 3496u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3500);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3496);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rasr_a1da8_write(_start, _buf)?;
                }
                if _start < 3504 && _end > 3500 {
                    let _offset_start = 3500u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3504);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3500);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rbar_a2dac_write(_start, _buf)?;
                }
                if _start < 3508 && _end > 3504 {
                    let _offset_start = 3504u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3508);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3504);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rasr_a2db0_write(_start, _buf)?;
                }
                if _start < 3512 && _end > 3508 {
                    let _offset_start = 3508u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3512);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3508);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rbar_a3db4_write(_start, _buf)?;
                }
                if _start < 3516 && _end > 3512 {
                    let _offset_start = 3512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .scs_mpu_rasr_a3db8_write(_start, _buf)?;
                }
            }
            (3580..=3583, 3581..=3584) => {
                if _start < 3584 && _end > 3580 {
                    let _offset_start = 3580u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3584);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3580);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_demcrdfc_write(_start, _buf)?;
                }
            }
            (3840..=3843, 3841..=3844) => {
                if _start < 3844 && _end > 3840 {
                    let _offset_start = 3840u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3844);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3840);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_stirf00_write(_start, _buf)?;
                }
            }
            (3892..=3911, 3893..=3912) => {
                if _start < 3896 && _end > 3892 {
                    let _offset_start = 3892u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3896);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3892);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_fpccrf34_write(_start, _buf)?;
                }
                if _start < 3900 && _end > 3896 {
                    let _offset_start = 3896u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3900);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3896);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_fpcarf38_write(_start, _buf)?;
                }
                if _start < 3904 && _end > 3900 {
                    let _offset_start = 3900u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(3904);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(3900);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().scs_fpdscrf3c_write(_start, _buf)?;
                }
                if _start < 3908 && _end > 3904 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 3912 && _end > 3908 {
                    return Err(MemError::WriteViolation);
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
pub struct Apb35(
    pub std::sync::Arc<std::sync::Mutex<super::peripheral::Peripherals>>,
);
impl icicle_vm::cpu::mem::IoMemory for Apb35 {
    fn read(&mut self, _addr: u64, _buf: &mut [u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb35::Apb35::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (16..=23, 17..=24) => {
                return Err(MemError::ReadViolation);
            }
            (28..=43, 29..=44) => {
                return Err(MemError::ReadViolation);
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_events_stopped104_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_events_ready108_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_events_endrx110_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (280..=283, 281..=284) => {
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_events_end118_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (288..=291, 289..=292) => {
                if _start < 292 && _end > 288 {
                    let _offset_start = 288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(292);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_events_endtx120_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    let _offset_start = 296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(300);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_events_acquired128_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (332..=335, 333..=336) => {
                if _start < 336 && _end > 332 {
                    let _offset_start = 332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_events_started14c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_shorts200_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_intenset304_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_intenclr308_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1024..=1027, 1025..=1028) => {
                if _start < 1028 && _end > 1024 {
                    let _offset_start = 1024u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1028);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1024);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_semstat400_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1088..=1091, 1089..=1092) => {
                if _start < 1092 && _end > 1088 {
                    let _offset_start = 1088u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1092);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1088);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_status440_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_enable500_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1304 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_psel_sck0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_psel_miso4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_psel_mosi8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_psel_csnc_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1308 && _end > 1304 {
                    let _offset_start = 1304u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1308);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1304);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_rxd518_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_txd51c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_frequency524_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1332..=1367, 1333..=1368) => {
                if _start < 1348 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_rxd_ptr0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_rxd_maxcnt4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_rxd_amount8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_rxd_listc_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1364 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_txd_ptr0_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_txd_maxcnt4_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_txd_amount8_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf = &mut _buf
                            [_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        let value = self
                            .0
                            .lock()
                            .unwrap()
                            .apb35_txd_listc_read()?
                            .to_ne_bytes();
                        for _byte in _start.._end {
                            _buf[_byte as usize] = value[_byte as usize];
                        }
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_config554_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _offset_start = 1372u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1376);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1372);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_def55c_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            (1472..=1475, 1473..=1476) => {
                if _start < 1476 && _end > 1472 {
                    let _offset_start = 1472u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1476);
                    let _buf =
                        &mut _buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1472);
                    let _end = (_start + _buf.len() as u64).max(4);
                    let value = self
                        .0
                        .lock()
                        .unwrap()
                        .apb35_orc5c0_read()?
                        .to_ne_bytes();
                    for _byte in _start.._end {
                        _buf[_byte as usize] = value[_byte as usize];
                    }
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
    fn write(&mut self, _addr: u64, _buf: &[u8]) -> MemResult<()> {
        let _instance_page =
            crate::peripheral::apb35::Apb35::page_to_index(_addr >> 12u32);
        let _start = _addr & 4095u64;
        let _end = _start + u64::try_from(_buf.len()).unwrap();
        match (_start, _end) {
            (16..=23, 17..=24) => {
                if _start < 20 && _end > 16 {
                    let _offset_start = 16u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(20);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(16);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_tasks_start10_write(_start, _buf)?;
                }
                if _start < 24 && _end > 20 {
                    let _offset_start = 20u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(24);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(20);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_tasks_stop14_write(_start, _buf)?;
                }
            }
            (28..=43, 29..=44) => {
                if _start < 32 && _end > 28 {
                    let _offset_start = 28u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(32);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(28);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_tasks_suspend1c_write(_start, _buf)?;
                }
                if _start < 36 && _end > 32 {
                    let _offset_start = 32u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(36);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(32);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_tasks_resume20_write(_start, _buf)?;
                }
                if _start < 40 && _end > 36 {
                    let _offset_start = 36u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(40);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(36);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_tasks_acquire24_write(_start, _buf)?;
                }
                if _start < 44 && _end > 40 {
                    let _offset_start = 40u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(44);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(40);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_tasks_release28_write(_start, _buf)?;
                }
            }
            (260..=267, 261..=268) => {
                if _start < 264 && _end > 260 {
                    let _offset_start = 260u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(264);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(260);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_events_stopped104_write(_start, _buf)?;
                }
                if _start < 268 && _end > 264 {
                    let _offset_start = 264u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(268);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(264);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_events_ready108_write(_start, _buf)?;
                }
            }
            (272..=275, 273..=276) => {
                if _start < 276 && _end > 272 {
                    let _offset_start = 272u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(276);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(272);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_events_endrx110_write(_start, _buf)?;
                }
            }
            (280..=283, 281..=284) => {
                if _start < 284 && _end > 280 {
                    let _offset_start = 280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_events_end118_write(_start, _buf)?;
                }
            }
            (288..=291, 289..=292) => {
                if _start < 292 && _end > 288 {
                    let _offset_start = 288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(292);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(288);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_events_endtx120_write(_start, _buf)?;
                }
            }
            (296..=299, 297..=300) => {
                if _start < 300 && _end > 296 {
                    let _offset_start = 296u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(300);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(296);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_events_acquired128_write(_start, _buf)?;
                }
            }
            (332..=335, 333..=336) => {
                if _start < 336 && _end > 332 {
                    let _offset_start = 332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(336);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(332);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_events_started14c_write(_start, _buf)?;
                }
            }
            (512..=515, 513..=516) => {
                if _start < 516 && _end > 512 {
                    let _offset_start = 512u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(516);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(512);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_shorts200_write(_start, _buf)?;
                }
            }
            (772..=779, 773..=780) => {
                if _start < 776 && _end > 772 {
                    let _offset_start = 772u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(776);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(772);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_intenset304_write(_start, _buf)?;
                }
                if _start < 780 && _end > 776 {
                    let _offset_start = 776u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(780);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(776);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_intenclr308_write(_start, _buf)?;
                }
            }
            (1024..=1027, 1025..=1028) => {
                return Err(MemError::WriteViolation);
            }
            (1088..=1091, 1089..=1092) => {
                if _start < 1092 && _end > 1088 {
                    let _offset_start = 1088u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1092);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1088);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_status440_write(_start, _buf)?;
                }
            }
            (1280..=1283, 1281..=1284) => {
                if _start < 1284 && _end > 1280 {
                    let _offset_start = 1280u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1284);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1280);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_enable500_write(_start, _buf)?;
                }
            }
            (1288..=1311, 1289..=1312) => {
                if _start < 1304 && _end > 1288 {
                    let _offset_start = 1288u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1304);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1288);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_psel_sck0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_psel_miso4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        let _offset_start = 8u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(12);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(8);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_psel_mosi8_write(_start, _buf)?;
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_psel_csnc_write(_start, _buf)?;
                    }
                }
                if _start < 1308 && _end > 1304 {
                    return Err(MemError::WriteViolation);
                }
                if _start < 1312 && _end > 1308 {
                    let _offset_start = 1308u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1312);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1308);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb35_txd51c_write(_start, _buf)?;
                }
            }
            (1316..=1319, 1317..=1320) => {
                if _start < 1320 && _end > 1316 {
                    let _offset_start = 1316u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1320);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1316);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_frequency524_write(_start, _buf)?;
                }
            }
            (1332..=1367, 1333..=1368) => {
                if _start < 1348 && _end > 1332 {
                    let _offset_start = 1332u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1348);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1332);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_rxd_ptr0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_rxd_maxcnt4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_rxd_listc_write(_start, _buf)?;
                    }
                }
                if _start < 1364 && _end > 1348 {
                    let _offset_start = 1348u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1364);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1348);
                    let _end = (_start + _buf.len() as u64).max(16);
                    if _start < 4 && _end > 0 {
                        let _offset_start = 0u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(4);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(0);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_txd_ptr0_write(_start, _buf)?;
                    }
                    if _start < 8 && _end > 4 {
                        let _offset_start = 4u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(8);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(4);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_txd_maxcnt4_write(_start, _buf)?;
                    }
                    if _start < 12 && _end > 8 {
                        return Err(MemError::WriteViolation);
                    }
                    if _start < 16 && _end > 12 {
                        let _offset_start = 12u64.saturating_sub(_start);
                        let _offset_end =
                            _buf.len() as u64 - _end.saturating_sub(16);
                        let _buf =
                            &_buf[_offset_start as usize.._offset_end as usize];
                        let _start = _start.saturating_sub(12);
                        let _end = (_start + _buf.len() as u64).max(4);
                        self.0
                            .lock()
                            .unwrap()
                            .apb35_txd_listc_write(_start, _buf)?;
                    }
                }
                if _start < 1368 && _end > 1364 {
                    let _offset_start = 1364u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1368);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1364);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0
                        .lock()
                        .unwrap()
                        .apb35_config554_write(_start, _buf)?;
                }
            }
            (1372..=1375, 1373..=1376) => {
                if _start < 1376 && _end > 1372 {
                    let _offset_start = 1372u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1376);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1372);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb35_def55c_write(_start, _buf)?;
                }
            }
            (1472..=1475, 1473..=1476) => {
                if _start < 1476 && _end > 1472 {
                    let _offset_start = 1472u64.saturating_sub(_start);
                    let _offset_end =
                        _buf.len() as u64 - _end.saturating_sub(1476);
                    let _buf =
                        &_buf[_offset_start as usize.._offset_end as usize];
                    let _start = _start.saturating_sub(1472);
                    let _end = (_start + _buf.len() as u64).max(4);
                    self.0.lock().unwrap().apb35_orc5c0_write(_start, _buf)?;
                }
            }
            _ => return Err(MemError::Unmapped),
        }
        #[allow(unreachable_code)]
        Ok(())
    }
}
